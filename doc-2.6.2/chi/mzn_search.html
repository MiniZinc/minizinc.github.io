

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.5. 搜索 &mdash; The MiniZinc Handbook 2.6.2</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/mzn_search.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.6. MiniZinc中的有效建模实践" href="efficient.html" />
    <link rel="prev" title="2.4. 选项类型" href="optiontypes.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.6.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. Minizinc 指南</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. MiniZinc基本模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. 更多复杂模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. 谓词和函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. 选项类型</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.5. 搜索</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">2.5.1. 有限域搜索</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">2.5.2. 搜索注解</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">2.5.3. 注解</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. MiniZinc中的有效建模实践</a></li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. 在MiniZinc中对布尔可满足性问题建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc和展平</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_2_tutorial.html">2. Minizinc 指南</a> &raquo;</li>
        
      <li>2.5. 搜索</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sec-search">
<span id="id1"></span><h1>2.5. 搜索<a class="headerlink" href="#sec-search" title="Permalink to this headline">¶</a></h1>
<p id="index-0">MiniZinc默认没有我们想如何搜索解的声明。这就把搜索全部都留给下层的求解器了。
但是有些时候，尤其是对组合整数问题，我们或许想规定搜索应该如何去进行。
这就需要我们和求解器沟通出一个搜索策略 <span class="target" id="index-1"></span>search 。注意，搜索策略 <em>不</em> 真的是模型的一部分。实际上，我们不要求每个求解器把所有可能的求解策略都实现了。
MiniZinc通过使用 <em>annotations</em> 来用一个稳定的方法跟约束求解器沟通额外的信息。</p>
<div class="section" id="id2">
<h2>2.5.1. 有限域搜索<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p id="index-2">利用有限域求解器搜索涉及到检查变量剩余的可能值以及选择进一步地约束一些变量。
搜索则会加一个新的约束来限制这个变量的剩余值（实际上猜测解可能存在于哪里），然后使用传播来确定其他的值是否可能存在于解中。
为了确保完全性，搜索会保留另外一个选择，而它是新约束的否定。
搜索会当有限域求解器发现所有的约束都被满足，此时一个解已经被找到，或者有约束不被满足时停止。
当不可满足出现的时候，搜索必须换另外一个不同的选择集合继续下去。通常有限域求解器使用 <span class="target" id="index-3"></span>深度优先搜索 ，它会撤销最后一个做的选择然后尝试做一个新的选择。</p>
<div class="literal-block-wrapper docutils container" id="ex-queens">
<div class="code-block-caption"><span class="caption-number">Listing 2.5.1 </span><span class="caption-text">n皇后问题模型 (<a class="reference download internal" href="downloads/nqueens.mzn" download=""><tt class="xref download docutils literal">nqueens.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="p">;</span><span class="s"> </span><span class="c">% i列的皇后在行q[i]</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">);</span><span class="s">                       </span><span class="c">% 不同行</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% 不同对角线</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% 上+下</span><span class="s"></span>

<span class="c">% 搜索</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>有限域问题的一个简单例子是 <span class="math notranslate nohighlight">\(n\)</span> 皇后问题，它要求我们放置 <span class="math notranslate nohighlight">\(n\)</span> 个皇后在 <span class="math notranslate nohighlight">\(n \times n\)</span> 棋盘上使得任何两个都不会互相攻击。变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> 记录了在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> 列的皇后放置在哪一行上。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 约束确保了任何两个皇后都不会在同一行或者对角线上。 <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.5.1</span></a> 的左边给出了 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">9</span><span class="s"></span></code> 的典型（部分）搜索树。我们首选设置 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code> ，
这样就可以从其他变量的定义域里面移除一些数值，例如 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"></span></code> 不能取值1或者2.
我们接下来设置 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="s"></span></code> ，然后进一步地从其他变量的定义域里面移除一些数值。
我们设置 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="s"></span></code> （它最早的可能值）。在这三个决策后，棋盘的状态显示为 <a class="reference internal" href="#fig-9q-b"><span class="std std-numref">Fig. 2.5.2</span></a> 。其中皇后表示已经固定的皇后位置。星星表示此处放置的皇后会攻击到已经放置的皇后，所以我们不能在此处放置皇后。</p>
<div class="figure" id="id5">
<span id="fig-9q-a"></span><img alt="images/tree-4.svg" src="images/tree-4.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.1 </span><span class="caption-text">9皇后问题的部分搜索树</span></p>
</div>
<div class="figure" id="id6">
<span id="fig-9q-b"></span><img alt="images/chess9x9-3.svg" src="images/chess9x9-3.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.2 </span><span class="caption-text">在加入 <tt class="docutils literal">q[1] = 1</tt>, <tt class="docutils literal">q[2] = 4</tt>, <tt class="docutils literal">q[3] = 5</tt> 的状态</span></p>
</div>
<div class="figure" id="id7">
<span id="fig-9q-c"></span><img alt="images/chess9x9-4.svg" src="images/chess9x9-4.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.3 </span><span class="caption-text">在进一步加入 <tt class="docutils literal">q[6] = 4</tt> 后的初始传播</span></p>
</div>
<p>一个搜索策略决定要做哪一个选择。我们目前所做的决定都按照一个简单的策略：选择第一个还没有固定的变量，尝试设置它为它的最小可能值。按照这个策略，下一个决策应该是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="s"></span></code> 。变量选择的另外一个策略是选择现在可能值集合 <em>定义域</em> 最小的变量。按照这个所谓 <em>最先失败</em> 变量选择策略，下一个决策应该是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> 。如果我们做了这个决策，则初始的传播会去除掉 <a class="reference internal" href="#fig-9q-c"><span class="std std-numref">Fig. 2.5.3</span></a> 中显示的额外的值。
但是它使得 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"></span></code> 只剩余有一个值。所以 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="s"></span></code> 被执行。但是这又使得 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"></span></code> 也只剩余一个值2。因此这个时候有个约束一定会被违反。我们检测到了不满足性，求解器必须回溯取消最后一个决策 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> 并且加入它的否定 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> （引导我们到了 <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.5.1</span></a> 中树的状态(c)），即强制使 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">8</span><span class="s"></span></code> 。这使得有些值从定义域中被去除。我们接下来继续重新启用搜索策略来决定该怎么做。</p>
<p>很多有限域搜索被定义为这种方式：选择一个变量来进一步约束，然后选择如何进一步地约束它。</p>
</div>
<div class="section" id="id3">
<h2>2.5.2. 搜索注解<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p id="index-4">MiniZinc中的搜索注解注明了为了找到一个问题的解应如何去搜索。
注解附在求解项，在关键字 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"></span></code> 之后。
搜索注解</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>出现在求解项中。注解使用连接符 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="s"></span></code> 附为模型的一部分。
这个搜索注解意思是我们应该按照从整型变量数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> 中选择拥有最小现行定义域的变量（这个是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span><span class="s"></span></code> 规则），然后尝试设置其为它的最小可能值（ <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span><span class="s"></span></code> 值选择），纵观整个搜索树来搜索（ <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">complete</span><span class="s"></span></code> 搜索）。</p>
<div class="admonition- admonition" id="defblock-0">
<p class="first admonition-title">基本搜素注解</p>
<p id="index-5">我们有三个基本搜索注解，相对应于不同的基本搜索类型：</p>
<ul class="simple">
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">int_search</span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">约束选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="s"></span></code> 是一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code> 类型的一维数组， <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量选择</span><span class="o">&gt;</span><span class="s"></span></code> 是一个接下来会讨论的变量选择注解， <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">约束选择</span><span class="o">&gt;</span><span class="s"></span></code> 是一个接下来会讨论的如何约束一个变量的选择， <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"></span></code> 是一个搜索策略，我们暂时假设为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">complete</span><span class="s"></span></code></li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">bool_search</span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">约束选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="s"></span></code> 是一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="s"></span></code> 类型的一维数组，剩余的和上面一样。</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">set_search</span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">约束选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="s"></span></code> 是一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code> 类型的一维数组，剩余的和上面一样。</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">float_search</span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">精度</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">约束选择</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量</span><span class="o">&gt;</span><span class="s"></span></code> 是一个一维 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="s"></span></code> 数组, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;precision&gt;</span><span class="s"></span></code> 是一个固定的用于表示 <span class="math notranslate nohighlight">\(\epsilon\)</span> 浮点数, 其中两个数之差低于这个浮点数时被认为相等。剩余的和上面一样。</li>
</ul>
<p id="index-6">变量选择注解的例子有：</p>
<ul class="simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">input_order</span><span class="s"></span></code>: 从数组中按照顺序选择</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span><span class="s"></span></code>: 选择拥有最小定义域大小的变量，以及</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">smallest</span><span class="s"></span></code>: 选择拥有最小值的变量。</li>
</ul>
<p id="index-7">约束一个变量的方式有：</p>
<ul class="simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span><span class="s"></span></code>: 赋最小的定义域内的值给变量，</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_median</span><span class="s"></span></code>: 赋定义域内的中间值给变量，</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_random</span><span class="s"></span></code>: 从定义域中取一个随机的值赋给变量，以及</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_split</span><span class="s"></span></code> 把变量定义域一分为二然后去除掉上半部分。</li>
</ul>
<p class="last">对于完全搜素， <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">策略</span><span class="o">&gt;</span><span class="s"></span></code> 基本都是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">complete</span><span class="s"></span></code> 。关于一份完整的变量和约束选择注解，请参看MiniZinc参考文档中的FlatZinc说明书。</p>
</div>
<p>利用搜索构造注解，我们可以创建更加复杂的搜索策略。目前我们只有一个这样的注解。</p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="nf">seq_search</span><span class="p">([</span><span class="s"> </span><span class="o">&lt;</span><span class="s">搜素注解</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">搜素注解</span><span class="o">&gt;</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>顺序搜索构造首先执行对列表中的第一个注解所指定的变量的搜索，当这个注解中的所有的变量都固定后，它执行第二个搜索注解，等等。直到所有的搜索注解都完成。</p>
<p>我们来看一下 <a class="reference internal" href="predicates.html#ex-jobshop3"><span class="std std-numref">Listing 2.3.8</span></a> 中给出的车间作业调度模型。我们可以替换求解项为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">seq_search</span><span class="p">([</span><span class="s"></span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="nv">smallest</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">),</span><span class="s"></span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">([</span><span class="nv">end</span><span class="p">],</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)])</span><span class="s"></span>
<span class="s">      </span><span class="k">minimize</span><span class="s"> </span><span class="nv">end</span><span class="s"></span>
</pre></div>
</div>
<p>通过选择可以最早开始的作业并设置其为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> ，起始时间被设置为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> 。
当所有的起始时间都设置完后，终止时间 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">end</span><span class="s"></span></code> 或许还没有固定。因此我们设置其为它的最小可能取值。</p>
</div>
<div class="section" id="id4">
<h2>2.5.3. 注解<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p id="index-9">在MiniZinc中，注解是第一类对象。我们可以在模型中声明新的注解，以及声明和赋值给注解变量。</p>
<div class="admonition- admonition" id="defblock-1">
<p class="first admonition-title">注解</p>
<p id="index-10">注解有一个类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">ann</span><span class="s"></span></code> 。你可以声明一个注解参数 <span class="target" id="index-11"></span>parameter （拥有可选择的赋值）:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="o">&lt;</span><span class="s">标识符</span><span class="o">&gt;</span><span class="p">;</span><span class="s"></span>
<span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="o">&lt;</span><span class="s">标识符</span><span class="o">&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">&lt;</span><span class="s">注解表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>对注解变量赋值和对其他参数赋值一样操作。</p>
<p><span class="target" id="index-12"></span>表达式 ， <span class="target" id="index-13"></span>变量声明 ，和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"></span></code> 项都可以通过使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="s"></span></code> 操作符来成为注解。</p>
<p>使用注解项 <span class="target" id="index-14"></span>注解项 ，我们可以声明一个新的注解 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">annotation</span><span class="s"></span></code> <span class="target" id="index-15"></span>项 :</p>
<div class="last highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="o">&lt;</span><span class="s">注解名</span><span class="o">&gt;</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">参数定义</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">参数定义</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-queens-ann">
<div class="code-block-caption"><span class="caption-number">Listing 2.5.2 </span><span class="caption-text">n皇后问题的注解模型 (<a class="reference download internal" href="downloads/nqueens-ann.mzn" download=""><tt class="xref download docutils literal">nqueens-ann.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens-ann" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="nv">nwords</span><span class="p">);</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="nv">n</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">32</span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">)</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s">                      </span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s"></span>

<span class="kt">ann</span><span class="p">:</span><span class="s"> </span><span class="nv">search_ann</span><span class="p">;</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">search_ann</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-queens-ann"><span class="std std-numref">Listing 2.5.2</span></a> 中的程序阐述了注解声明，注解和注解变量的使用。
我们声明一个新的注解 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bitdomain</span><span class="s"></span></code> ，意思是来告诉求解器变量定义域应该通过大小为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">nwords</span><span class="s"></span></code> 的比特数组来表示。
注解附注在变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> 的声明之后。每一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 约束都被注解为内部注解 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">domain</span><span class="s"></span></code> ，而它指导求解器去使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 的定义域传播版本（如果有的话）。一个注解变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">search_ann</span><span class="s"></span></code> 被声明和使用来定义搜索策略。我们可以在一个单独的数据文件中来给出搜素策略的值。</p>
<p>搜索注解的例子或许有以下几种（我们假设每一行都在一个单独的数据文件中）</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>第一个只是按顺序来选择皇后然后设置其为最小值。第二个按顺序来选择皇后，但是设置中间值给它。第三个选择定义域大小最小的皇后，然后设置最小值给它。最后一个策略选择定义域大小最小的皇后，设置中间值给它。</p>
<p>不同的搜索策略对于能多容易找到解有显著的差异。下面的表格给出了一个简单的关于使用4种不同的搜索策略找到n皇后问题的第一个解所要做的决策个数（其中—表示超过100,000个决策）。很明显地看到，合适的搜索策略会产生显著的提高。</p>
<table border="1" class="table-nonfluid table-bordered docutils">
<colgroup>
<col width="10%" />
<col width="22%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">n</th>
<th class="head">input-min</th>
<th class="head">input-median</th>
<th class="head">ff-min</th>
<th class="head">ff-median</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>10</td>
<td>28</td>
<td>15</td>
<td>16</td>
<td>20</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>248</td>
<td>34</td>
<td>23</td>
<td>15</td>
</tr>
<tr class="row-even"><td>20</td>
<td>37330</td>
<td>97</td>
<td>114</td>
<td>43</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>7271</td>
<td>846</td>
<td>2637</td>
<td>80</td>
</tr>
<tr class="row-even"><td>30</td>
<td>—</td>
<td>385</td>
<td>1095</td>
<td>639</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>—</td>
<td>4831</td>
<td>—</td>
<td>240</td>
</tr>
<tr class="row-even"><td>40</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>236</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="efficient.html" class="btn btn-neutral float-right" title="2.6. MiniZinc中的有效建模实践" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="optiontypes.html" class="btn btn-neutral" title="2.4. 选项类型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, 2019, 2020 Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.6.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/js/doc-links.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>