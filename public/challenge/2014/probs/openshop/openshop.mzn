%-----------------------------------------------------------------------------%
% openshop.mzn
% Diarmuid Grimes (adapted from Ralph Becket jobshop.mzn)
%
% The open-shop scheduling problem.
% --------------------------------
%
% An open shop problem is identical to a jobshop with the exception that there
% is no ordering on the tasks of a job. 
% A job is a sequence of tasks.
% A task involves processing by a single machine for some duration.
% A machine can operate on at most one task at a time, for each job at most one task can
% be performed at a time.
% Tasks cannot be interrupted.
% The goal is to schedule each job to minimise the finishing time.
%
% The instances are from three sets of benchmarks:
% - "tai*" are instances generated by E. Taillard, "Benchmarks for basic scheduling 
%   problems", European Journal of Operations Research, 1993
% - "gp*" are instances generated by C. Geuret and C. Prins, "A new lower bound for 
%   the Open-Shop problem", Annals of Operations Research, 1999
% - "j*per*" are instances generated by P. Brucker and J. Hurink and B. Jurisch and 
%   B. Wostmann, "A branch \& bound algorithm for the open-shop problem", Discrete 
%   Applied Mathematic, 1997 
% The Brucker instances are generally the most difficult.
%-----------------------------------------------------------------------------%

include "globals.mzn";

%-----------------------------------------------------------------------------%
% Model parameters.
%

int: n_machines;                        % The number of machines.
int: n_jobs;                            % The number of jobs.
int: n_tasks_per_job = n_machines;      % Each job has one task per machine.
set of int: jobs = 1..n_jobs;
set of int: tasks = 1..n_tasks_per_job;

    % Array below not needed as 1st task of each job is run on 1st machine, etc.
    % job_task_machine[j, k] is the machine required by task k of job j.
    %
    % array [jobs, tasks] of 0..(n_machines-1): job_task_machine;

    % job_task_duration[j, k] is the duration of task k of job j.
    %
array [jobs, tasks] of int: job_task_duration;

    % minimal/maximal duration : bounds on end time
    % (strengthened lb compared to Beckets jsp by taking max of job durations, and machine durations)
int: min_duration = 
	max(
		max([sum([job_task_duration[i, j] | j in tasks]) | i in jobs ]),
		max([sum([job_task_duration[i, j] | i in jobs ]) | j in tasks])
	);

int: max_duration = sum(job_task_duration);

%-----------------------------------------------------------------------------%
% Model variables.
%

    % The start time of each job task.
    %
array [jobs, tasks] of var 0.. max_duration: job_task_start;

    % The finishing time is the time of the last task to complete.
    %
var min_duration..max_duration: objective;



%-----------------------------------------------------------------------------%
% Constraints.
%

    % Sanity check: tasks cannot take a negative amount of time.
    %
constraint
    forall ( j in jobs, k in tasks ) (
        job_task_duration[j, k]  >=  0
    );

    % No task can start earlier than time step 0.
    %
constraint
    forall ( j in jobs, k in 1..(n_tasks_per_job - 1) ) (
        0  <=  job_task_start[j, k]
    );

    % Tasks on the same job cannot overlap.
    %
constraint
    forall (
        j in jobs,
        ka in 1..(n_tasks_per_job - 1),
        kb in (ka + 1)..n_tasks_per_job
    ) (
        % (N.B.: if-then-elses flatten somewhat faster than implications.)
        no_overlap(
            job_task_start[j, ka], job_task_duration[j, ka],
            job_task_start[j, kb], job_task_duration[j, kb]
        )
    );

    % Tasks on the same machine cannot overlap.
    %
constraint
    forall (ja in jobs, jb in (ja + 1)..n_jobs, k in tasks) (
        % (N.B.: if-then-elses flatten somewhat faster than implications.)
        no_overlap(
            job_task_start[ja, k], job_task_duration[ja, k],
            job_task_start[jb, k], job_task_duration[jb, k]
            )
    );

predicate no_overlap(var int: t_a, var int: d_a, var int: t_b, var int: d_b)  =
	let { var bool: b } in (
		(    b  -> t_a + d_a <= t_b)
	/\	(not(b) -> t_b + d_b <= t_a)
	);

    % Tasks on the same job cannot overlap.
    %
constraint
	forall (j in jobs)(
		cumulative(
			[ job_task_start[j, k]    | k in tasks ],
			[ job_task_duration[j, k] | k in tasks ],
			[ 1                       | k in tasks ],
			1
		)
	);

	% Tasks on the same machine cannot overlap.
	%
constraint
	forall (k in tasks)(
		cumulative(
			[ job_task_start[j, k]    | j in jobs ],
			[ job_task_duration[j, k] | j in jobs ],
			[ 1                       | j in jobs ],
			1
		)
	);

    % The finishing time must be no earlier than the finishing time
    % of any task.
    %
constraint
    forall ( j in jobs, k in tasks ) (
    	job_task_start[j, k] + job_task_duration[j, k] <= objective
    );

%-----------------------------------------------------------------------------%
% Objective.
%

solve 
	:: seq_search([
		int_search([job_task_start[j, k] | j in jobs, k in tasks], 
			smallest, indomain_min, complete),
		int_search([objective], input_order, indomain_min, complete)
	])
	minimize objective;

output [
    "job_task_start = array2d(", show(jobs), ", ", show(tasks), ", ", show(job_task_start), ");\n",
    "objective = ", show(objective), ";\n"
];

%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%

