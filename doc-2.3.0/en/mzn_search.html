

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head><!-- analytics -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-63390311-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-63390311-1');
</script>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.5. Search &mdash; The MiniZinc Handbook 2.3.0</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/mzn_search.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.6. Effective Modelling Practices in MiniZinc" href="efficient.html" />
    <link rel="prev" title="2.4. Option Types" href="optiontypes.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotations">2.5.3. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restart">2.5.4. Restart</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warm-starts">2.5.5. Warm Starts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. Effective Modelling Practices in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_2_tutorial.html">2. A MiniZinc Tutorial</a> &raquo;</li>
        
      <li>2.5. Search</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="search">
<span id="sec-search"></span><h1>2.5. Search<a class="headerlink" href="#search" title="Permalink to this headline">¶</a></h1>
<p id="index-0">By default in MiniZinc there is no declaration of how
we want to search for solutions. This leaves the search
completely up to the underlying solver.
But sometimes, particularly for combinatorial integer problems,
we may want to specify how the search should be undertaken.
This requires us to communicate to the solver a <span class="target" id="index-1"></span>search strategy.
Note that the search strategy is <em>not</em> really part
of the model.
Indeed it is not required that each solver implements all
possible search strategies.
MiniZinc uses a consistent approach to communicating extra information
to the constraint solver using <em>annotations</em>.</p>
<div class="section" id="finite-domain-search">
<h2>2.5.1. Finite Domain Search<a class="headerlink" href="#finite-domain-search" title="Permalink to this headline">¶</a></h2>
<p id="index-2">Search in a finite domain solver involves examining the
remaining possible values of variables and choosing to
constrain some variables further.
The search then adds a new constraint that
restricts the remaining values
of the variable
(in effect guessing where the solution might lie),
and then applies propagation to determine what other values
are still possible in solutions.
In order to guarantee completeness, the search leaves another
choice which is the negation of the new constraint.
The search ends either when
the finite domain solver detects that all constraints are satisfied,
and hence a solution has been found, or that the constraints are
unsatisfiable.
When unsatisfiability is detected
the search must proceed down a different set of
choices.  Typically finite domain solvers use <span class="target" id="index-3"></span>depth first search
where they undo the last choice made and then try to make a new choice.</p>
<div class="literal-block-wrapper docutils container" id="ex-queens">
<div class="code-block-caption"><span class="caption-number">Listing 2.5.1 </span><span class="caption-text">Model for n-queens (<a class="reference download internal" href="downloads/nqueens.mzn" download=""><tt class="xref download docutils literal">nqueens.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="p">;</span><span class="s"> </span><span class="c">% queen is column i is in row q[i]</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">);</span><span class="s">                       </span><span class="c">% distinct rows</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% distinct diagonals</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% upwards+downwards</span><span class="s"></span>

<span class="c">% search</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>A simple example of a finite domain problem is the <span class="math notranslate nohighlight">\(n\)</span> queens
problem which requires that we
place <span class="math notranslate nohighlight">\(n\)</span> queens on an <span class="math notranslate nohighlight">\(n \times n\)</span> chessboard so that none can
attack another.
The variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> records in which row the queen in column <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code>
is placed. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraints ensure
that no two queens are on the same row, or diagonal.
A typical (partial) search tree
for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">9</span><span class="s"></span></code> is illustrated in <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.5.1</span></a>.
We first set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code>, this removes values from the domains of other
variables, so that e.g. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"></span></code> cannot take the values 1 or 2.
We then set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="s"></span></code>, this further removes values from the domains
of other variables. We set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="s"></span></code> (its earliest possible value).
The state of the chess board after these three decisions is shown in
<a class="reference internal" href="#fig-9q-b"><span class="std std-numref">Fig. 2.5.2</span></a> where the queens indicate the position
of the queens fixed already and
the stars indicate positions where we cannot place a queen
since it would be able to take an already placed queen.</p>
<div class="figure" id="id1">
<span id="fig-9q-a"></span><img alt="images/tree-4.svg" src="images/tree-4.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.1 </span><span class="caption-text">Partial search trees for 9 queens</span></p>
</div>
<div class="figure" id="id2">
<span id="fig-9q-b"></span><img alt="images/chess9x9-3.svg" src="images/chess9x9-3.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.2 </span><span class="caption-text">The state after the addition of <tt class="docutils literal">q[1] = 1</tt>, <tt class="docutils literal">q[2] = 4</tt>, <tt class="docutils literal">q[3] = 5</tt></span></p>
</div>
<div class="figure" id="id3">
<span id="fig-9q-c"></span><img alt="images/chess9x9-4.svg" src="images/chess9x9-4.svg" /><p class="caption"><span class="caption-number">Fig. 2.5.3 </span><span class="caption-text">The initial propagation on adding further <tt class="docutils literal">q[6] = 4</tt></span></p>
</div>
<p>A search strategy determines which choices to make. The decisions we have
made so far follow the simple strategy of picking the
first variable which is not fixed yet, and try to set it to its least
possible value.  Following this strategy the next decision would be
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="s"></span></code>.
An alternate strategy for variable selection is to choose the variable whose
current set of possible values (<em>domain</em>) is smallest.
Under this so called <em>first-fail</em>
variable selection strategy the next decision would be
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code>.
If we make this decision, then initially propagation removes the additional
values shown in <a class="reference internal" href="#fig-9q-c"><span class="std std-numref">Fig. 2.5.3</span></a>. But this leaves only one value for
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"></span></code>, <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="s"></span></code>, so this is forced, but then this leaves only one
possible value for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"></span></code>, that is 2. Hence a constraint must be
violated. We have detected unsatisfiability, and the solver must backtrack
undoing the last decision <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> and adding its negation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code>
(leading us to state (c) in the tree in <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.5.1</span></a>)
which forces <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">8</span><span class="s"></span></code>. This removes some values from the domain
and then we again reinvoke the search strategy to decide what to do.</p>
<p>Many finite domain searches are defined in this way:
choose a variable to constrain further, and then choose how to
constrain it further.</p>
</div>
<div class="section" id="search-annotations">
<h2>2.5.2. Search Annotations<a class="headerlink" href="#search-annotations" title="Permalink to this headline">¶</a></h2>
<p id="index-4">Search annotations in MiniZinc
specify how to search in order to find a solution to the
problem. The annotation is attached to the solve item, after the keyword
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"></span></code>.
The search annotation</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>appears on the solve item. Annotations are attached to parts of
the model using the connector <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="s"></span></code>.
This search annotation means that we should search by selecting from
the array of integer variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code>, the variable with the smallest
current domain (this is the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span><span class="s"></span></code> rule), and try setting
it to its smallest possible value
(<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span><span class="s"></span></code>
value selection).</p>
<div class="admonition-basic-search-annotations admonition" id="defblock-0">
<p class="first admonition-title">Basic search annotations</p>
<p id="index-5">There are three basic search annotations corresponding to different
basic variable types:</p>
<ul class="simple">
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">int_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span><span class="s"></span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code>,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;varchoice&gt;</span><span class="s"></span></code> is a variable choice annotation discussed below,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"></span></code> is a choice of how to constrain a variable, discussed
below.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">bool_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span><span class="s"></span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="s"></span></code>
and the rest are as above.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">set_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span><span class="s"></span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code>
and the rest are as above.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">float_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;precision&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span><span class="s"></span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="s"></span></code>,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;precision&gt;</span><span class="s"></span></code> is a fixed float specifying the <span class="math notranslate nohighlight">\(\epsilon\)</span> below which
two float values are considered equal,
and the rest are as above.</li>
</ul>
<p id="index-6">Example variable choice annotations are:</p>
<ul class="simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">input_order</span><span class="s"></span></code>: choose in order from the array</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span><span class="s"></span></code>: choose the variable with the smallest domain size, and</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">smallest</span><span class="s"></span></code>: choose the variable with the smallest value in its domain.</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">dom_w_deg</span><span class="s"></span></code>: choose the variable with the smallest value of domain
size divided by weighted degree, which is the number of times it has been
in a constraint that caused failure earlier in the search.</li>
</ul>
<p id="index-7">Example ways to constrain a variable are:</p>
<ul class="simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span><span class="s"></span></code>: assign the variable its smallest domain value,</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_median</span><span class="s"></span></code>: assign the variable its median domain value,</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_random</span><span class="s"></span></code>: assign the variable a random value from its domain, and</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_split</span><span class="s"></span></code> bisect the variables domain excluding the upper half.</li>
</ul>
<p>For backwards compatibility with older version of MiniZinc, the search
annotations can be called with an additional argument that represents the
search strategy to use. The only such strategy that is currently supported is
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">complete</span><span class="s"></span></code>, meaning an exhaustive exploration of the search space. With
the additional argument, an annotation might then look like this:
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span></code>.</p>
<p class="last">For a complete list of variable and constraint choice annotations
see the FlatZinc specification in the MiniZinc reference
documentation.</p>
</div>
<p>We can construct more complex search strategies using search
constructor annotations. There is only one such annotation at present:</p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="nf">seq_search</span><span class="p">([</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">search</span><span class="o">-</span><span class="kt">ann</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">search</span><span class="o">-</span><span class="kt">ann</span><span class="o">&gt;</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>The sequential search constructor first undertakes the search given
by the first annotation in its list, when all variables in this annotation
are fixed it undertakes the second search annotation, etc. until all
search annotations are complete.</p>
<p>Consider the jobshop scheduling model shown in <a class="reference internal" href="predicates.html#ex-jobshop3"><span class="std std-numref">Listing 2.3.8</span></a>.
We could replace the solve item with</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">seq_search</span><span class="p">([</span><span class="s"></span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="nv">smallest</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">),</span><span class="s"></span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">([</span><span class="nv">end</span><span class="p">],</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)])</span><span class="s"></span>
<span class="s">      </span><span class="k">minimize</span><span class="s"> </span><span class="nv">end</span><span class="s"></span>
</pre></div>
</div>
<p>which tries to set start times <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> by choosing the job that can start
earliest and setting it to that time. When all start times are complete
the end time <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">end</span><span class="s"></span></code> may not be fixed. Hence we set it to
its minimal possible value.</p>
</div>
<div class="section" id="annotations">
<h2>2.5.3. Annotations<a class="headerlink" href="#annotations" title="Permalink to this headline">¶</a></h2>
<p id="index-9">Annotations are a first class object in MiniZinc. We
can declare new annotations in a model, and declare and assign
to annotation variables.</p>
<div class="admonition-annotations admonition" id="defblock-1">
<p class="first admonition-title">Annotations</p>
<p id="index-10">Annotations have a type <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">ann</span><span class="s"></span></code>.
You can declare an annotation
<span class="target" id="index-11"></span>parameter (with optional assignment):</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;ident&gt;</span><span class="p">;</span><span class="s"></span>
<span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;ident&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="cs">&lt;ann-expr&gt;</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>and assign to an annotation variable just as any other parameter.</p>
<p><span class="target" id="index-12"></span>Expressions, <span class="target" id="index-13"></span>variable declarations,
and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"></span></code> items can all
be annotated using the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="s"></span></code> operator.</p>
<p>We can declare a new <span class="target" id="index-14"></span>annotation
using the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">annotation</span><span class="s"></span></code> <span class="target" id="index-15"></span>item:</p>
<div class="last highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="cs">&lt;annotation-name&gt;</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;arg-def&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;arg-def&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-queens-ann">
<div class="code-block-caption"><span class="caption-number">Listing 2.5.2 </span><span class="caption-text">Annotated model for n-queens (<a class="reference download internal" href="downloads/nqueens-ann.mzn" download=""><tt class="xref download docutils literal">nqueens-ann.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens-ann" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="nv">nwords</span><span class="p">);</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="nv">n</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">32</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">)</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s">                      </span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s"></span>

<span class="kt">ann</span><span class="p">:</span><span class="s"> </span><span class="nv">search_ann</span><span class="p">;</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">search_ann</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The program in <a class="reference internal" href="#ex-queens-ann"><span class="std std-numref">Listing 2.5.2</span></a> illustrates the use of annotation
declarations, annotations and annotation variables.
We declare a new annotation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bitdomain</span><span class="s"></span></code> which is meant to tell
the solver that variables domains should be represented via bit arrays
of size <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">nwords</span><span class="s"></span></code>.
The annotation is attached to the declarations of the variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code>.
Each of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraints is annotated with
the built in annotation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">domain</span><span class="s"></span></code>
which instructs the solver to use
the domain propagating version of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> if it has one.
An annotation variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">search_ann</span><span class="s"></span></code> is declared and used
to define the search strategy.  We can give the value to the search
strategy in a separate data file.</p>
<p>Example search annotations might be the following (where
we imagine each line is in a separate data file)</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">);</span><span class="s"></span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_random</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>The first just tries the queens in order setting them to the
minimum value, the second tries the queens variables in order, but sets
them to their median value, the third tries the queen variable with smallest
domain and sets it to the minimum value, and the final strategy
tries the queens variable with smallest domain setting it to its median
value.</p>
<p>Different search strategies can make a significant difference in
how easy it is to find solutions.
A small comparison of the number of failures made to find the first solution
of the n-queens problems using the 5 different search strategies
is shown in the table below (where — means more than 100,000 failures).
Clearly the right search strategy can make a significant difference, and variables selection is more important than value selection, except that for this
problem random value selection is very powerful.</p>
<table border="1" class="table-nonfluid table-bordered docutils">
<colgroup>
<col width="8%" />
<col width="17%" />
<col width="22%" />
<col width="13%" />
<col width="17%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">n</th>
<th class="head">input-min</th>
<th class="head">input-median</th>
<th class="head">ff-min</th>
<th class="head">ff-median</th>
<th class="head">input-random</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>10</td>
<td>22</td>
<td>2</td>
<td>5</td>
<td>0</td>
<td>6</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>191</td>
<td>4</td>
<td>4</td>
<td>12</td>
<td>39</td>
</tr>
<tr class="row-even"><td>20</td>
<td>20511</td>
<td>32</td>
<td>27</td>
<td>16</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>2212</td>
<td>345</td>
<td>51</td>
<td>25</td>
<td>2</td>
</tr>
<tr class="row-even"><td>30</td>
<td>—</td>
<td>137</td>
<td>22</td>
<td>66</td>
<td>9</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>—</td>
<td>1722</td>
<td>52</td>
<td>12</td>
<td>12</td>
</tr>
<tr class="row-even"><td>40</td>
<td>—</td>
<td>—</td>
<td>16</td>
<td>44</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>—</td>
<td>—</td>
<td>41</td>
<td>18</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="restart">
<h2>2.5.4. Restart<a class="headerlink" href="#restart" title="Permalink to this headline">¶</a></h2>
<p id="index-16">Any kind of depth first search for solving optimization problems
suffers from the problem that wrong decisions made at the top of
the search tree can take an exponential amount of search to undo.
One common way to ameliorate this problem is to restart the search
from the top thus having a chance to make different decisions.</p>
<p>MiniZinc includes annotations to control restart behaviour. These
annotations, like other search annotations, are attached to the
solve item of the model.</p>
<div class="admonition-restart-search-annotations admonition" id="defblock-2">
<p class="first admonition-title">Restart search annotations</p>
<p id="index-17">The different restart annotations control how frequently a restart occurs.
Restarts occur when a limit in nodes is reached, where search returns to the
top of the search tree and begins again. The possibilities are</p>
<ul class="simple">
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_constant</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span><span class="s"></span></code> is an integer
defining after how many nodes to restart.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_linear</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span><span class="s"></span></code> is an integer
defining the initial number of nodes before the first restart. The second
restart gets twice as many nodes, the third gets three times, etc.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_geometric</span><span class="p">(</span><span class="cs">&lt;base&gt;</span><span class="p">,</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;base&gt;</span><span class="s"></span></code> is a
float and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span><span class="s"></span></code> is an integer. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span><span class="s"></span></code> th restart has a
node limit of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">scale</span><span class="o">&gt;</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">base</span><span class="o">&gt;</span><span class="s">^</span><span class="nv">k</span><span class="s"></span></code>.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_luby</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span><span class="s"></span></code> is an integer.
The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span><span class="s"></span></code> th restart gets <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">scale</span><span class="o">&gt;*</span><span class="nv">L</span><span class="p">[</span><span class="nv">k</span><span class="p">]</span><span class="s"></span></code> where :mzn`L[k]` is the
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span><span class="s"></span></code> th number in the Luby sequence. The Luby sequence looks like
1 1 2 1 1 2 4 1 1 2 1 1 2 4 8 …, that is it repeats two copies of the
sequence ending in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s">^</span><span class="nv">i</span><span class="s"></span></code> before adding the number <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s">^</span><span class="p">{</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">}</span><span class="s"></span></code>.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nv">restart_none</span><span class="s"></span></code> dont apply any restart
(useful for setting a <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">ann</span><span class="s"></span></code> parameter that controls restart).</li>
</ul>
<p class="last">Solvers behaviour where two or more restart annotations are used is
undefined.</p>
</div>
<p>Restart search is much more robust in finding solutions, since it can avoid
getting stuck in a non-productive area of the search.  Note that restart
search does not make much sense if the underlying search strategy does
not do something different the next time it starts at the top.
For example the search annotation</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span><span class="s"></span>
<span class="s">      </span><span class="p">::</span><span class="s"> </span><span class="nf">restart_linear</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="s"></span>
</pre></div>
</div>
<p>does not very much sense since the underlying search is deterministic and
each restart will just redo the same search as the previous search.
Some solvers record the parts of the search tree that have already been
searched and avoid them. This will mean deterministic restarts will simply
effectively continue the search from the previous position. This gives
no benefit to restarts, whose aim is to change decisions high in the search
tree.</p>
<p>The simplest way to ensure that something is different in each restart
is to use some randomization, either in variable choice or value choice.
Alternatively some variable selection strategies make use of information
gathered from earlier search and hence will give different behaviour, for
example <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">dom_w_deg</span><span class="s"></span></code>.</p>
<p>To see the effectiveness of restart lets examine the n-queens problem again
with the underlying search strategy</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_random</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>with one of four restart strategies</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">r1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">restart_constant</span><span class="p">(</span><span class="m">100</span><span class="p">);</span><span class="s"></span>
<span class="nv">r2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">restart_linear</span><span class="p">(</span><span class="m">100</span><span class="p">);</span><span class="s"></span>
<span class="nv">r3</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">restart_geometric</span><span class="p">(</span><span class="m">1.5</span><span class="p">,</span><span class="m">100</span><span class="p">);</span><span class="s"></span>
<span class="nv">r4</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">restart_luby</span><span class="p">(</span><span class="m">100</span><span class="p">);</span><span class="s"></span>
<span class="nv">r5</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">restart_none</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<table border="1" class="table-nonfluid table-bordered docutils">
<colgroup>
<col width="9%" />
<col width="19%" />
<col width="24%" />
<col width="19%" />
<col width="19%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">n</th>
<th class="head">constant</th>
<th class="head">linear</th>
<th class="head">geometric</th>
<th class="head">luby</th>
<th class="head">none</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>10</td>
<td>35</td>
<td>35</td>
<td>35</td>
<td>35</td>
<td>14</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>36</td>
<td>36</td>
<td>36</td>
<td>36</td>
<td>22</td>
</tr>
<tr class="row-even"><td>20</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>16</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>2212</td>
<td>345</td>
<td>51</td>
<td>25</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>30</td>
<td>—</td>
<td>137</td>
<td>22</td>
<td>66</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>—</td>
<td>1722</td>
<td>52</td>
<td>12</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>40</td>
<td>148</td>
<td>148</td>
<td>194</td>
<td>148</td>
<td>15</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>183</td>
<td>183</td>
<td>183</td>
<td>183</td>
<td>103</td>
</tr>
<tr class="row-even"><td>500</td>
<td>1480</td>
<td>1480</td>
<td>1480</td>
<td>1480</td>
<td>1434</td>
</tr>
<tr class="row-odd"><td>1000</td>
<td>994</td>
<td>994</td>
<td>994</td>
<td>994</td>
<td>994</td>
</tr>
</tbody>
</table>
<p>THE CURRENT EXPERIMENT IS USELESS!</p>
</div>
<div class="section" id="warm-starts">
<span id="sec-warm-starts"></span><h2>2.5.5. Warm Starts<a class="headerlink" href="#warm-starts" title="Permalink to this headline">¶</a></h2>
<p>In many cases when solving an optimization or satisfaction
problem we may have solved a
previous version of the problem which is very similar.  In this case it
can be advantageous to use the previous solution found when searching for
solution to the new problem. This is currently supported by some MIP backends.</p>
<p>The warm start annotations are attached to the solve item, just like other
search annotations.</p>
<div class="admonition-warm-start-search-annotations admonition" id="defblock-3">
<p class="first admonition-title">Warm start search annotations</p>
<p id="index-18">The different restart annotations control how frequently a restart occurs.
Restarts occur when a limit in nodes is reached, where search returns to the
top of the search tree and begins again. The possibilities are</p>
<ul class="last simple">
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span><span class="s"></span></code> is a one
dimensional array of integer variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span><span class="s"></span></code> is a
one dimensional array of integer of the same length giving the warm start values
for each integer variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span><span class="s"></span></code>.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span><span class="s"></span></code> is a one
dimensional array of float variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span><span class="s"></span></code> is a
one dimensional array of floats of the same length giving the warm start values
for each float variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span><span class="s"></span></code>.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span><span class="s"></span></code> is a one
dimensional array of Boolean variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span><span class="s"></span></code> is a
one dimensional array of Booleans of the same length giving the warm start values
for each Boolean variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span><span class="s"></span></code>.</li>
<li><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span><span class="s"></span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span><span class="s"></span></code> is a one
dimensional array of set variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span><span class="s"></span></code> is a
one dimensional array of sets of integers of the same length giving the warm start values
for each set variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span><span class="s"></span></code>.</li>
</ul>
</div>
<p>The warm start annotation can be used by the solver as part of value selection. For example, if the selected
variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> has in its current domain the warm start value <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> then this is
the value selected for the variable.  If not the solver uses the existing value selection rule
applicable to that variable.
The order of warm_starts, relative to other search annotations, can be
important (especially for CP), so they all might need to be put into a <tt class="docutils literal">seq_search</tt> as below:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0.0</span><span class="o">..</span><span class="m">10.5</span><span class="p">:</span><span class="s"> </span><span class="nv">xf</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">xs</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nv">xf</span><span class="p">)</span><span class="o">==</span><span class="m">2.4</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">5</span><span class="o">==</span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="nv">xs</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">xs</span><span class="p">)</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"></span>
<span class="s">  </span><span class="p">::</span><span class="s"> </span><span class="nf">warm_start_array</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s">                     </span><span class="c">%%% Can be on the upper level</span><span class="s"></span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">8,4</span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s">               </span><span class="c">%%% Use &lt;&gt; for missing values</span><span class="s"></span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xf</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="o">-</span><span class="m">5</span><span class="s">..</span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">5.6</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">4.7</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">),</span><span class="s"></span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="s">..</span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="m">6</span><span class="o">..</span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">7</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
<span class="s">  </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
<span class="s">  </span><span class="p">::</span><span class="s"> </span><span class="nf">seq_search</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"></span>
<span class="s">    </span><span class="nf">warm_start_array</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s">                      </span><span class="c">%%% Now included in seq_search to keep order</span><span class="s"></span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">5,2</span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s">             </span><span class="c">%%% Repeated warm_starts allowed but not specified</span><span class="s"></span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xf</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="o">-</span><span class="m">5</span><span class="s">..</span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">5.6</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">4.7</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">),</span><span class="s"></span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="s">..</span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="m">6</span><span class="o">..</span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">7</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s"></span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="nv">b</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="l">true</span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s"></span>
<span class="s">    </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">  </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
<span class="s">  </span><span class="k">minimize</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">b</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">xf</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">intersect</span><span class="s"> </span><span class="nv">xs</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>If you’d like to provide a most complete warmstart information, please provide values for all
variables which are output when there is no output item or when compiled with <tt class="docutils literal">--output-mode dzn</tt>.
.. Still, this excludes auxiliary variables introduced by <tt class="docutils literal">let</tt> expressions. To capture them, you can customize
the output item, or try the FlatZinc level, see below.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="efficient.html" class="btn btn-neutral float-right" title="2.6. Effective Modelling Practices in MiniZinc" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="optiontypes.html" class="btn btn-neutral" title="2.4. Option Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.3.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
