

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head><!-- analytics -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-63390311-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-63390311-1');
</script>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.6. Effective Modelling Practices in MiniZinc &mdash; The MiniZinc Handbook 2.3.0</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/efficient.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.7. Boolean Satisfiability Modelling in MiniZinc" href="sat.html" />
    <link rel="prev" title="2.5. Search" href="mzn_search.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#effective-generators">2.6.2. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#redundant-constraints">2.6.3. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modelling-choices">2.6.4. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-modelling-and-channels">2.6.5. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetry">2.6.6. Symmetry</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#static-symmetry-breaking">2.6.6.1. Static Symmetry Breaking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-examples-of-symmetry">2.6.6.2. Other Examples of Symmetry</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_2_tutorial.html">2. A MiniZinc Tutorial</a> &raquo;</li>
        
      <li>2.6. Effective Modelling Practices in MiniZinc</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="effective-modelling-practices-in-minizinc">
<span id="sec-efficient"></span><h1>2.6. Effective Modelling Practices in MiniZinc<a class="headerlink" href="#effective-modelling-practices-in-minizinc" title="Permalink to this headline">¶</a></h1>
<p>There are almost always multiple
ways to model the same problem, some of which generate models which are
efficient to solve, and some of which are not.
In general it is very hard to tell a priori which models are the most
efficient
for solving a particular problem, and indeed it may critically depend on
the underlying solver used, and search strategy.  In this chapter we
concentrate
on modelling practices that avoid inefficiency in generating models
and generated models.</p>
<div class="section" id="variable-bounds">
<h2>2.6.1. Variable Bounds<a class="headerlink" href="#variable-bounds" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Finite domain propagation engines, which are the principle type of solver
targeted by MiniZinc, are more effective the tighter the bounds on the
variables involved.  They can also behave badly with problems which
have subexpressions that take large integer values, since they may
implicitly limit the size of integer variables.</p>
<div class="literal-block-wrapper docutils container" id="ex-grocery">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.1 </span><span class="caption-text">A model with unbounded variables (<a class="reference download internal" href="downloads/grocery.mzn" download=""><tt class="xref download docutils literal">grocery.mzn</tt></a>).</span><a class="headerlink" href="#ex-grocery" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item1</span><span class="p">;</span><span class="s"> </span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item3</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item4</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">711</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item4</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">711</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="p">;</span><span class="s"></span>
<span class="s">  </span>
<span class="k">constraint</span><span class="s">         </span><span class="m">0</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item2</span><span class="s"></span>
<span class="s">           </span><span class="o">/\</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>
<span class="s">  </span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;{&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item1</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item2</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item3</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">        </span><span class="nb">show</span><span class="p">(</span><span class="nv">item4</span><span class="p">),</span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The grocery problem shown in <a class="reference internal" href="#ex-grocery"><span class="std std-numref">Listing 2.6.1</span></a> finds 4 items
whose prices in dollars add up to 7.11 and multiply up to 7.11.
The variables are declared unbounded. Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver chuffed grocery.mzn
</pre></div>
</div>
<p>yields</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>=====UNSATISFIABLE=====
</pre></div>
</div>
<p>This is because the
intermediate expressions in the multiplication
are also <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code>
and are given default bounds in the solver
<span class="math notranslate nohighlight">\(-1,000,000 \dots 1,000,000\)</span>,
and these ranges are too small to hold the
values that the intermediate expressions may need to take.</p>
<p>Modifying the model so that the items are declared with tight bounds</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item3</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>results in a better model, since now MiniZinc can infer bounds on the
intermediate expressions and use these rather than the default bounds.
With this modification, executing the model gives</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{120,125,150,316}
----------
</pre></div>
</div>
<p>Note however that even the improved model may be too difficult for
some solvers.
Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver g12lazy grocery.mzn
</pre></div>
</div>
<p>does not return an answer, since the solver builds a huge representation
for the intermediate product variables.</p>
<div class="admonition-bounding-variables admonition" id="defblock-0">
<p class="first admonition-title">Bounding variables</p>
<p class="last" id="index-1">Always try to use bounded variables in models.
When using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">let</span><span class="s"></span></code>
declarations to introduce new variables, always try to define them
with correct and tight bounds.  This will make your model more efficient,
and avoid the possibility of unexpected overflows.
One exception is when you introduce a new variable which is
immediately defined as equal to an expression. Usually MiniZinc will be
able to infer effective bounds from the expression.</p>
</div>
</div>
<div class="section" id="effective-generators">
<h2>2.6.2. Effective Generators<a class="headerlink" href="#effective-generators" title="Permalink to this headline">¶</a></h2>
<p id="index-2">Imagine we want to count the number of triangles (<span class="math notranslate nohighlight">\(K_3\)</span> subgraphs)
appearing in a graph.  Suppose the graph is defined by
an adjacency matrix: <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> is true if nodes <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"></span></code> are
adjacent.  We might write</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s">  </span><span class="o">/\</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"></span>
<span class="s">                       </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]);</span><span class="s"></span>
</pre></div>
</div>
<p>which is certainly correct, but it examines all triples of nodes.
If the graph is sparse we can do better by realising that some
tests can be applied as soon as we select <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"></span></code>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s">  </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">],</span><span class="s"></span>
<span class="s">                        </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]);</span><span class="s"></span>
</pre></div>
</div>
<p>You can use the builitin <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="s"></span></code> <span class="target" id="index-3"></span>function to help
determine what is happening inside generators.</p>
<div class="admonition-tracing admonition" id="defblock-1">
<p class="first admonition-title">Tracing</p>
<p class="last">The function <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="p">(</span><span class="nv">s</span><span class="p">,</span><span class="nv">e</span><span class="p">)</span><span class="s"></span></code> prints the string <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> before
evaluating the expression <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">e</span><span class="s"></span></code> and returning its value.
It can be used in any context.</p>
</div>
<p>For example, we can see how many times the test is performed in the inner
loop for both versions of the calculation.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="bp">count</span><span class="o">=</span><span class="nb">sum</span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span>
<span class="s">          </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="nv">j</span><span class="o">&lt;</span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])</span><span class="s"> </span><span class="p">]);</span><span class="s"></span>
<span class="nv">adj</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Produces the output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
----------
</pre></div>
</div>
<p>indicating the inner loop is evaluated 64 times while</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="s">  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s">  </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">],</span><span class="s"></span>
<span class="s">                          </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])]);</span><span class="s"></span>
</pre></div>
</div>
<p>Produces the output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>++++++++++++++++
----------
</pre></div>
</div>
<p>indicating the inner loop is evaluated 16 times.</p>
<p>Note that you can use the dependent strings in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="s"></span></code> to
understand what is happening during model creation.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])(</span><span class="s"></span>
<span class="s">       </span><span class="nb">sum</span><span class="p">([</span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">i</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;,&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">j</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;,&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">k</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">|</span><span class="s"> </span>
<span class="s">             </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s">  </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]));</span><span class="s"></span>
</pre></div>
</div>
<p>will print out each of triangles that is found in the calculation.
It produces the output</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(1,2,3)
----------
</pre></div>
</div>
<p>We have to admit that we cheated a bit here: In certain circumstances, the MiniZinc compiler is in fact able to re-order the arguments in a <tt class="docutils literal">where</tt> clause automatically, so that they are evaluated as early as possible. In this case, adding the <tt class="docutils literal">trace</tt> function in fact <em>prevented</em> this optimisation. In general, it is however a good idea to help the compiler get it right, by splitting the <tt class="docutils literal">where</tt> clauses and placing them as close to the generators as possible.</p>
</div>
<div class="section" id="redundant-constraints">
<h2>2.6.3. Redundant Constraints<a class="headerlink" href="#redundant-constraints" title="Permalink to this headline">¶</a></h2>
<p id="index-4">The form of a model will affect how well the constraint solver can solve it.
In many cases adding constraints which are redundant, i.e. are logically
implied by the existing model, may improve the search for
solutions by making more information available to the solver earlier.</p>
<p>Consider the magic series problem from <a class="reference internal" href="modelling2.html#sec-complex"><span class="std std-ref">Complex Constraints</span></a>.
Running this for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">16</span><span class="s"></span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver gecode --all-solutions --statistics magic-series.mzn -D <span class="s2">&quot;n=16;&quot;</span>
</pre></div>
</div>
<p>might result in output</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = [12, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0];
----------
==========
</pre></div>
</div>
<p>and the statistics showing 89 failures required.</p>
<p>We can add redundant constraints to the model. Since each number
in the sequence counts the number of occurrences of a number we know
that they sum up to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>. Similarly we know that the sum of
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code> must also add up to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> because the sequence is magic.
Adding these constraints
gives the model in
<a class="reference internal" href="#ex-magic-series2"><span class="std std-numref">Listing 2.6.2</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ex-magic-series2">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.2 </span><span class="caption-text">Model solving the magic series problem with redundant constraints (<a class="reference download internal" href="downloads/magic-series2.mzn" download=""><tt class="xref download docutils literal">magic-series2.mzn</tt></a>).</span><a class="headerlink" href="#ex-magic-series2" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">))));</span><span class="s"></span>
<span class="c">% redundant</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s">   </span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;s = &quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">s</span><span class="p">),</span><span class="s"> &quot;;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">]</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>Running the same problem as before</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver gecode --all-solutions --statistics magic-series2.mzn -D <span class="s2">&quot;n=16;&quot;</span>
</pre></div>
</div>
<p>results in the same output, but with statistics showing just 14 failures
explored. The redundant constraints have allowed the solver to prune the
search much earlier.</p>
</div>
<div class="section" id="modelling-choices">
<h2>2.6.4. Modelling Choices<a class="headerlink" href="#modelling-choices" title="Permalink to this headline">¶</a></h2>
<p>There are many ways to model the same problem in MiniZinc,
although some may be more natural than others.
Different models may have very different efficiency of solving, and worse
yet, different models may be better or worse for different solving backends.
There are however some guidelines for usually producing better models:</p>
<div class="admonition-choosing-between-models admonition" id="defblock-2">
<p class="first admonition-title">Choosing between models</p>
<p>The better model is likely to have some of the following features</p>
<ul class="simple">
<li>smaller number of variables, or at least those that are not
functionally defined by other variables</li>
<li>smaller domain sizes of variables</li>
<li>more succinct, or direct, definition of the constraints of the model</li>
<li>uses global constraints as much as possible</li>
</ul>
<p class="last">In reality all this has to be tempered by how effective the search is for
the model.  Usually the effectiveness of search is hard to judge except by
experimentation.</p>
</div>
<p>Consider the problem of finding permutations of <span class="math notranslate nohighlight">\(n\)</span> numbers
from 1 to <span class="math notranslate nohighlight">\(n\)</span> such that the differences between adjacent numbers
also form a permutation of numbers 1 to <span class="math notranslate nohighlight">\(n-1\)</span>.
Note that the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables are functionally defined by
the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> variables so the raw search space is <span class="math notranslate nohighlight">\(n^n\)</span>.
The obvious way to model this problem is shown in <a class="reference internal" href="#ex-allint"><span class="std std-numref">Listing 2.6.3</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.3 </span><span class="caption-text">A natural model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s">      </span><span class="c">% sequence of numbers</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of differences</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">u</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">u</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]));</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;x = </span><span class="p">\(</span><span class="nv">x</span><span class="p">)</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>In this model the array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> represents the permutation of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>
numbers and the constraints are naturally represented using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code>.</p>
<p>Running the model</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver gecode --all-solutions --statistics allinterval.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>finds all solutions in 16077 nodes and 71ms</p>
<p>An alternate model uses array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> gives the
position of the number <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> in the sequence.
We also model the positions of the differences using variables
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code>. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> is the position in the sequence where the absolute difference
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> occurs.  If the values of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> differ by one
where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code>, meaning the
positions are adjacent, then <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> is constrained to be the earliest
of these positions.
We can add two redundant constraints to this model:
since we know that a difference of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="s"></span></code> must result, we know that
the positions of 1 and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> must be adjacent (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">abs</span><span class="p">(</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code>),
which also tell us that the position of difference <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="s"></span></code> is
the earlier of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="s"></span></code>, i.e.
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"></span></code>.
With this we can model the problem
as shown in <a class="reference internal" href="#ex-allint2"><span class="std std-numref">Listing 2.6.4</span></a>. The output statement recreates the
original sequence <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> from the array of positions <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint2">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.4 </span><span class="caption-text">An inverse model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint2" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s">  </span><span class="c">% position of each number</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"> </span><span class="c">% position of difference i</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="s"></span>
<span class="s">	   	 </span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">                 </span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"></span>
<span class="s">	   </span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_only</span><span class="s"></span>
<span class="s">  </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">i</span><span class="o">*</span><span class="p">(</span><span class="nb">fix</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"> </span><span class="gr">|</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="gr">]</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;x = </span><span class="p">\(</span><span class="nv">x</span><span class="p">)</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The inverse model has the same size as the original model, in terms of
number of variables and domain sizes.  But the inverse model has a much more
indirect way of modelling the relationship between the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables
as opposed to the relationship between <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables.
Hence we might expect the original model to be better.</p>
<p>The command</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver gecode --all-solutions --statistics allinterval2.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>finds all the solutions in  98343 nodes and 640 ms.
So the more direct modelling of the constraints is clearly paying off.</p>
<p>Note that the inverse model prints out the answers using the same <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> view of
the solution.  The way this is managed is using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">output_only</span><span class="s"></span></code> annotations.
The array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> is defined as a fixed array and annotated as <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">output_only</span><span class="s"></span></code>.
This means it will only be evaluated, and can only be used in output statements.
Once a solution for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> is discovered the value of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> is calculated
during output processing, and hence can be displayed in the output.</p>
<div class="admonition-output-only-annotation admonition" id="defblock-3">
<p class="first admonition-title">Output_only annotation</p>
<p class="last" id="index-5">The <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nv">output_only</span><span class="s"></span></code> annotation can be applied to variable definitions.
The variable defined must not be a <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"></span></code> type, it can only be <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">par</span><span class="s"></span></code>.
The variable must also have a right hand side definition giving its value.
This right hand side definition can make use of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">fix</span><span class="s"></span></code> functions to access
the values of decision variables, since it is evaluated at solution processing
time</p>
</div>
</div>
<div class="section" id="multiple-modelling-and-channels">
<span id="sec-multiple-modelling-and-channels"></span><h2>2.6.5. Multiple Modelling and Channels<a class="headerlink" href="#multiple-modelling-and-channels" title="Permalink to this headline">¶</a></h2>
<p>When we have two models for the same problem it may be
useful to use both models together by tying the variables in the two models
together, since each can give different information to the solver.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint3">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.5 </span><span class="caption-text">A dual model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="downloads/allinterval3.mzn" download=""><tt class="xref download docutils literal">allinterval3.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint3" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;inverse.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of numbers</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of differences</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">u</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]));</span><span class="s"> </span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s">  </span><span class="c">% position of each number</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"> </span><span class="c">% position of difference i</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="nv">u</span><span class="p">,</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="nb">show</span><span class="p">(</span><span class="nv">x</span><span class="p">),</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-allint3"><span class="std std-numref">Listing 2.6.5</span></a> gives a dual model combining features of
<a class="reference download internal" href="downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a> and <a class="reference download internal" href="downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>.
The beginning of the model is taken from <a class="reference download internal" href="downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a>.
We then introduce the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables from <a class="reference download internal" href="downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>.
We tie the variables together using the
global
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">inverse</span><span class="s"></span></code> constraint:
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">inverse</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="p">)</span><span class="s"></span></code> holds if <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> is the inverse function of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> (and vice versa),
that is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code>. A definition
is shown in <a class="reference internal" href="#ex-inverse"><span class="std std-numref">Listing 2.6.6</span></a>.
The model does not include the constraints relating the
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables, they are redundant (and indeed propagation
redundant)
so they do not add information for a
propagation solver. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraints are also missing since
they are made redundant (and propagation redundant) by the inverse
constraints.
The only constraints are the relationships of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables
and the redundant constraints on <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ex-inverse">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.6 </span><span class="caption-text">A definition of the <tt class="docutils literal">inverse</tt> global constraint (<a class="reference download internal" href="downloads/inverse.mzn" download=""><tt class="xref download docutils literal">inverse.mzn</tt></a>).</span><a class="headerlink" href="#ex-inverse" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">))(</span><span class="nv">invf</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">f</span><span class="p">))</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">f</span><span class="p">))(</span><span class="s"></span>
<span class="s">        </span><span class="nv">f</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">))(</span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">f</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">invf</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>One of the benefits of the dual model is that there is more scope for
defining different search strategies.
Running the dual model,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver g12fd --all-solutions --statistics allinterval3.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>which uses the search strategy of
the inverse model, labelling the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> variables,
finds all solutions in 1714 choice points and 0.5s.
Note that running the same model with labelling on the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> variables
requires 13142 choice points and 1.5s.</p>
</div>
<div class="section" id="symmetry">
<h2>2.6.6. Symmetry<a class="headerlink" href="#symmetry" title="Permalink to this headline">¶</a></h2>
<p>Symmetry is very common in constraint satisfaction and optimisation problems. To illustrate this, let us look again at the n-queens problem from <a class="reference internal" href="mzn_search.html#ex-queens"><span class="std std-numref">Listing 2.5.1</span></a>. The top left chess board in <a class="reference internal" href="#fig-queens-sym"><span class="std std-numref">Fig. 2.6.1</span></a> shows a solution to the 8-queens problems (labeled “original”). The remaining chess boards show seven symmetric variants of the same solution: rotated by 90, 180 and 270 degrees, and flipped vertically.</p>
<div class="figure" id="id1">
<span id="fig-queens-sym"></span><img alt="images/queens_symm.svg" src="images/queens_symm.svg" /><p class="caption"><span class="caption-number">Fig. 2.6.1 </span><span class="caption-text">Symmetric variants of an 8-queens solution</span></p>
</div>
<p>If we wanted to enumerate <em>all</em> solutions to the 8-queens problem, we could obviously save the solver some work by only enumerating <em>non-symmetric</em> solutions, and then generating the symmetric variants ourselves. This is one reason why we want to get rid of symmetry in constraint models. The other, much more important reason, is that the solver may also <strong>explore symmetric variants of non-solution states!</strong></p>
<p>For example, a typical constraint solver may try to place the queen in column 1 into row 1 (which is fine), and then try to put the column 2 queen into row 3, which, at first sight, does not violate any of the constraints. However, this configuration cannot be completed to a full solution (which the solver finds out after a little search). <a class="reference internal" href="#fig-queens-sym-unsat"><span class="std std-numref">Fig. 2.6.2</span></a> shows this configuration on the top left chess board. Now nothing prevents the solver from trying, e.g., the second configuration from the left in the bottom row of <a class="reference internal" href="#fig-queens-sym-unsat"><span class="std std-numref">Fig. 2.6.2</span></a>, where the queen in column 1 is still in row 1, and the queen in column 3 is placed in row 2. Therefore, even when only searching for a single solution, the solver may explore many symmetric states that it has already seen and proven unsatisfiable before!</p>
<div class="figure" id="id2">
<span id="fig-queens-sym-unsat"></span><img alt="images/queens_symm_unsat.svg" src="images/queens_symm_unsat.svg" /><p class="caption"><span class="caption-number">Fig. 2.6.2 </span><span class="caption-text">Symmetric variants of an 8-queens unsatisfiable partial assignment</span></p>
</div>
<div class="section" id="static-symmetry-breaking">
<h3>2.6.6.1. Static Symmetry Breaking<a class="headerlink" href="#static-symmetry-breaking" title="Permalink to this headline">¶</a></h3>
<p>The modelling technique for dealing with symmetry is called <em>symmetry breaking</em>, and in its simplest form, involves adding constraints to the model that rule out all symmetric variants of a (partial) assignment to the variables except one. These constraints are called <em>static symmetry breaking constraints</em>.</p>
<p>The basic idea behind symmetry breaking is to impose an <em>order</em>. For example, to rule out any vertical flips of the chess board, we could simply add the constraint that the queen in the first column must be in the top half of the board:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Convince yourself that this would remove exactly half of the symmetric variants in <a class="reference internal" href="#fig-queens-sym"><span class="std std-numref">Fig. 2.6.1</span></a>. In order to remove <em>all</em> symmetry, we need to work a bit harder.</p>
<p>Whenever we can express all symmetries as permutations of the array of variables, a set of <em>lexicographic ordering constraints</em> can be used to break all symmetry. For example, if the array of variables is called <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code>, and reversing the array is a symmetry of the problem, then the following constraint will break that symmetry:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="nv">x</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>How about two-dimensional arrays? Lexicographic ordering works just the same, we only have to coerce the arrays into one dimension. For example, the following breaks the symmetry of flipping the array along one of the diagonals (note the swapped indices in the second comprehension):</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">([</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>The great thing about using lexicographic ordering constraints is that we can add multiple ones (to break several symmetries simultaneously), without them interfering with each other, as long as we keep the order in the first argument the same.</p>
<p>For the n-queens problem, unfortunately this technique does not immediately apply, because some of its symmetries cannot be described as permutations of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> array. The trick to overcome this is to express the n-queens problem in terms of Boolean variables that model, for each field of the board, whether it contains a queen or not. Now all the symmetries can be modeled as permutations of this array. Since the main constraints of the n-queens problem are much easier to express with the integer <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> array, we simply use both models together and add channeling constraints between them, as explained in <a class="reference internal" href="#sec-multiple-modelling-and-channels"><span class="std std-ref">Multiple Modelling and Channels</span></a>.</p>
<p>The full model, with added Boolean variables, channeling constraints and symmetry breaking constraints is shown in <a class="reference internal" href="#ex-queens-sym"><span class="std std-numref">Listing 2.6.7</span></a>. We can conduct a little experiment to check whether it successfully breaks all the symmetry. Try running the model with increasing values for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>, e.g. from 1 to 10, counting the number of solutions (e.g., by using the <tt class="docutils literal">-s</tt> flag with the Gecode solver, or selecting “Print all solutions” as well as “Statistics for solving” in the IDE). You should get the following sequence of numbers of solutions: 1, 0, 0, 1, 2, 1, 6, 12, 46, 92. To verify the sequence, you can search for it in the <em>On-Line Encyclopedia of Integer Sequences</em> (<a class="reference external" href="http://oeis.org">http://oeis.org</a>).</p>
<div class="literal-block-wrapper docutils container" id="ex-queens-sym">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.7 </span><span class="caption-text">Partial model for n-queens with symmetry breaking (full model: <a class="reference download internal" href="downloads/nqueens_sym.mzn" download=""><tt class="xref download docutils literal">nqueens_sym.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens-sym" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% Map each position i,j to a Boolean telling us whether there is a queen at i,j</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">qb</span><span class="p">;</span><span class="s"></span>

<span class="c">% Channeling constraint</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="o">=</span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="c">% Lexicographic symmetry breaking constraints</span><span class="s"></span>
<span class="k">constraint</span><span class="s"></span>
<span class="s">    </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">),</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">),</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="other-examples-of-symmetry">
<h3>2.6.6.2. Other Examples of Symmetry<a class="headerlink" href="#other-examples-of-symmetry" title="Permalink to this headline">¶</a></h3>
<p>Many other problems have inherent symmetries, and breaking these can often make a significant difference in solving performance. Here is a list of some common cases:</p>
<ul class="simple">
<li>Bin packing: when trying to pack items into bins, any two bins that have
the same capacity are symmetric.</li>
<li>Graph colouring: When trying to assign colours to nodes in a graph such
that adjacent nodes must have different colours, we typically model
colours as integer numbers. However, any permutation of colours is again a
valid graph colouring.</li>
<li>Vehicle routing: if the task is to assign customers to certain vehicles,
any two vehicles with the same capacity may be symmetric (this is similar
to the bin packing example).</li>
<li>Rostering/time tabling: two staff members with the same skill set may be
interchangeable, just like two rooms with the same capacity or technical
equipment.</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sat.html" class="btn btn-neutral float-right" title="2.7. Boolean Satisfiability Modelling in MiniZinc" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mzn_search.html" class="btn btn-neutral" title="2.5. Search" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.3.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
