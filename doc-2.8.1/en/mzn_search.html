<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2.6. Search &mdash; The MiniZinc Handbook 2.8.1</title>
      <link rel="stylesheet" href="static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/mzn_search.html"/>
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="static/jquery.js?v=5d32c60e"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="static/documentation_options.js?v=2966be4c"></script>
        <script src="static/doctools.js?v=888ff710"></script>
        <script src="static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="static/js/doc-links.js?v=34cd1aa9"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.7. Effective Modelling Practices in MiniZinc" href="efficient.html" />
    <link rel="prev" title="2.5. Tuple and record types" href="tuple_and_record_types.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
  <a href="https://www.minizinc.org">
    
      <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
  </a>
      <div class="version">
        2.8.1
      </div>

  
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
  
    
  
  <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
  
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuple_and_record_types.html">2.5. Tuple and record types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.6. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-domain-search">2.6.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#search-annotations">2.6.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotations">2.6.3. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restart">2.6.4. Restart</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warm-starts">2.6.5. Warm Starts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.7. Effective Modelling Practices in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.8. Boolean Satisfiability Modelling in MiniZinc</a></li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.9. FlatZinc and Flattening</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

  

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part_2_tutorial.html"><span class="section-number">2. </span>A MiniZinc Tutorial</a></li>
      <li class="breadcrumb-item active"><span class="section-number">2.6. </span>Search</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="search">
<span id="sec-search"></span><h1><span class="section-number">2.6. </span>Search<a class="headerlink" href="#search" title="Link to this heading"></a></h1>
<p id="index-0">By default in MiniZinc there is no declaration of how
we want to search for solutions. This leaves the search
completely up to the underlying solver.
But sometimes, particularly for combinatorial integer problems,
we may want to specify how the search should be undertaken.
This requires us to communicate to the solver a <span class="target" id="index-1"></span>search strategy.
Note that the search strategy is <em>not</em> really part
of the model.
Indeed it is not required that each solver implements all
possible search strategies.
MiniZinc uses a consistent approach to communicating extra information
to the constraint solver using <em>annotations</em>.</p>
<section id="finite-domain-search">
<h2><span class="section-number">2.6.1. </span>Finite Domain Search<a class="headerlink" href="#finite-domain-search" title="Link to this heading"></a></h2>
<p id="index-2">Search in a finite domain solver involves examining the
remaining possible values of variables and choosing to
constrain some variables further.
The search then adds a new constraint that
restricts the remaining values
of the variable
(in effect guessing where the solution might lie),
and then applies propagation to determine what other values
are still possible in solutions.
In order to guarantee completeness, the search leaves another
choice which is the negation of the new constraint.
The search ends either when
the finite domain solver detects that all constraints are satisfied,
and hence a solution has been found, or that the constraints are
unsatisfiable.
When unsatisfiability is detected
the search must proceed down a different set of
choices.  Typically finite domain solvers use <span class="target" id="index-3"></span>depth first search
where they undo the last choice made and then try to make a new choice.</p>
<div class="literal-block-wrapper docutils container" id="ex-queens">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.1 </span><span class="caption-text">Model for n-queens (<a class="reference download internal" download="" href="downloads/27fe825c5c14f31364697520d4bbfdb7/nqueens.mzn"><tt class="xref download docutils literal">nqueens.mzn</tt></a>). <span class="mzn-playground-button"><a href="playground-nqueens.html" target="_blank" title="Open in Playground">&#9654;</a></span></span><a class="headerlink" href="#ex-queens" title="Link to this code"></a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="p">;</span><span class="s"> </span><span class="c">% queen in column i is in row q[i]</span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span>

<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">);</span><span class="s">                       </span><span class="c">% distinct rows</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% distinct diagonals</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]);</span><span class="s"> </span><span class="c">% upwards+downwards</span>

<span class="c">% search</span>
<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">];</span>
</pre></div>
</div>
</div>
<p>A simple example of a finite domain problem is the <span class="math notranslate nohighlight">\(n\)</span> queens
problem which requires that we
place <span class="math notranslate nohighlight">\(n\)</span> queens on an <span class="math notranslate nohighlight">\(n \times n\)</span> chessboard so that none can
attack another.
The variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span></code> records in which row the queen in column <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span></code>
is placed. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span></code> constraints ensure
that no two queens are on the same row, or diagonal.
A typical (partial) search tree
for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">9</span></code> is illustrated in <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.6.1</span></a>.
We first set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span></code>, this removes values from the domains of other
variables, so that e.g. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span></code> cannot take the values 1 or 2.
We then set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span></code>, this further removes values from the domains
of other variables. We set <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span></code> (its earliest possible value).
The state of the chess board after these three decisions is shown in
<a class="reference internal" href="#fig-9q-b"><span class="std std-numref">Fig. 2.6.2</span></a> where the queens indicate the position
of the queens fixed already and
the stars indicate positions where we cannot place a queen
since it would be able to take an already placed queen.</p>
<figure class="align-default" id="id1">
<span id="fig-9q-a"></span><img alt="images/tree-4.svg" src="images/tree-4.svg" /><figcaption>
<p><span class="caption-number">Fig. 2.6.1 </span><span class="caption-text">Partial search trees for 9 queens</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id2">
<span id="fig-9q-b"></span><img alt="images/chess9x9-3.svg" src="images/chess9x9-3.svg" /><figcaption>
<p><span class="caption-number">Fig. 2.6.2 </span><span class="caption-text">The state after the addition of <tt class="docutils literal">q[1] = 1</tt>, <tt class="docutils literal">q[2] = 4</tt>, <tt class="docutils literal">q[3] = 5</tt></span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id3">
<span id="fig-9q-c"></span><img alt="images/chess9x9-4.svg" src="images/chess9x9-4.svg" /><figcaption>
<p><span class="caption-number">Fig. 2.6.3 </span><span class="caption-text">The initial propagation on adding further <tt class="docutils literal">q[6] = 4</tt></span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>A search strategy determines which choices to make. The decisions we have
made so far follow the simple strategy of picking the
first variable which is not fixed yet, and try to set it to its least
possible value.  Following this strategy the next decision would be
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span></code>.
An alternate strategy for variable selection is to choose the variable whose
current set of possible values (<em>domain</em>) is smallest.
Under this so called <em>first-fail</em>
variable selection strategy the next decision would be
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span></code>.
If we make this decision, then initially propagation removes the additional
values shown in <a class="reference internal" href="#fig-9q-c"><span class="std std-numref">Fig. 2.6.3</span></a>. But this leaves only one value for
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span></code>, <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span></code>, so this is forced, but then this leaves only one
possible value for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">7</span><span class="p">]</span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">9</span><span class="p">]</span></code>, that is 2. Hence a constraint must be
violated. We have detected unsatisfiability, and the solver must backtrack
undoing the last decision <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span></code> and adding its negation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="m">4</span></code>
(leading us to state (c) in the tree in <a class="reference internal" href="#fig-9q-a"><span class="std std-numref">Fig. 2.6.1</span></a>)
which forces <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">8</span></code>. This removes some values from the domain
and then we again reinvoke the search strategy to decide what to do.</p>
<p>Many finite domain searches are defined in this way:
choose a variable to constrain further, and then choose how to
constrain it further.</p>
</section>
<section id="search-annotations">
<h2><span class="section-number">2.6.2. </span>Search Annotations<a class="headerlink" href="#search-annotations" title="Link to this heading"></a></h2>
<p id="index-4">Search annotations in MiniZinc
specify how to search in order to find a solution to the
problem. The annotation is attached to the solve item, after the keyword
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span></code>.
The search annotation</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span>
</pre></div>
</div>
<p>appears on the solve item. Annotations are attached to parts of
the model using the connector <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span></code>.
This search annotation means that we should search by selecting from
the array of integer variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span></code>, the variable with the smallest
current domain (this is the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span></code> rule), and try setting
it to its smallest possible value
(<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span></code>
value selection).</p>
<div class="admonition-basic-search-annotations admonition" id="defblock-0">
<p class="admonition-title">Basic search annotations</p>
<p id="index-5">There are three basic search annotations corresponding to different
basic variable types:</p>
<ul class="simple">
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">int_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span></code>,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;varchoice&gt;</span></code> is a variable choice annotation discussed below,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;constrainchoice&gt;</span></code> is a choice of how to constrain a variable, discussed
below.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">bool_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span></code>
and the rest are as above.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">set_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span></code>
and the rest are as above.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">float_search</span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;variables&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;precision&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoice&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;constrainchoice&gt;</span><span class="s"> </span><span class="p">)</span></code>
where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;variables&gt;</span></code> is a one dimensional array of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span></code>,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;precision&gt;</span></code> is a fixed float specifying the <span class="math notranslate nohighlight">\(\epsilon\)</span> below which
two float values are considered equal,
and the rest are as above.</p></li>
</ul>
<p id="index-6">Example variable choice annotations are:</p>
<ul class="simple">
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">input_order</span></code>: choose in order from the array</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">first_fail</span></code>: choose the variable with the smallest domain size, and</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">smallest</span></code>: choose the variable with the smallest value in its domain.</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">dom_w_deg</span></code>: choose the variable with the smallest value of domain
size divided by weighted degree, which is the number of times it has been
in a constraint that caused failure earlier in the search.</p></li>
</ul>
<p id="index-7">Example ways to constrain a variable are:</p>
<ul class="simple">
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_min</span></code>: assign the variable its smallest domain value,</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_median</span></code>: assign the variable its median domain value (or the smaller of the two middle values in case of an even number of elements in the domain),</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_random</span></code>: assign the variable a random value from its domain, and</p></li>
<li><p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">indomain_split</span></code> bisect the variables domain excluding the upper half.</p></li>
</ul>
<p>For backwards compatibility with older version of MiniZinc, the search
annotations can be called with an additional argument that represents the
search strategy to use. The only such strategy that is currently supported is
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">complete</span></code>, meaning an exhaustive exploration of the search space. With
the additional argument, an annotation might then look like this:
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span></code>.</p>
<p>For a complete list of variable and constraint choice annotations
see the FlatZinc specification in the MiniZinc reference
documentation.</p>
</div>
<p>We can construct more complex search strategies using search
constructor annotations. There is only one such annotation at present:</p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="nf">seq_search</span><span class="p">([</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">search</span><span class="o">-</span><span class="kt">ann</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">search</span><span class="o">-</span><span class="kt">ann</span><span class="o">&gt;</span><span class="s"> </span><span class="p">])</span>
</pre></div>
</div>
<p>The sequential search constructor first undertakes the search given
by the first annotation in its list, when all variables in this annotation
are fixed it undertakes the second search annotation, etc. until all
search annotations are complete.</p>
<p>Consider the jobshop scheduling model shown in <a class="reference internal" href="predicates.html#ex-jobshop3"><span class="std std-numref">Listing 2.3.9</span></a>.
We could replace the solve item with</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">seq_search</span><span class="p">([</span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="nv">smallest</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">),</span>
<span class="s">             </span><span class="nf">int_search</span><span class="p">([</span><span class="nv">end</span><span class="p">],</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)])</span>
<span class="s">      </span><span class="k">minimize</span><span class="s"> </span><span class="nv">end</span>
</pre></div>
</div>
<p>which tries to set start times <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span></code> by choosing the job that can start
earliest and setting it to that time. When all start times are complete
the end time <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">end</span></code> may not be fixed. Hence we set it to
its minimal possible value.</p>
</section>
<section id="annotations">
<h2><span class="section-number">2.6.3. </span>Annotations<a class="headerlink" href="#annotations" title="Link to this heading"></a></h2>
<p id="index-9">Annotations are a first class object in MiniZinc. We
can declare new annotations in a model, and declare and assign
to annotation variables.</p>
<div class="admonition-annotations admonition" id="defblock-1">
<p class="admonition-title">Annotations</p>
<p id="index-10">Annotations have a type <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">ann</span></code>.
You can declare an annotation
<span class="target" id="index-11"></span>parameter (with optional assignment):</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;ident&gt;</span><span class="p">;</span>
<span class="kt">ann</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;ident&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="cs">&lt;ann-expr&gt;</span><span class="s"> </span><span class="p">;</span>
</pre></div>
</div>
<p>and assign to an annotation variable just as any other parameter.</p>
<p><span class="target" id="index-12"></span>Expressions, <span class="target" id="index-13"></span>variable declarations,
and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span></code> items can all
be annotated using the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">::</span></code> operator.</p>
<p>We can declare a new <span class="target" id="index-14"></span>annotation
using the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">annotation</span></code> <span class="target" id="index-15"></span>item:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="cs">&lt;annotation-name&gt;</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="cs">&lt;arg-def&gt;</span><span class="p">,</span><span class="s"> ...</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;arg-def&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-queens-ann">
<div class="code-block-caption"><span class="caption-number">Listing 2.6.2 </span><span class="caption-text">Annotated model for n-queens (<a class="reference download internal" download="" href="downloads/4a4e90eb188338a26c30d417aa434b92/nqueens-ann.mzn"><tt class="xref download docutils literal">nqueens-ann.mzn</tt></a>). <span class="mzn-playground-button"><a href="playground-nqueens-ann.html" target="_blank" title="Open in Playground">&#9654;</a></span></span><a class="headerlink" href="#ex-queens-ann" title="Link to this code"></a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">annotation</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="nv">nwords</span><span class="p">);</span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">bitdomain</span><span class="p">(</span><span class="nv">n</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">32</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">);</span>

<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="nv">q</span><span class="p">)</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain_propagation</span><span class="p">;</span><span class="s">                      </span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain_propagation</span><span class="p">;</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain_propagation</span><span class="p">;</span>

<span class="kt">ann</span><span class="p">:</span><span class="s"> </span><span class="nv">search_ann</span><span class="p">;</span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">search_ann</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;Q&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">];</span>
</pre></div>
</div>
</div>
<p>The program in <a class="reference internal" href="#ex-queens-ann"><span class="std std-numref">Listing 2.6.2</span></a> illustrates the use of annotation
declarations, annotations and annotation variables.
We declare a new annotation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bitdomain</span></code> which is meant to tell
the solver that variables domains should be represented via bit arrays
of size <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">nwords</span></code>.
The annotation is attached to the declarations of the variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span></code>.
Each of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span></code> constraints is annotated with
the built in annotation <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">domain_propagation</span></code>
which instructs the solver to use
the domain propagating version of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span></code> if it has one.
An annotation variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">search_ann</span></code> is declared and used
to define the search strategy.  We can give the value to the search
strategy in a separate data file.</p>
<p>Example search annotations might be the following (where
we imagine each line is in a separate data file)</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">);</span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_median</span><span class="p">);</span>
<span class="nv">search_ann</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_random</span><span class="p">);</span>
</pre></div>
</div>
<p>The first just tries the queens in order setting them to the
minimum value, the second tries the queens variables in order, but sets
them to their median value, the third tries the queen variable with smallest
domain and sets it to the minimum value, and the final strategy
tries the queens variable with smallest domain setting it to its median
value.</p>
<p>Different search strategies can make a significant difference in
how easy it is to find solutions.
A small comparison of the number of failures made to find the first solution
of the n-queens problems using the 5 different search strategies
is shown in the table below (where — means more than 100,000 failures).
Clearly the right search strategy can make a significant difference, and variables selection is more important than value selection, except that for this
problem random value selection is very powerful.</p>
<table class="table-nonfluid table-bordered docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>n</p></th>
<th class="head"><p>input-min</p></th>
<th class="head"><p>input-median</p></th>
<th class="head"><p>ff-min</p></th>
<th class="head"><p>ff-median</p></th>
<th class="head"><p>input-random</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10</p></td>
<td><p>22</p></td>
<td><p>2</p></td>
<td><p>5</p></td>
<td><p>0</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>191</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>12</p></td>
<td><p>39</p></td>
</tr>
<tr class="row-even"><td><p>20</p></td>
<td><p>20511</p></td>
<td><p>32</p></td>
<td><p>27</p></td>
<td><p>16</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>25</p></td>
<td><p>2212</p></td>
<td><p>345</p></td>
<td><p>51</p></td>
<td><p>25</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>30</p></td>
<td><p>—</p></td>
<td><p>137</p></td>
<td><p>22</p></td>
<td><p>66</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-odd"><td><p>35</p></td>
<td><p>—</p></td>
<td><p>1722</p></td>
<td><p>52</p></td>
<td><p>12</p></td>
<td><p>12</p></td>
</tr>
<tr class="row-even"><td><p>40</p></td>
<td><p>—</p></td>
<td><p>—</p></td>
<td><p>16</p></td>
<td><p>44</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>45</p></td>
<td><p>—</p></td>
<td><p>—</p></td>
<td><p>41</p></td>
<td><p>18</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
</section>
<section id="restart">
<h2><span class="section-number">2.6.4. </span>Restart<a class="headerlink" href="#restart" title="Link to this heading"></a></h2>
<p id="index-16">Any kind of depth first search for solving optimization problems
suffers from the problem that wrong decisions made at the top of
the search tree can take an exponential amount of search to undo.
One common way to ameliorate this problem is to restart the search
from the top thus having a chance to make different decisions.</p>
<p>MiniZinc includes annotations to control restart behaviour. These
annotations, like other search annotations, are attached to the
solve item of the model.</p>
<div class="admonition-restart-search-annotations admonition" id="defblock-2">
<p class="admonition-title">Restart search annotations</p>
<p id="index-17">The different restart annotations control how frequently a restart occurs.
Restarts occur when a limit in nodes is reached, where search returns to the
top of the search tree and begins again. The possibilities are</p>
<ul class="simple">
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_constant</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span></code> is an integer
defining after how many nodes to restart.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_linear</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span></code> is an integer
defining the initial number of nodes before the first restart. The second
restart gets twice as many nodes, the third gets three times, etc.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_geometric</span><span class="p">(</span><span class="cs">&lt;base&gt;</span><span class="p">,</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;base&gt;</span></code> is a
float and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span></code> is an integer. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span></code> th restart has a
node limit of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">scale</span><span class="o">&gt;</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="o">&lt;</span><span class="nv">base</span><span class="o">&gt;</span><span class="s">^</span><span class="nv">k</span></code>.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">restart_luby</span><span class="p">(</span><span class="cs">&lt;scale&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;scale&gt;</span></code> is an integer.
The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span></code> th restart gets <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">scale</span><span class="o">&gt;*</span><span class="nv">L</span><span class="p">[</span><span class="nv">k</span><span class="p">]</span></code> where :mzn`L[k]` is the
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">k</span></code> th number in the Luby sequence. The Luby sequence looks like
1 1 2 1 1 2 4 1 1 2 1 1 2 4 8 …, that is it repeats two copies of the
sequence ending in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s">^</span><span class="nv">i</span></code> before adding the number <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s">^</span><span class="p">{</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">}</span></code>.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nv">restart_none</span></code> don’t apply any restart
(useful for setting a <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">ann</span></code> parameter that controls restart).</p></li>
</ul>
<p>If two or more restart annotations are used, the solver’s behaviour is
undefined.</p>
</div>
<p>Restart search is much more robust in finding solutions, since it can avoid
getting stuck in a non-productive area of the search.  Note that restart
search does not make much sense if the underlying search strategy does
not do something different the next time it starts at the top.
For example the search annotation</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">q</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">);</span>
<span class="s">      </span><span class="p">::</span><span class="s"> </span><span class="nf">restart_linear</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
<span class="s">      </span><span class="k">satisfy</span>
</pre></div>
</div>
<p>does not make very much sense since the underlying search is deterministic and
each restart will just redo the same search as the previous search.
Some solvers record the parts of the search tree that have already been
searched and avoid them. This will mean deterministic restarts will simply
effectively continue the search from the previous position. This gives
no benefit to restarts, whose aim is to change decisions high in the search
tree.</p>
<p>The simplest way to ensure that something is different in each restart
is to use some randomization, either in variable choice or value choice.
Alternatively some variable selection strategies make use of information
gathered from earlier search and hence will give different behaviour, for
example <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">dom_w_deg</span></code>.</p>
</section>
<section id="warm-starts">
<span id="sec-warm-starts"></span><h2><span class="section-number">2.6.5. </span>Warm Starts<a class="headerlink" href="#warm-starts" title="Link to this heading"></a></h2>
<p>In many cases when solving an optimization or satisfaction
problem we may have solved a
previous version of the problem which is very similar.  In this case it
can be advantageous to use the previous solution found when searching for
solution to the new problem. This is currently supported by some MIP backends.</p>
<p>The warm start annotations are attached to the solve item, just like other
search annotations.</p>
<div class="admonition-warm-start-search-annotations admonition" id="defblock-3">
<p class="admonition-title">Warm start search annotations</p>
<p id="index-18">Warm start annotations are used to indicate a (potentially partial or even invalid)
starting point for solvers which support them.</p>
<ul class="simple">
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span></code> is a one
dimensional array of integer variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span></code> is a
one dimensional array of integer of the same length giving the warm start values
for each integer variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span></code>.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span></code> is a one
dimensional array of float variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span></code> is a
one dimensional array of floats of the same length giving the warm start values
for each float variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span></code>.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span></code> is a one
dimensional array of Boolean variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span></code> is a
one dimensional array of Booleans of the same length giving the warm start values
for each Boolean variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span></code>.</p></li>
<li><p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">warm_start</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="cs">&lt;vals&gt;</span><span class="p">)</span></code> where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span></code> is a one
dimensional array of set variables, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vals&gt;</span></code> is a
one dimensional array of sets of integers of the same length giving the warm start values
for each set variable in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;</span><span class="nv">vars</span><span class="o">&gt;</span></code>.</p></li>
</ul>
<p>The <tt class="docutils literal">warm_start_array</tt> annotation takes a list of <tt class="docutils literal">warm_start</tt> annotations and can be used to specify an
ordering of the warm starts which is maintained in the FlatZinc.</p>
</div>
<p>The warm start annotation can be used by the solver as part of value selection. For example, if the selected
variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span></code> has in its current domain the warm start value <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span></code> then this is
the value selected for the variable.  If not the solver uses the existing value selection rule
applicable to that variable.
The order of warm_starts, relative to other search annotations, can be
important (especially for CP), so they all might need to be put into a <tt class="docutils literal">seq_search</tt> as below:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0.0</span><span class="o">..</span><span class="m">10.5</span><span class="p">:</span><span class="s"> </span><span class="nv">xf</span><span class="p">;</span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">;</span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">xs</span><span class="p">;</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">==</span><span class="m">1</span><span class="p">;</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nv">xf</span><span class="p">)</span><span class="o">==</span><span class="m">2.4</span><span class="p">;</span>
<span class="k">constraint</span><span class="s"> </span><span class="m">5</span><span class="o">==</span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="nv">xs</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">xs</span><span class="p">)</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">);</span>
<span class="k">solve</span>
<span class="s">  </span><span class="p">::</span><span class="s"> </span><span class="nf">warm_start_array</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s">                     </span><span class="c">%%% Can be on the upper level</span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">8,4</span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s">               </span><span class="c">%%% Use &lt;&gt; for missing values</span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xf</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="o">-</span><span class="m">5</span><span class="s">..</span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">5.6</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">4.7</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">),</span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="s">..</span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="m">6</span><span class="o">..</span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">7</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">)</span>
<span class="s">  </span><span class="p">]</span><span class="s"> </span><span class="p">)</span>
<span class="s">  </span><span class="p">::</span><span class="s"> </span><span class="nf">seq_search</span><span class="p">(</span><span class="s"> </span><span class="p">[</span>
<span class="s">    </span><span class="nf">warm_start_array</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s">                      </span><span class="c">%%% Now included in seq_search to keep order</span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">5,2</span><span class="p">]</span><span class="s"> </span><span class="p">),</span><span class="s">             </span><span class="c">%%% Repeated warm_starts allowed but not specified</span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xf</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="o">-</span><span class="m">5</span><span class="s">..</span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">5.6</span><span class="p">,</span><span class="o">&lt;&gt;</span><span class="p">,</span><span class="m">4.7</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">),</span>
<span class="s">      </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">,</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="s">..</span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="m">6</span><span class="o">..</span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="o">..</span><span class="m">7</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">)</span>
<span class="s">    </span><span class="p">]</span><span class="s"> </span><span class="p">),</span>
<span class="s">    </span><span class="nf">warm_start</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="nv">b</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="l">true</span><span class="p">]</span><span class="s"> </span><span class="p">),</span>
<span class="s">    </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">)</span>
<span class="s">  </span><span class="p">]</span><span class="s"> </span><span class="p">)</span>
<span class="s">  </span><span class="k">minimize</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">b</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">xf</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="s"> </span><span class="nv">xs</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">intersect</span><span class="s"> </span><span class="nv">xs</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="p">);</span>
</pre></div>
</div>
<p>If you’d like to provide a most complete warmstart information, please provide values for all
variables which are output when there is no output item or when compiled with <tt class="docutils literal">--output-mode dzn</tt>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tuple_and_record_types.html" class="btn btn-neutral float-left" title="2.5. Tuple and record types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="efficient.html" class="btn btn-neutral float-right" title="2.7. Effective Modelling Practices in MiniZinc" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, 2017, 2018, 2019, 2020 Peter J. Stuckey, Kim Marriott, Guido Tack.</p>
  </div>

  
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-63390311-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-63390311-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>