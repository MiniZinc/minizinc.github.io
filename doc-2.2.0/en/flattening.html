<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.8. FlatZinc and Flattening &#8212; MiniZinc Documentation 2.1.2 documentation</title>
    <link rel="stylesheet" href="static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="static/style.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. MiniZinc Reference Documentation" href="part_3_reference.html" />
    <link rel="prev" title="2.7. Boolean Satisfiability Modelling in MiniZinc" href="sat.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          MiniZinc Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b>2.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_introduction.html">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html">1.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html#structure">1.1.1. Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro.html#how-to-read-this">1.1.2. How to Read This</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">1.2. Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installation.html#binary-packages">1.2.1. Binary Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#compilation-from-source-code">1.2.2. Compilation from Source Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#adding-third-party-solvers">1.2.3. Adding Third-party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ide_basic_steps.html">1.3. First steps with the MiniZinc IDE</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#our-first-example">2.1.1. Our First Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#an-arithmetic-optimisation-example">2.1.2. An Arithmetic Optimisation Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#datafiles-and-assertions">2.1.3. Datafiles and Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#real-number-solving">2.1.4. Real Number Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#basic-structure-of-a-model">2.1.5. Basic structure of a model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#arrays-and-sets">2.2.1. Arrays and Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#global-constraints">2.2.2. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#conditional-expressions">2.2.3. Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#enumerated-types">2.2.4. Enumerated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#complex-constraints">2.2.5. Complex Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#set-constraints">2.2.6. Set Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#putting-it-all-together">2.2.7. Putting it all together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#global-constraints">2.3.1. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-predicates">2.3.2. Defining Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-functions">2.3.3. Defining Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#reflection-functions">2.3.4. Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-variables">2.3.5. Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#context">2.3.6. Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-constraints">2.3.7. Local Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#domain-reflection-functions">2.3.8. Domain Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#scope">2.3.9. Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#declaring-and-using-option-types">2.4.1. Declaring and Using Option Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#hidden-option-types">2.4.2. Hidden Option Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#annotations">2.5.3. Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#unconstrained-variables">2.6.2. Unconstrained Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#effective-generators">2.6.3. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#redundant-constraints">2.6.4. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#modelling-choices">2.6.5. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#multiple-modelling-and-channels">2.6.6. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#symmetry">2.6.7. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-integers">2.7.1. Modelling Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.8. FlatZinc and Flattening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#flattening-expressions">2.8.1. Flattening Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-expressions">2.8.2. Linear Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays">2.8.4. Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reification">2.8.5. Reification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predicates">2.8.6. Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_reference.html">3. MiniZinc Reference Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spec.html">3.1. Specification of MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spec.html#introduction">3.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#notation">3.1.2. Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#overview-of-a-model">3.1.3. Overview of a Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#syntax-overview">3.1.4. Syntax Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#high-level-model-structure">3.1.5. High-level Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#types-and-type-insts">3.1.6. Types and Type-insts</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#expressions">3.1.7. Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#items">3.1.8. Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#annotations">3.1.9. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#partiality">3.1.10. Partiality</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#built-in-operations">3.1.11. Built-in Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#content-types">3.1.12. Content-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#json-support">3.1.13. JSON support</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#full-grammar">3.1.14. Full grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-interfacing.html">3.2. Interfacing Solvers to Flatzinc</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">2.8. FlatZinc and Flattening</a><ul>
<li><a class="reference internal" href="#flattening-expressions">2.8.1. Flattening Expressions</a><ul>
<li><a class="reference internal" href="#simplification-and-evaluation">2.8.1.1. Simplification and Evaluation</a></li>
<li><a class="reference internal" href="#defining-subexpressions">2.8.1.2. Defining Subexpressions</a></li>
<li><a class="reference internal" href="#flatzinc-constraint-form">2.8.1.3. FlatZinc constraint form</a></li>
<li><a class="reference internal" href="#bounds-analysis">2.8.1.4. Bounds analysis</a></li>
<li><a class="reference internal" href="#objectives">2.8.1.5. Objectives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linear-expressions">2.8.2. Linear Expressions</a></li>
<li><a class="reference internal" href="#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li><a class="reference internal" href="#arrays">2.8.4. Arrays</a></li>
<li><a class="reference internal" href="#reification">2.8.5. Reification</a></li>
<li><a class="reference internal" href="#predicates">2.8.6. Predicates</a></li>
<li><a class="reference internal" href="#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="sat.html" title="Previous Chapter: 2.7. Boolean Satisfiability Modelling in MiniZinc"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 2.7. Boolean ...</span>
    </a>
  </li>
  <li>
    <a href="part_3_reference.html" title="Next Chapter: 3. MiniZinc Reference Documentation"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">3. MiniZinc R... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="flatzinc-and-flattening">
<span id="sec-flattening"></span><h1>2.8. FlatZinc and Flattening<a class="headerlink" href="#flatzinc-and-flattening" title="Permalink to this headline">¶</a></h1>
<p>Constraint solvers do not directly support MiniZinc models, rather in order
to run a MiniZinc model, it is translated into a simple subset of MiniZinc
called FlatZinc. FlatZinc reflects the fact that most constraint solvers
only solve satisfaction
problems of the form <span class="math notranslate nohighlight">\(\bar{exists} c_1 \wedge \cdots \wedge c_m\)</span>
or optimization problems of the form
<span class="math notranslate nohighlight">\(\text{minimize } z \text{ subject to }  c_1 \wedge \cdots \wedge c_m\)</span>,
where <span class="math notranslate nohighlight">\(c_i\)</span> are primitive constraints and <span class="math notranslate nohighlight">\(z\)</span> is an integer or float
expression in a restricted form.</p>
<p id="index-0">The tool <tt class="docutils literal">mzn2fzn</tt>
takes a MiniZinc model and data files and creates
a flattened FlatZinc model which is equivalent to the MiniZinc model with
the given data, and that appears in the restricted form discussed above.
Normally the construction of a FlatZinc model which is sent to a solver is
hidden from the user but you can view the result of flattening a model
<tt class="docutils literal">model.mzn</tt> with
its data <tt class="docutils literal">data.dzn</tt> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mzn2fzn model.mzn data.dzn
</pre></div>
</div>
<p>which creates a FlatZinc model called <tt class="docutils literal">model.fzn</tt>.</p>
<p>In this chapter we explore the process of translation from MiniZinc to FlatZinc.</p>
<div class="section" id="flattening-expressions">
<h2>2.8.1. Flattening Expressions<a class="headerlink" href="#flattening-expressions" title="Permalink to this headline">¶</a></h2>
<p>The restrictions of the underlying solver mean that complex expressions in
MiniZinc need to be <em>flattened</em> to only use conjunctions of primitive
constraints which do not themselves contain structured terms.</p>
<p>Consider the following model for ensuring that two circles in a rectangular
box do not overlap:</p>
<div class="literal-block-wrapper docutils container" id="fig-nonoverlap">
<div class="code-block-caption"><span class="caption-number">Listing 2.58 </span><span class="caption-text">Modelling non overlap of two circles (<a class="reference download internal" href="downloads/cnonoverlap.mzn" download=""><tt class="xref download docutils literal">cnonoverlap.mzn</tt></a>).</span><a class="headerlink" href="#fig-nonoverlap" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">width</span><span class="p">;</span><span class="s">          </span><span class="c">% width of rectangle to hold circles</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">height</span><span class="p">;</span><span class="s">         </span><span class="c">% height of rectangle to hold circles</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">r1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r1</span><span class="o">..</span><span class="nv">width</span><span class="o">-</span><span class="nv">r1</span><span class="p">:</span><span class="s">  </span><span class="nv">x1</span><span class="p">;</span><span class="s"> </span><span class="c">% (x1,y1) is center of circle of radius r1</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r1</span><span class="o">..</span><span class="nv">height</span><span class="o">-</span><span class="nv">r1</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">r2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r2</span><span class="o">..</span><span class="nv">width</span><span class="o">-</span><span class="nv">r2</span><span class="p">:</span><span class="s">  </span><span class="nv">x2</span><span class="p">;</span><span class="s"> </span><span class="c">% (x2,y2) is center of circle of radius r2</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r2</span><span class="o">..</span><span class="nv">height</span><span class="o">-</span><span class="nv">r2</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="s">                       </span><span class="c">% centers are at least r1 + r2 apart</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x1</span><span class="o">-</span><span class="nv">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">x1</span><span class="o">-</span><span class="nv">x2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="nv">y1</span><span class="o">-</span><span class="nv">y2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">y1</span><span class="o">-</span><span class="nv">y2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="simplification-and-evaluation">
<h3>2.8.1.1. Simplification and Evaluation<a class="headerlink" href="#simplification-and-evaluation" title="Permalink to this headline">¶</a></h3>
<p>Given the data file</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">width</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">10.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">height</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">8.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">r1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">r2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3.0</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>the translation to FlatZinc first simplifies the model by replacing all the
parameters by their values, and evaluating any fixed expression.
After this simplification the values of parameters are not longer needed.
An exception to this is large arrays of parametric values. If they are
used more than once, then the parameter is retained to avoid duplicating the
large expression.</p>
<p>After simplification the variable and parameter declarations parts of
the model of <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.58</span></a> become</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">8.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">6.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">7.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">5.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="defining-subexpressions">
<span id="sec-flat-sub"></span><h3>2.8.1.2. Defining Subexpressions<a class="headerlink" href="#defining-subexpressions" title="Permalink to this headline">¶</a></h3>
<p>Now no constraint solver directly handles complex constraint expressions
like the one in <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.58</span></a>.
Instead, each subexpression in the expression is named, and we create a
constraint to construct the value of each expression.  Let’s examine the
subexpressions of the constraint expression. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="s"></span></code> is a
subexpression, if we name if <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"></span></code> we can define it as
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span></code> Notice that this expression occurs
twice in the model. We only need to contruct the value once, we can then
reuse it.  This is called <em>common subexpression elimination</em>.
The subexpression <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="s"></span></code> can be named
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code>
and we can define it as
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span></code>
We can similarly name <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span></code>
and
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span></code>
and finally <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span></code>.
The inequality constraint itself becomes
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">25.0</span><span class="p">;</span><span class="s"></span></code> since <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">r1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">r2</span><span class="p">)</span><span class="s"></span></code>
is calculated as <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">25.0</span><span class="s"></span></code>.
The flattened constraint is hence</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">25.0</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="flatzinc-constraint-form">
<span id="sec-flat-fzn"></span><h3>2.8.1.3. FlatZinc constraint form<a class="headerlink" href="#flatzinc-constraint-form" title="Permalink to this headline">¶</a></h3>
<p>Flattening as its final step converts the form of the constraint to a
standard FlatZinc form which is always <span class="math notranslate nohighlight">\(p(a_1, \ldots, a_n)\)</span> where
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> is the name of the primitive constraint and <span class="math notranslate nohighlight">\(a_1, \ldots, a_n\)</span> are the
arguments. FlatZinc tries to use a minimum of different constraint forms so
for example the constraint <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="s"></span></code> is first rewritten to
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">x2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"></span></code> and then output using the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">float_plus</span><span class="s"></span></code> primitive
constraint. The resulting constraint form is as follows:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">x2</span><span class="p">,</span><span class="s"> </span><span class="nv">x1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">y2</span><span class="p">,</span><span class="s"> </span><span class="nv">y1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT02</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="bounds-analysis">
<h3>2.8.1.4. Bounds analysis<a class="headerlink" href="#bounds-analysis" title="Permalink to this headline">¶</a></h3>
<p>We are still missing one thing, the
declarations for the introduced variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"></span></code>, …,
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT05</span><span class="s"></span></code>. While these could just be declared as
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="s"></span></code>, in order to make the solver’s task easier MiniZinc tries to
determine upper and lower bounds on newly introduced variables, by a simple
bounds analysis. For example since <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="s"></span></code>
and <span class="math notranslate nohighlight">\(2.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x1</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 8.0\)</span> and <span class="math notranslate nohighlight">\(3.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x2</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 7.0\)</span> then we can see that
<span class="math notranslate nohighlight">\(-5.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT0</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 5.0\)</span>. Given this information we can see that
<span class="math notranslate nohighlight">\(-25.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 25.0\)</span> (although note that if we recognized that the
multiplication was in fact a squaring we could give the much more accurate
bounds <span class="math notranslate nohighlight">\(0.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 25.0\)</span>).</p>
<p>The alert reader may have noticed a discrepancy between the flattened form
of the constraints in <a class="reference internal" href="#sec-flat-sub"><span class="std std-ref">Defining Subexpressions</span></a> and <a class="reference internal" href="#sec-flat-fzn"><span class="std std-ref">FlatZinc constraint form</span></a>.  In
the latter there is no inequality constraint. Since unary inequalities can
be fully represented by the bounds of a variable, the inequality forces the
lower bound of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT05</span><span class="s"></span></code> to be <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">25.0</span><span class="s"></span></code> and is then redundant.  The final
flattened form of the model of <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.58</span></a> is:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% Variables</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">8.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">6.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">7.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="m">5.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="c">%</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">5.0</span><span class="o">..</span><span class="m">5.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">25.0</span><span class="o">..</span><span class="m">25.0</span><span class="p">:</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">3.0</span><span class="o">..</span><span class="m">3.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9.0</span><span class="o">..</span><span class="m">9.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">25.0</span><span class="o">..</span><span class="m">34.0</span><span class="p">:</span><span class="s">  </span><span class="nv">FLOAT05</span><span class="p">;</span><span class="s"></span>
<span class="c">% Constraints</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">x2</span><span class="p">,</span><span class="s"> </span><span class="nv">x1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">y2</span><span class="p">,</span><span class="s"> </span><span class="nv">y1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT02</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">);</span><span class="s"></span>
<span class="c">%</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="objectives">
<h3>2.8.1.5. Objectives<a class="headerlink" href="#objectives" title="Permalink to this headline">¶</a></h3>
<p>MiniZinc flattens minimization or maximization
objectives just like constraints.  The objective
expression is flattened and a variable is created for it, just as for other
expressions. In the FlatZinc output the solve item is always on a single
variable.  See <a class="reference internal" href="#sec-let"><span class="std std-ref">Let Expressions</span></a> for an example.</p>
</div>
</div>
<div class="section" id="linear-expressions">
<h2>2.8.2. Linear Expressions<a class="headerlink" href="#linear-expressions" title="Permalink to this headline">¶</a></h2>
<p>One of the most important form of constraints, widely used for modelling,
are linear constraints of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}a_1 x_1 + \cdots + a_n x_n \begin{array}[c]{c} = \\ \leq \\ &lt; \end{array} a_0\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> are integer or floating point constants, and
<span class="math notranslate nohighlight">\(x_i\)</span> are integer or floating point variables.
They are highly expressive, and are the only class of constraint supported
by (integer) linear programming constraint solvers.
The translator from MiniZinc to FlatZinc tries to create linear
constraints, rather than break up linear constraints into many
subexpressions.</p>
<div class="literal-block-wrapper docutils container" id="fig-lflat">
<div class="code-block-caption"><span class="caption-number">Listing 2.59 </span><span class="caption-text">A MiniZinc model to illustrate linear constraint flattening (<a class="reference download internal" href="downloads/linear.mzn" download=""><tt class="xref download docutils literal">linear.mzn</tt></a>).</span><a class="headerlink" href="#fig-lflat" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s">       </span><span class="nv">d</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="o">..</span><span class="m">6</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s">  </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">3</span><span class="o">*</span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">19</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">4</span><span class="o">*</span><span class="nv">d</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>Consider the model shown in <a class="reference internal" href="#fig-lflat"><span class="std std-numref">Listing 2.59</span></a>. Rather than create
variables for all the subexressions <span class="math notranslate nohighlight">\(3*x\)</span>, <span class="math notranslate nohighlight">\(3*x - y\)</span>, <span class="math notranslate nohighlight">\(x * z\)</span>, <span class="math notranslate nohighlight">\(3*x - y + x*z\)</span>,
<span class="math notranslate nohighlight">\(x + y + z\)</span>, <span class="math notranslate nohighlight">\(d * (x + y + z)\)</span>, <span class="math notranslate nohighlight">\(19 + d * (x + y + z)\)</span>,
and <span class="math notranslate nohighlight">\(19 + d * (x + y + z) - 4*d\)</span>
translation will attempt to create a large linear constraint which captures
as much as possible of the constraint in a single FlatZinc
constraint.</p>
<p>Flattening creates linear expressions as a single unit rather than building
intermediate variables for each subexpression. It also simplfies the linear
expression created.  Extracting the linear expression from the constraints
leads to</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">80</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4</span><span class="o">*</span><span class="nv">x</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">23</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Notice how the <em>nonlinear expression</em> <span class="math notranslate nohighlight">\(x \times z\)</span> is extracted as a
new subexpression and given a name, while the remaining terms are collected
together so that each variable appears exactly once (and indeed variable <span class="math notranslate nohighlight">\(y\)</span>
whose terms cancel is eliminated).</p>
<p>Finally each constraint is written to FlatZinc form obtaining:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">80</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le</span><span class="p">([</span><span class="m">1,4</span><span class="p">,</span><span class="m">1</span><span class="p">],[</span><span class="nv">INT01</span><span class="p">,</span><span class="nv">x</span><span class="p">,</span><span class="nv">z</span><span class="p">],</span><span class="m">23</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_times</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">z</span><span class="p">,</span><span class="nv">INT01</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="unrolling-expressions">
<span id="sec-unroll"></span><h2>2.8.3. Unrolling Expressions<a class="headerlink" href="#unrolling-expressions" title="Permalink to this headline">¶</a></h2>
<p>Most models require creating a number of constraints which is
dependent on the input data.  MiniZinc supports these models with array
types, list and set comprehensions, and aggregation functions.</p>
<p>Consider the following aggregate expression from the production scheduling
example of <a class="reference internal" href="modelling2.html#ex-prod-planning"><span class="std std-numref">Listing 2.11</span></a>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"></span>
<span class="s">                     </span><span class="p">(</span><span class="nb">min</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"></span>
<span class="s">                                     </span><span class="p">(</span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]));</span><span class="s"></span>
</pre></div>
</div>
<p>Since this uses generator call syntax we can rewrite it to equivalent
form which is processed by <tt class="docutils literal">mzn2fzn</tt>:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="p">([</span><span class="s"> </span><span class="nb">min</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"></span>
<span class="s">                           </span><span class="p">|</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">]</span><span class="gr">)</span><span class="s"></span>
<span class="s">                     </span><span class="p">|</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>Given the data</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">nproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="nv">nresources</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="nv">capacity</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">4000</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">2000</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">];</span><span class="s"></span>
<span class="nv">consumption</span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">250</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="p">,</span><span class="s"> </span><span class="m">100</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="p">|</span><span class="s"> </span><span class="m">200</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
<p>this first builds the array for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code></p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"></span>
<span class="s">                           </span><span class="p">|</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
<p>which is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">16</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">26</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">]</span><span class="s"></span></code> and then calculates the minimum as 3.
It then builds the same array for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code> which is
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">20</span><span class="p">,</span><span class="s"> </span><span class="m">13</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">]</span><span class="s"></span></code> and calculates the minimum as 3. It then constructs the
array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]</span><span class="s"></span></code> and calculates the maximum as 3.
There is no representation of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> in the output FlatZinc,
this evaluation is simply used to replace <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> by the
calculated value 3.</p>
<p>The most common form of aggregate expression in a constraint model is
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code>.  Forall expressions are unrolled into multiple constraints.</p>
<p>Consider the MiniZinc fragment</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>which arises from the SEND-MORE-MONEY example of <a class="reference internal" href="modelling2.html#ex-smm"><span class="std std-numref">Listing 2.13</span></a>
using a default decomposition for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code>.
The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> expression creates a constraint for each <span class="math notranslate nohighlight">\(i, j\)</span> pair which meet
the requirement <span class="math notranslate nohighlight">\(i &lt; j\)</span>, thus creating</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="s"> </span><span class="c">% S != E</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">3</span><span class="p">];</span><span class="s"> </span><span class="c">% S != N</span><span class="s"></span>
<span class="o">..</span><span class="s">.</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"> </span><span class="c">% S != Y</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">3</span><span class="p">];</span><span class="s"> </span><span class="c">% E != N</span><span class="s"></span>
<span class="o">..</span><span class="s">.</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"> </span><span class="c">% R != Y</span><span class="s"></span>
</pre></div>
</div>
<p>In FlatZinc form this is</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">N</span><span class="p">);</span><span class="s"></span>
<span class="o">..</span><span class="s">.</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">Y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">);</span><span class="s"></span>
<span class="o">..</span><span class="s">.</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Notice how the temporary array variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> are replaced by the
original variables in the output FlatZinc.</p>
</div>
<div class="section" id="arrays">
<h2>2.8.4. Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h2>
<p>One dimensional arrays
in MiniZinc can have arbitrary indices as long as they are
contiguous integers.  In FlatZinc all arrays are indexed from <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">1</span><span class="o">..</span><span class="nv">l</span><span class="s"></span></code>
where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">l</span><span class="s"></span></code> is the length of the array.  This means that array lookups need to
be translated to the FlatZinc view of indices.</p>
<p>Consider the following MiniZinc model for balancing a seesaw
of length <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">l2</span><span class="s"></span></code>,
with a child of weight <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">cw</span><span class="s"></span></code> kg using exactly <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 1kg weights.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s">                               </span><span class="c">% child weight</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l2</span><span class="p">;</span><span class="s">                               </span><span class="c">% half seesaw length</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">;</span><span class="s">                                </span><span class="c">% number of 1kg weight</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">m</span><span class="p">,</span><span class="nv">cw</span><span class="p">):</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"> </span><span class="c">% weight at each point</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">;</span><span class="s">                        </span><span class="c">% position of child</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">)(</span><span class="nv">i</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"> </span><span class="c">% balance</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">)(</span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">m</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s"> </span><span class="c">% all weights used</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s">                  </span><span class="c">% child is at position p</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Given <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">cw</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code>, <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">l2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code>, and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="s"></span></code> the unrolling produces the constraints</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">0</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>But FlatZinc insists that the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> array starts at index 1.
This means we need to rewrite all the array accesses to use the new index
value. For fixed array lookups this is easy, for variable array lookups we
may need to create a new variable.  The result for the equations above is</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">0</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">INT01</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Finally we rewrite the constraints into FlatZinc form. Note how the variable
array index lookup is mapped to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">array_var_int_element</span><span class="s"></span></code>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="m">5</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_var_int_element</span><span class="p">(</span><span class="nv">INT01</span><span class="p">,</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT01</span><span class="p">,</span><span class="s"> </span><span class="nv">p</span><span class="p">],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Multidimensional arrays are supported by MiniZinc, but only single
dimension arrays are supported by FlatZinc (at present).
This means that multidimensional arrays must be mapped to single dimension
arrays, and multidimensional array access must be mapped to single dimension
array access.</p>
<p>Consider the Laplace equation constraints defined for a finite element
plate model in <a class="reference internal" href="modelling2.html#ex-laplace"><span class="std std-numref">Listing 2.10</span></a>:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">HEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">h</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">h</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">WIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">w</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s">  </span>
<span class="kt">array</span><span class="p">[</span><span class="nv">HEIGHT</span><span class="p">,</span><span class="nv">WIDTH</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% temperature at point (i,j)</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">left</span><span class="p">;</span><span class="s">   </span><span class="c">% left   edge temperature</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">right</span><span class="p">;</span><span class="s">  </span><span class="c">% right  edge temperature</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">top</span><span class="p">;</span><span class="s">    </span><span class="c">% top    edge temperature</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">bottom</span><span class="p">;</span><span class="s"> </span><span class="c">% bottom edge temperature</span><span class="s"></span>

<span class="c">% equation</span><span class="s"></span>
<span class="c">% Laplace equation: each internal temp. is average of its neighbours</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="s"></span>
<span class="s">              </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>Assuming <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">h</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> this creates the constraints</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="m">4,0</span><span class="o">..</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% temperature at point (i,j)</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,4</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,4</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,4</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>The 2 dimensional array of 25 elements is converted to a one dimensional
array and the indices are changed accordingly: so index <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> becomes
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">]</span><span class="s"></span></code>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">25</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">10</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">11</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">15</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">16</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">22</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">23</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">24</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">20</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="reification">
<h2>2.8.5. Reification<a class="headerlink" href="#reification" title="Permalink to this headline">¶</a></h2>
<p id="index-1">FlatZinc models involve only variables and parameter declarations
and a series of primitive constraints.  Hence when we model in MiniZinc
with Boolean connectives other than conjunction, something has to be done.
The core approach to handling complex formulae that use
connectives other than conjunction is by
<em>reification</em>.
Reifying a constraint <span class="math notranslate nohighlight">\(c\)</span> createsa new constraint equivalent to <span class="math notranslate nohighlight">\(b \leftrightarrow c\)</span>
where the Boolean variable <span class="math notranslate nohighlight">\(b\)</span> is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">true</span><span class="s"></span></code>
if the constraint holds and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">false</span><span class="s"></span></code> if it doesn’t hold.</p>
<p>Once we have the capability to <em>reify</em> constraints the treatment of
complex formulae is not different from arithmetic expressions. We create a
name for each subexpression and a flat constraint to constrain the name to
take the value of its subexpression.</p>
<p>Consider the following constraint expression that occurs in the jobshop
scheduling example of <a class="reference internal" href="modelling2.html#ex-jobshop"><span class="std std-numref">Listing 2.17</span></a>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="c">%% ensure no overlap of tasks</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">tasks</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">jobs</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Given the data file</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">jobs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="nv">tasks</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="p">;</span><span class="s"></span>
<span class="nv">d</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="p">|]</span><span class="s"></span>
</pre></div>
</div>
<p>then the unrolling creates</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>Reification of the constraints that appear in the disjunction
creates new Boolean variables to define the values of each expression.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2,1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">23</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL02</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL04</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL06</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Each primitive constraint can now be mapped to the FlatZinc form.
Note how the two dimensional array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> is mapped to a one dimensional form.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">23</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">4</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">4</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">6</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">6</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL03</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL05</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_lin_le_reif</span><span class="s"></span></code> is the reified form of the linear constraint
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_lin_le</span><span class="s"></span></code>.</p>
<p>Most FlatZinc primitive constraints <span class="math notranslate nohighlight">\(p(\bar{x})\)</span> have a reified form
<span class="math notranslate nohighlight">\(\mathit{p\_reif}(\bar{x},b)\)</span> which takes an additional final argument <span class="math notranslate nohighlight">\(b\)</span>
and defines the constraint <span class="math notranslate nohighlight">\(b \leftrightarrow p(\bar{x})\)</span>.
FlatZinc primitive constraints which define functional relationships,
like <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_plus</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_plus</span><span class="s"></span></code>, do
not need to support reification. Instead, the equality with the result of the function is reified.</p>
<p>Another important use of reification arises when we use the coercion
function <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> (either explicitly, or implicitly by using a Boolean
expression as an integer expression). Flattening creates a Boolean
variable to hold the value of the Boolean expression argument, as well as an
integer variable (restricted to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="s"></span></code>) to hold this value.</p>
<p>Consider the magic series problem of <a class="reference internal" href="modelling2.html#ex-magic-series"><span class="std std-numref">Listing 2.21</span></a>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">))));</span><span class="s"></span>
</pre></div>
</div>
<p>Given <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code> the unrolling creates</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>and flattening creates</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL07</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT06</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT08</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">INT02</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">INT06</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT08</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>The final FlatZinc form is</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL07</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT02</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT04</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT06</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT08</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL01</span><span class="p">,</span><span class="s"> </span><span class="nv">INT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL03</span><span class="p">,</span><span class="s"> </span><span class="nv">INT04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL05</span><span class="p">,</span><span class="s"> </span><span class="nv">INT06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL07</span><span class="p">,</span><span class="s"> </span><span class="nv">INT08</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT02</span><span class="p">,</span><span class="s"> </span><span class="nv">INT04</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT06</span><span class="p">,</span><span class="s"> </span><span class="nv">INT08</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="predicates">
<h2>2.8.6. Predicates<a class="headerlink" href="#predicates" title="Permalink to this headline">¶</a></h2>
<p>An important factor in the support for MiniZinc by many different solvers
is that global constraints (and indeed FlatZinc constraints) can be
specialized for the particular solver.</p>
<p>Each solver will either specify a predicate without a definition, or with a
definition. For example a solver that has a builtin global <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code>
predicate, will include the definition</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>in its globals library, while a solver using the default decompsition will
have the definition</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>Predicate calls <span class="math notranslate nohighlight">\(p(\bar{t})\)</span>
are flattened by first constructing variables <span class="math notranslate nohighlight">\(v_i\)</span> for
each argument terms <span class="math notranslate nohighlight">\(t_i\)</span>.
If the predicate has no definition we simply use a call to the predicate
with the constructed arguments: <span class="math notranslate nohighlight">\(p(\bar{v})\)</span>.
If the predicate has a definition <span class="math notranslate nohighlight">\(p(\bar{x}) = \phi(\bar{x})\)</span>
then we replace the predicate call <span class="math notranslate nohighlight">\(p(\bar{t})\)</span>
with the body of the predicate with the formal arguments replaced by the
argument variables, that is <span class="math notranslate nohighlight">\(\phi(\bar{v})\)</span>.
Note that if a predicate call  <span class="math notranslate nohighlight">\(p(\bar{t})\)</span>
appears in a reified position and it has no definition, we check for the
existence of a reified version of the predicate <span class="math notranslate nohighlight">\(\mathit{p\_reif}(\bar{x},b)\)</span> in which
case we use that.</p>
<p>Consider the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraint in the
SEND-MORE-MONEY example of <a class="reference internal" href="modelling2.html#ex-smm"><span class="std std-numref">Listing 2.13</span></a></p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>If the solver has a builtin <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> we simply construct a new variable
for the argument, and replace it in the call.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Notice that bounds analysis attempts to find tight bounds on the new array
variable.   The reason for constructing the array argument is if we use the
same array twice the FlatZinc solver does not have to construct it twice.
In this case since it is not used twice a later stage of the translation
will replace <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> by its definition.</p>
<p>What if the solver uses the default definition of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code>?
Then the variable <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> is defined as usual, and the predicate call is
replaced by a renamed copy where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> replaces the formal argument <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code>.
The resulting code is</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>which we examined in <a class="reference internal" href="#sec-unroll"><span class="std std-ref">Unrolling Expressions</span></a>.</p>
<p>Consider the following constraint, where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> appears in a reified
position.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">])</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>If the solver has a reified form of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> this will be flattend to</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent_reif</span><span class="p">([</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">],</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent_reif</span><span class="p">([</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">],</span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">],</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Using the default decomposition, the predicate replacement will first create</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">];</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="p">)(</span><span class="nv">v1</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v1</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="p">)(</span><span class="nv">v2</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v2</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>which will eventually be flattened to the FlatZinc form</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_and</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">,</span><span class="nv">BOOL03</span><span class="p">],</span><span class="nv">BOOL04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">BOOL06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_and</span><span class="p">([</span><span class="nv">BOOL03</span><span class="p">,</span><span class="nv">BOOL05</span><span class="p">,</span><span class="nv">BOOL06</span><span class="p">],</span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL04</span><span class="p">,</span><span class="nv">BOOL07</span><span class="p">],</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Note how common subexpression elimination reuses the
reified inequality <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">B</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">C</span><span class="s"></span></code> (although there is a better translation which
lifts the common constraint to the top level conjunction).</p>
</div>
<div class="section" id="let-expressions">
<span id="sec-let"></span><h2>2.8.7. Let Expressions<a class="headerlink" href="#let-expressions" title="Permalink to this headline">¶</a></h2>
<p>Let expressions are a powerful facility of MiniZinc to introduce new
variables. This is useful for creating common sub expressions, and for
defining local variables for predicates.
During flattening let expressions are translated to variable and constraint
declarations. The relational semantics of MiniZinc means that these
constraints must appear as if conjoined
in the first enclosing Boolean expression.</p>
<p>A key feature of let expressions is that each time they are used they
create new variables.</p>
<p>Consider the flattening of the code</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="nv">u</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>First the predicate calls are replaced by their definition.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Next let variables are renamed apart</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y1</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y2</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Finally variable declarations are extracted to the top level</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Once the let expression is removed we can flatten as usual.</p>
<p>Remember that let expressions can define values for newly introduced
variables (and indeed must do so for parameters).
These implicitly define constraints that must also be flattened.</p>
<p>Consider the complex objective function for wedding seating problem of
<a class="reference internal" href="predicates.html#ex-wedding2"><span class="std std-numref">Listing 2.34</span></a>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">h</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Hatreds</span><span class="p">)(</span><span class="s"></span>
<span class="s">      </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s">  </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h1</span><span class="p">[</span><span class="nv">h</span><span class="p">]],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h2</span><span class="p">[</span><span class="nv">h</span><span class="p">]],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">      </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>For conciseness we assume only the first two Hatreds, so</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Hatreds</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">groom</span><span class="p">,</span><span class="s"> </span><span class="nv">carol</span><span class="p">];</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">clara</span><span class="p">,</span><span class="s"> </span><span class="nv">bestman</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>The first step of flattening is to unroll the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">sum</span><span class="s"></span></code> expression, giving
(we keep the guest names and parameter <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Seats</span><span class="s"></span></code> for clarity only, in
reality they would be replaced by their definition):</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">))</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>Next each new variable in a let expression is renamed to be distinct</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same1</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">))</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same2</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>Variables in the let expression
are extracted to the top level and
defining constraints are extracted to the correct
level (which in this case is also the top level).</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p11</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p21</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">same1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">);</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="s"> </span><span class="nv">p12</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="s"> </span><span class="nv">p22</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">same2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="gr">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="nv">same1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same1</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="gr">)</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="nv">same2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same2</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="gr">)</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Now we have constructed equivalent MiniZinc code without the use of let
expressions and the flattening can proceed as usual.</p>
<p>As an illustration of let expressions that do not appear at the top level
consider the following model</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">                     </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>We extract the variable definitions to the top level and the constraints to
the first enclosing Boolean context, which here is the right hand side of
the implication.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Note that if we know that the equation defining a  variable definition
cannot fail we can extract it to the top level. This will usually make
solving substantially faster.</p>
<p>For the example above the constraint <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code> can fail since the domain
of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> is not big enough for all possible values of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code>. But the
constraint <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code> cannot (indeed bounds analysis will give <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">z</span><span class="s"></span></code>
bounds big enough to hold all possible values of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code>).
A better flattening will give</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>Currently <tt class="docutils literal">mzn2fzn</tt> does this by always defining the declared
bounds of an
introduced variable to be big enough for its defining equation to always
hold and then adding bounds constraints in the correct context for the let
expression.   On the example above this results in</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9</span><span class="o">..</span><span class="m">72</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>This translation leads to more efficient solving since the possibly
complex calculation of the let variable is not reified.</p>
<p>Another reason for this approach is that it also works when introduced variables
appear in negative contexts (as long as they have a definition).
Consider the following example similar to the previous one</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">           </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>The let expressions appear in a negated context, but each introduced
variable is defined. The flattened code is</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9</span><span class="o">..</span><span class="m">72</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Note the analog to the simple approach to let elimination
does not give a correct translation:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>gives answers for all possible values of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code>, whereas the original
constraint removes the possibility that <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code>.</p>
<p>The treatment of <em>constraint items</em> in let expressions is analogous
to defined variables. One can think of a constraint as equivalent to
defining a new Boolean variable. The definitions of the new Boolean variables
are extractted to the top level, and the Boolean remains in the correct
context.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="s"></span>
<span class="s">                    </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>is treated like</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">),</span><span class="s"></span>
<span class="s">                          </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="p">),</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">b2</span><span class="s"></span>
<span class="s">                    </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>and flattens to</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">b1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, 2017, Peter J. Stuckey, Kim Marriott, Guido Tack.<br/>
    </p>
  </div>
</footer>
  </body>
</html>