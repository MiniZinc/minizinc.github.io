<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.6. Effective Modelling Practices in MiniZinc &#8212; MiniZinc Documentation 2.1.2 documentation</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.7. Boolean Satisfiability Modelling in MiniZinc" href="sat.html" />
    <link rel="prev" title="2.5. Search" href="mzn_search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          MiniZinc Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b>2.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_introduction.html">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html">1.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html#structure">1.1.1. Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro.html#how-to-read-this">1.1.2. How to Read This</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">1.2. Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installation.html#binary-packages">1.2.1. Binary Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#compilation-from-source-code">1.2.2. Compilation from Source Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#adding-third-party-solvers">1.2.3. Adding Third-party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ide_basic_steps.html">1.3. First steps with the MiniZinc IDE</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#our-first-example">2.1.1. Our First Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#an-arithmetic-optimisation-example">2.1.2. An Arithmetic Optimisation Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#datafiles-and-assertions">2.1.3. Datafiles and Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#real-number-solving">2.1.4. Real Number Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#basic-structure-of-a-model">2.1.5. Basic structure of a model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#arrays-and-sets">2.2.1. Arrays and Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#global-constraints">2.2.2. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#conditional-expressions">2.2.3. Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#enumerated-types">2.2.4. Enumerated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#complex-constraints">2.2.5. Complex Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#set-constraints">2.2.6. Set Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#putting-it-all-together">2.2.7. Putting it all together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#global-constraints">2.3.1. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-predicates">2.3.2. Defining Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-functions">2.3.3. Defining Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#reflection-functions">2.3.4. Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-variables">2.3.5. Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#context">2.3.6. Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-constraints">2.3.7. Local Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#domain-reflection-functions">2.3.8. Domain Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#scope">2.3.9. Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#declaring-and-using-option-types">2.4.1. Declaring and Using Option Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#hidden-option-types">2.4.2. Hidden Option Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#annotations">2.5.3. Annotations</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unconstrained-variables">2.6.2. Unconstrained Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#effective-generators">2.6.3. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#redundant-constraints">2.6.4. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modelling-choices">2.6.5. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-modelling-and-channels">2.6.6. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetry">2.6.7. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-integers">2.7.1. Modelling Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#flattening-expressions">2.8.1. Flattening Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#linear-expressions">2.8.2. Linear Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#arrays">2.8.4. Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#reification">2.8.5. Reification</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#predicates">2.8.6. Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_reference.html">3. MiniZinc Reference Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spec.html">3.1. Specification of MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spec.html#introduction">3.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#notation">3.1.2. Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#overview-of-a-model">3.1.3. Overview of a Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#syntax-overview">3.1.4. Syntax Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#high-level-model-structure">3.1.5. High-level Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#types-and-type-insts">3.1.6. Types and Type-insts</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#expressions">3.1.7. Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#items">3.1.8. Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#annotations">3.1.9. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#partiality">3.1.10. Partiality</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#built-in-operations">3.1.11. Built-in Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#content-types">3.1.12. Content-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#json-support">3.1.13. JSON support</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#full-grammar">3.1.14. Full grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-interfacing.html">3.2. Interfacing Solvers to Flatzinc</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li><a class="reference internal" href="#variable-bounds">2.6.1. Variable Bounds</a></li>
<li><a class="reference internal" href="#unconstrained-variables">2.6.2. Unconstrained Variables</a></li>
<li><a class="reference internal" href="#effective-generators">2.6.3. Effective Generators</a></li>
<li><a class="reference internal" href="#redundant-constraints">2.6.4. Redundant Constraints</a></li>
<li><a class="reference internal" href="#modelling-choices">2.6.5. Modelling Choices</a></li>
<li><a class="reference internal" href="#multiple-modelling-and-channels">2.6.6. Multiple Modelling and Channels</a></li>
<li><a class="reference internal" href="#symmetry">2.6.7. Symmetry</a><ul>
<li><a class="reference internal" href="#static-symmetry-breaking">2.6.7.1. Static Symmetry Breaking</a></li>
<li><a class="reference internal" href="#other-examples-of-symmetry">2.6.7.2. Other Examples of Symmetry</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="mzn_search.html" title="Previous Chapter: 2.5. Search"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 2.5. Search</span>
    </a>
  </li>
  <li>
    <a href="sat.html" title="Next Chapter: 2.7. Boolean Satisfiability Modelling in MiniZinc"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">2.7. Boolean ... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="effective-modelling-practices-in-minizinc">
<span id="sec-efficient"></span><h1>2.6. Effective Modelling Practices in MiniZinc<a class="headerlink" href="#effective-modelling-practices-in-minizinc" title="Permalink to this headline">¶</a></h1>
<p>There are almost always multiple
ways to model the same problem, some of which generate models which are
efficient to solve, and some of which are not.
In general it is very hard to tell a priori which models are the most
efficient
for solving a particular problem, and indeed it may critically depend on
the underlying solver used, and search strategy.  In this chapter we
concentrate
on modelling practices that avoid inefficiency in generating models
and generated models.</p>
<div class="section" id="variable-bounds">
<h2>2.6.1. Variable Bounds<a class="headerlink" href="#variable-bounds" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Finite domain propagation engines, which are the principle type of solver
targeted by MiniZinc, are more effective the tighter the bounds on the
variables involved.  They can also behave badly with problems which
have subexpressions that take large integer values, since they may
implicitly limit the size of integer variables.</p>
<div class="literal-block-wrapper docutils container" id="ex-grocery">
<div class="code-block-caption"><span class="caption-number">Listing 2.41 </span><span class="caption-text">A model with unbounded variables (<a class="reference download internal" href="_downloads/grocery.mzn" download=""><tt class="xref download docutils literal">grocery.mzn</tt></a>).</span><a class="headerlink" href="#ex-grocery" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item1</span><span class="p">;</span><span class="s"> </span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item3</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">item4</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">711</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">item4</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">711</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">100</span><span class="p">;</span><span class="s"></span>
<span class="s">  </span>
<span class="k">constraint</span><span class="s">         </span><span class="m">0</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">item1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item2</span><span class="s"></span>
<span class="s">           </span><span class="o">/\</span><span class="s"> </span><span class="nv">item2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">item3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>
<span class="s">  </span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;{&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item1</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item2</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">item3</span><span class="p">),</span><span class="s"> &quot;,&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">        </span><span class="nb">show</span><span class="p">(</span><span class="nv">item4</span><span class="p">),</span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The grocery problem shown in <a class="reference internal" href="#ex-grocery"><span class="std std-numref">Listing 2.41</span></a> finds 4 items
whose prices in dollars add up to 7.11 and multiply up to 7.11.
The variables are declared unbounded. Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd grocery.mzn
</pre></div>
</div>
<p>yields</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">=====</span><span class="n">UNSATISFIABLE</span><span class="o">=====</span>
<span class="o">%</span> <span class="n">grocery</span><span class="o">.</span><span class="n">fzn</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">model</span> <span class="n">inconsistency</span> <span class="n">detected</span> <span class="n">before</span> <span class="n">search</span><span class="o">.</span>
</pre></div>
</div>
<p>This is because the
intermediate expressions in the multiplication
are also <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code>
and are given default bounds in the solver
<span class="math notranslate nohighlight">\(-1,000,000 \dots 1,000,000\)</span>,
and these ranges are too small to hold the
values that the intermediate expressions may need to take.</p>
<p>Modifying the model so that the items are declared with tight bounds</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item3</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">711</span><span class="p">:</span><span class="s"> </span><span class="nv">item4</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>results in a better model, since now MiniZinc can infer bounds on the
intermediate expressions and use these rather than the default bounds.
With this modification, executing the model gives</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">120</span><span class="p">,</span><span class="mi">125</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">316</span><span class="p">}</span>
<span class="o">----------</span>
</pre></div>
</div>
<p>Note however that even the improved model may be too difficult for
some solvers.
Running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12lazy grocery.mzn
</pre></div>
</div>
<p>does not return an answer, since the solver builds a huge representation
for the intermediate product variables.</p>
<div class="admonition-bounding-variables admonition" id="defblock-0">
<p class="first admonition-title">Bounding variables</p>
<p class="last" id="index-1">Always try to use bounded variables in models.
When using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">let</span><span class="s"></span></code>
declarations to introduce new variables, always try to define them
with correct and tight bounds.  This will make your model more efficient,
and avoid the possibility of unexpected overflows.
One exception is when you introduce a new variable which is
immediately defined as equal to an expression. Usually MiniZinc will be
able to infer effective bounds from the expression.</p>
</div>
</div>
<div class="section" id="unconstrained-variables">
<h2>2.6.2. Unconstrained Variables<a class="headerlink" href="#unconstrained-variables" title="Permalink to this headline">¶</a></h2>
<p id="index-2">Sometimes when modelling it is easier to introduce more variables than
actually required to model the problem.</p>
<div class="literal-block-wrapper docutils container" id="ex-unc">
<div class="code-block-caption"><span class="caption-number">Listing 2.42 </span><span class="caption-text">A model for Golomb rulers with unconstrained variables (<a class="reference download internal" href="_downloads/golomb.mzn" download=""><tt class="xref download docutils literal">golomb.mzn</tt></a>).</span><a class="headerlink" href="#ex-unc" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"> </span><span class="c">% number of marks on ruler</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">;</span><span class="s"> </span><span class="c">% max length of ruler</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">:</span><span class="s"> </span><span class="nv">mark</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">:</span><span class="s"> </span><span class="nv">diffs</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s">          </span><span class="c">% (diff)</span><span class="s"></span>
<span class="s">                  </span><span class="p">(</span><span class="nv">diffs</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s">  </span><span class="c">% (diff)</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="s"> </span><span class="nv">diffs</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">diffs</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">diffs</span><span class="p">[</span><span class="nv">n</span><span class="p">,</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">];</span><span class="s">  </span><span class="c">% symmetry break</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;marks = &quot;</span><span class="p">,</span><span class="nb">show</span><span class="p">(</span><span class="nv">mark</span><span class="p">),</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>Consider the model for Golomb rulers shown in <a class="reference internal" href="#ex-unc"><span class="std std-numref">Listing 2.42</span></a>.
A Golomb ruler of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> marks is one where the absolute differences
between any two marks are different.
It creates a two dimensional array of difference variables, but
only uses those of the form <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">diff</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">j</span><span class="s"></span></code>.
Running the model as</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd golomb.mzn -D <span class="s2">&quot;n = 4; m = 6;&quot;</span>
</pre></div>
</div>
<p>results in output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mark</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
<span class="n">diffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
<span class="o">----------</span>
</pre></div>
</div>
<p>and everything seems fine with the model.
But if we ask for all solutions using</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd -a golomb.mzn -D <span class="s2">&quot;n = 4; m = 6;&quot;</span>
</pre></div>
</div>
<p>we are presented with a never ending list of the same solution!</p>
<p>What is going on?  In order for the finite domain solver to finish
it needs to fix all variables, including the variables <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">diff</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code>
where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">j</span><span class="s"></span></code>, which means there are countless ways of generating a
solution, simply by changing these variables to take arbitrary values.</p>
<p>We can avoid problems with unconstrained variables, by modifying
the model so that they are fixed to some value. For example replacing
the lines marked <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="c">% (diff}</span><span class="s"></span></code> in <a class="reference internal" href="#ex-unc"><span class="std std-numref">Listing 2.42</span></a>
to</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"></span>
<span class="s">                 </span><span class="p">(</span><span class="nv">diffs</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">mark</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"></span>
<span class="s">                               </span><span class="k">else</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">endif</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>ensures that the extra variables are all fixed to 0. With this change
the solver returns just one solution.</p>
<p>MiniZinc will automatically remove variables which are unconstrained
and not used in the output.  An alternate solution to the above problem is
simply to remove the output of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">diffs</span><span class="s"></span></code> array by changing the
output statement to</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;mark = </span><span class="p">\(</span><span class="nv">mark</span><span class="p">)</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>With this change running</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd -a golomb.mzn -D <span class="s2">&quot;n = 4; m = 6;&quot;</span>
</pre></div>
</div>
<p>simply results in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mark</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
<span class="o">----------</span>
<span class="o">==========</span>
</pre></div>
</div>
<p>illustrating the unique solution.</p>
<div class="admonition-unconstrained-variables admonition" id="defblock-1">
<p class="first admonition-title">Unconstrained Variables</p>
<p class="last" id="index-3">Models should never have unconstrained variables. Sometimes it is
difficult to model without unnecessary variables.
If this is the case add
constraints to fix the unnecessary variables,
so they cannot influence the
solving.</p>
</div>
</div>
<div class="section" id="effective-generators">
<h2>2.6.3. Effective Generators<a class="headerlink" href="#effective-generators" title="Permalink to this headline">¶</a></h2>
<p id="index-4">Imagine we want to count the number of triangles (<span class="math notranslate nohighlight">\(K_3\)</span> subgraphs)
appearing in a graph.  Suppose the graph is defined by
an adjacency matrix: <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> is true if nodes <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"></span></code> are
adjacent.  We might write</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s">  </span><span class="o">/\</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"></span>
<span class="s">                       </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]);</span><span class="s"></span>
</pre></div>
</div>
<p>which is certainly correct, but it examines all triples of nodes.
If the graph is sparse we can do better by realising that some
tests can be applied as soon as we select <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"></span></code>.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">     </span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]));</span><span class="s"></span>
</pre></div>
</div>
<p>You can use the builitin <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="s"></span></code> <span class="target" id="index-5"></span>function to help
determine what is happening inside generators.</p>
<div class="admonition-tracing admonition" id="defblock-2">
<p class="first admonition-title">Tracing</p>
<p class="last">The function <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="p">(</span><span class="nv">s</span><span class="p">,</span><span class="nv">e</span><span class="p">)</span><span class="s"></span></code> prints the string <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> before
evaluating the expression <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">e</span><span class="s"></span></code> and returning its value.
It can be used in any context.</p>
</div>
<p>For example, we can see how many times the test is performed in the inner
loop for both versions of the calculation.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="bp">count</span><span class="o">=</span><span class="nb">sum</span><span class="p">([</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span>
<span class="s">          </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="nv">j</span><span class="o">&lt;</span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])</span><span class="s"> </span><span class="p">]);</span><span class="s"></span>
<span class="nv">adj</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="s"></span>
<span class="s">       </span><span class="p">|</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">false</span><span class="p">,</span><span class="s"> </span><span class="l">true</span><span class="p">,</span><span class="s">  </span><span class="l">false</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Produces the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="o">----------</span>
</pre></div>
</div>
<p>indicating the inner loop is evaluated 64 times while</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">  </span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="m">1</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])]));</span><span class="s"></span>
</pre></div>
</div>
<p>Produces the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">++++++++++++++++</span>
<span class="o">----------</span>
</pre></div>
</div>
<p>indicating the inner loop is evaluated 16 times.</p>
<p>Note that you can use the dependent strings in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">trace</span><span class="s"></span></code> to
understand what is happening during model creation.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])(</span><span class="s"></span>
<span class="s">       </span><span class="nb">sum</span><span class="p">([</span><span class="nb">trace</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">i</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;,&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">j</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;,&quot;</span><span class="o">++</span><span class="nb">show</span><span class="p">(</span><span class="nv">k</span><span class="p">)</span><span class="o">++</span><span class="s">&quot;)&quot;</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">|</span><span class="s"> </span>
<span class="s">             </span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">NODES</span><span class="s"> </span><span class="k">where</span><span class="s">  </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">adj</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">]]));</span><span class="s"></span>
</pre></div>
</div>
<p>will print out each of triangles that is found in the calculation.
It produces the output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">----------</span>
</pre></div>
</div>
</div>
<div class="section" id="redundant-constraints">
<h2>2.6.4. Redundant Constraints<a class="headerlink" href="#redundant-constraints" title="Permalink to this headline">¶</a></h2>
<p id="index-6">The form of a model will affect how well the constraint solver can solve it.
In many cases adding constraints which are redundant, i.e. are logically
implied by the existing model, may improve the search for
solutions by making more information available to the solver earlier.</p>
<p>Consider the magic series problem from <a class="reference internal" href="modelling2.html#sec-complex"><span class="std std-ref">Complex Constraints</span></a>.
Running this for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">16</span><span class="s"></span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd --all-solutions --statistics magic-series.mzn -D <span class="s2">&quot;n=16;&quot;</span>
</pre></div>
</div>
<p>might result in output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
<span class="o">----------</span>
<span class="o">==========</span>
</pre></div>
</div>
<p>and the statistics showing 174 choice points required.</p>
<p>We can add redundant constraints to the model. Since each number
in the sequence counts the number of occurrences of a number we know
that they sum up to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>. Similarly we know that the sum of
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code> must also add up to <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> because the sequence is magic.
Adding these constraints
gives the model in
<a class="reference internal" href="#ex-magic-series2"><span class="std std-numref">Listing 2.43</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ex-magic-series2">
<div class="code-block-caption"><span class="caption-number">Listing 2.43 </span><span class="caption-text">Model solving the magic series problem with redundant constraints (<a class="reference download internal" href="_downloads/magic-series2.mzn" download=""><tt class="xref download docutils literal">magic-series2.mzn</tt></a>).</span><a class="headerlink" href="#ex-magic-series2" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">))));</span><span class="s"></span>
<span class="c">% redundant</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s">   </span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;s = &quot;</span><span class="p">,</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">s</span><span class="p">),</span><span class="s"> &quot;;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">]</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>Running the same problem as before</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd --all-solutions --statistics magic-series2.mzn -D <span class="s2">&quot;n=16;&quot;</span>
</pre></div>
</div>
<p>results in the same output, but with statistics showing just 13 choicepoints
explored. The redundant constraints have allowed the solver to prune the
search much earlier.</p>
</div>
<div class="section" id="modelling-choices">
<h2>2.6.5. Modelling Choices<a class="headerlink" href="#modelling-choices" title="Permalink to this headline">¶</a></h2>
<p>There are many ways to model the same problem in MiniZinc,
although some may be more natural than others.
Different models may have very different efficiency of solving, and worse
yet, different models may be better or worse for different solving backends.
There are however some guidelines for usually producing better models:</p>
<div class="admonition-choosing-between-models admonition" id="defblock-3">
<p class="first admonition-title">Choosing between models</p>
<p>The better model is likely to have some of the following features</p>
<ul class="simple">
<li>smaller number of variables, or at least those that are not
functionally defined by other variables</li>
<li>smaller domain sizes of variables</li>
<li>more succinct, or direct, definition of the constraints of the model</li>
<li>uses global constraints as much as possible</li>
</ul>
<p class="last">In reality all this has to be tempered by how effective the search is for
the model.  Usually the effectiveness of search is hard to judge except by
experimentation.</p>
</div>
<p>Consider the problem of finding permutations of <span class="math notranslate nohighlight">\(n\)</span> numbers
from 1 to <span class="math notranslate nohighlight">\(n\)</span> such that the differences between adjacent numbers
also form a permutation of numbers 1 to <span class="math notranslate nohighlight">\(n-1\)</span>.
Note that the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables are functionally defined by
the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> variables so the raw search space is <span class="math notranslate nohighlight">\(n^n\)</span>.
The obvious way to model this problem is shown in <a class="reference internal" href="#ex-allint"><span class="std std-numref">Listing 2.44</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint">
<div class="code-block-caption"><span class="caption-number">Listing 2.44 </span><span class="caption-text">A natural model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="_downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s">      </span><span class="c">% sequence of numbers</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of differences</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">u</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">u</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]));</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="nb">show</span><span class="p">(</span><span class="nv">x</span><span class="p">),</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>In this model the array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> represents the permutation of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>
numbers and the constraints are naturally represented using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code>.</p>
<p>Running the model</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd -all-solutions --statistics allinterval.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>finds all solutions in 84598 choice points and 3s.</p>
<p>An alternate model uses array <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> gives the
position of the number <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> in the sequence.
We also model the positions of the differences using variables
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code>. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> is the position in the sequence where the absolute difference
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> occurs.  If the values of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> differ by one
where <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code>, meaning the
positions are adjacent, then <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> is constrained to be the earliest
of these positions.
We can add two redundant constraints to this model:
since we know that a difference of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="s"></span></code> must result, we know that
the positions of 1 and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> must be adjacent (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">abs</span><span class="p">(</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code>),
which also tell us that the position of difference <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="s"></span></code> is
the earlier of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="s"></span></code>, i.e.
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"></span></code>.
With this we can model the problem
as shown in <a class="reference internal" href="#ex-allint2"><span class="std std-numref">Listing 2.45</span></a>. The output statement recreates the
original sequence <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> from the array of positions <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint2">
<div class="code-block-caption"><span class="caption-number">Listing 2.45 </span><span class="caption-text">An inverse model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="_downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint2" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s">  </span><span class="c">% position of each number</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"> </span><span class="c">% position of difference i</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="s"></span>
<span class="s">	   	 </span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">                 </span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"></span>
<span class="s">	   </span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;x = [&quot;</span><span class="p">,]</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">       </span><span class="p">[</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">i</span><span class="p">)</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;]</span><span class="se">\n</span><span class="s">;&quot; </span><span class="k">else</span><span class="s"> &quot;, &quot; </span><span class="k">endif</span><span class="s"> </span>
<span class="s">         </span><span class="p">|</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The inverse model has the same size as the original model, in terms of
number of variables and domain sizes.  But the inverse model has a much more
indirect way of modelling the relationship between the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables
as opposed to the relationship between <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables.
Hence we might expect the original model to be better.</p>
<p>The command</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd --all-solutions --statistics allinterval2.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>finds all the solutions in  75536 choice points and 18s.
Interestingly, although the model is not as succinct here, the search on the
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> variables is better than searching on the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> variables.
The lack of succinctness means that even though the search requires
less choice it is substantially slower.</p>
</div>
<div class="section" id="multiple-modelling-and-channels">
<span id="sec-multiple-modelling-and-channels"></span><h2>2.6.6. Multiple Modelling and Channels<a class="headerlink" href="#multiple-modelling-and-channels" title="Permalink to this headline">¶</a></h2>
<p>When we have two models for the same problem it may be
useful to use both models together by tying the variables in the two models
together, since each can give different information to the solver.</p>
<div class="literal-block-wrapper docutils container" id="ex-allint3">
<div class="code-block-caption"><span class="caption-number">Listing 2.46 </span><span class="caption-text">A dual model for the all interval series problem <tt class="docutils literal">prob007</tt> in CSPlib (<a class="reference download internal" href="_downloads/allinterval3.mzn" download=""><tt class="xref download docutils literal">allinterval3.mzn</tt></a>).</span><a class="headerlink" href="#ex-allint3" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;inverse.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of numbers</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">;</span><span class="s">  </span><span class="c">% sequence of differences</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">u</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]));</span><span class="s"> </span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s">  </span><span class="c">% position of each number</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"> </span><span class="c">% position of difference i</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="nv">u</span><span class="p">,</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">n</span><span class="p">]);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">      </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;x = &quot;</span><span class="p">,</span><span class="nb">show</span><span class="p">(</span><span class="nv">x</span><span class="p">),</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-allint3"><span class="std std-numref">Listing 2.46</span></a> gives a dual model combining features of
<a class="reference download internal" href="_downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a> and <a class="reference download internal" href="_downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>.
The beginning of the model is taken from <a class="reference download internal" href="_downloads/allinterval.mzn" download=""><tt class="xref download docutils literal">allinterval.mzn</tt></a>.
We then introduce the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables from <a class="reference download internal" href="_downloads/allinterval2.mzn" download=""><tt class="xref download docutils literal">allinterval2.mzn</tt></a>.
We tie the variables together using the
global
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">inverse</span><span class="s"></span></code> constraint:
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">inverse</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="p">)</span><span class="s"></span></code> holds if <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> is the inverse function of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> (and vice versa),
that is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code>. A definition
is shown in <a class="reference internal" href="#ex-inverse"><span class="std std-numref">Listing 2.47</span></a>.
The model does not include the constraints relating the
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> variables, they are redundant (and indeed propagation
redundant)
so they do not add information for a
propagation solver. The <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraints are also missing since
they are made redundant (and propagation redundant) by the inverse
constraints.
The only constraints are the relationships of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">u</span><span class="s"></span></code> variables
and the redundant constraints on <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> and <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ex-inverse">
<div class="code-block-caption"><span class="caption-number">Listing 2.47 </span><span class="caption-text">A definition of the <tt class="docutils literal">inverse</tt> global constraint (<a class="reference download internal" href="_downloads/inverse.mzn" download=""><tt class="xref download docutils literal">inverse.mzn</tt></a>).</span><a class="headerlink" href="#ex-inverse" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">))(</span><span class="nv">invf</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">f</span><span class="p">))</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">f</span><span class="p">))(</span><span class="s"></span>
<span class="s">        </span><span class="nv">f</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">invf</span><span class="p">))(</span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">f</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">invf</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>One of the benefits of the dual model is that there is more scope for
defining different search strategies.
Running the dual model,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mzn-g12fd -all-solutions --statistics allinterval3.mzn -D <span class="s2">&quot;n=10;&quot;</span>
</pre></div>
</div>
<p>which uses the search strategy of
the inverse model, labelling the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> variables,
finds all solutions in 1714 choice points and 0.5s.
Note that running the same model with labelling on the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> variables
requires 13142 choice points and 1.5s.</p>
</div>
<div class="section" id="symmetry">
<h2>2.6.7. Symmetry<a class="headerlink" href="#symmetry" title="Permalink to this headline">¶</a></h2>
<p>Symmetry is very common in constraint satisfaction and optimisation problems. To illustrate this, let us look again at the n-queens problem from <a class="reference internal" href="mzn_search.html#ex-queens"><span class="std std-numref">Listing 2.39</span></a>. The top left chess board in <a class="reference internal" href="#fig-queens-sym"><span class="std std-numref">Fig. 2.10</span></a> shows a solution to the 8-queens problems (labeled “original”). The remaining chess boards show seven symmetric variants of the same solution: rotated by 90, 180 and 270 degrees, and flipped vertically.</p>
<div class="figure" id="id1">
<span id="fig-queens-sym"></span><img alt="_images/queens_symm.svg" src="_images/queens_symm.svg" /><p class="caption"><span class="caption-number">Fig. 2.10 </span><span class="caption-text">Symmetric variants of an 8-queens solution</span></p>
</div>
<p>If we wanted to enumerate <em>all</em> solutions to the 8-queens problem, we could obviously save the solver some work by only enumerating <em>non-symmetric</em> solutions, and then generating the symmetric variants ourselves. This is one reason why we want to get rid of symmetry in constraint models. The other, much more important reason, is that the solver may also <strong>explore symmetric variants of non-solution states!</strong></p>
<p>For example, a typical constraint solver may try to place the queen in column 1 into row 1 (which is fine), and then try to put the column 2 queen into row 3, which, at first sight, does not violate any of the constraints. However, this configuration cannot be completed to a full solution (which the solver finds out after a little search). <a class="reference internal" href="#fig-queens-sym-unsat"><span class="std std-numref">Fig. 2.11</span></a> shows this configuration on the top left chess board. Now nothing prevents the solver from trying, e.g., the second configuration from the left in the bottom row of <a class="reference internal" href="#fig-queens-sym-unsat"><span class="std std-numref">Fig. 2.11</span></a>, where the queen in column 1 is still in row 1, and the queen in column 3 is placed in row 2. Therefore, even when only searching for a single solution, the solver may explore many symmetric states that it has already seen and proven unsatisfiable before!</p>
<div class="figure" id="id2">
<span id="fig-queens-sym-unsat"></span><img alt="_images/queens_symm_unsat.svg" src="_images/queens_symm_unsat.svg" /><p class="caption"><span class="caption-number">Fig. 2.11 </span><span class="caption-text">Symmetric variants of an 8-queens unsatisfiable partial assignment</span></p>
</div>
<div class="section" id="static-symmetry-breaking">
<h3>2.6.7.1. Static Symmetry Breaking<a class="headerlink" href="#static-symmetry-breaking" title="Permalink to this headline">¶</a></h3>
<p>The modelling technique for dealing with symmetry is called <em>symmetry breaking</em>, and in its simplest form, involves adding constraints to the model that rule out all symmetric variants of a (partial) assignment to the variables except one. These constraints are called <em>static symmetry breaking constraints</em>.</p>
<p>The basic idea behind symmetry breaking is to impose an <em>order</em>. For example, to rule out any vertical flips of the chess board, we could simply add the constraint that the queen in the first column must be in the top half of the board:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">q</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Convince yourself that this would remove exactly half of the symmetric variants in <a class="reference internal" href="#fig-queens-sym"><span class="std std-numref">Fig. 2.10</span></a>. In order to remove <em>all</em> symmetry, we need to work a bit harder.</p>
<p>Whenever we can express all symmetries as permutations of the array of variables, a set of <em>lexicographic ordering constraints</em> can be used to break all symmetry. For example, if the array of variables is called <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code>, and reversing the array is a symmetry of the problem, then the following constraint will break that symmetry:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="nv">x</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>How about two-dimensional arrays? Lexicographic ordering works just the same, we only have to coerce the arrays into one dimension. For example, the following breaks the symmetry of flipping the array along one of the diagonals (note the swapped indices in the second comprehension):</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">([</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>The great thing about using lexicographic ordering constraints is that we can add multiple ones (to break several symmetries simultaneously), without them interfering with each other, as long as we keep the order in the first argument the same.</p>
<p>For the n-queens problem, unfortunately this technique does not immediately apply, because some of its symmetries cannot be described as permutations of the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> array. The trick to overcome this is to express the n-queens problem in terms of Boolean variables that model, for each field of the board, whether it contains a queen or not. Now all the symmetries can be modeled as permutations of this array. Since the main constraints of the n-queens problem are much easier to express with the integer <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">q</span><span class="s"></span></code> array, we simply use both models together and add channeling constraints between them, as explained in <a class="reference internal" href="#sec-multiple-modelling-and-channels"><span class="std std-ref">Multiple Modelling and Channels</span></a>.</p>
<p>The full model, with added Boolean variables, channeling constraints and symmetry breaking constraints is shown in <a class="reference internal" href="#ex-queens-sym"><span class="std std-numref">Listing 2.48</span></a>. We can conduct a little experiment to check whether it successfully breaks all the symmetry. Try running the model with increasing values for <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code>, e.g. from 1 to 10, counting the number of solutions (e.g., by using the <tt class="docutils literal">-s</tt> flag with the Gecode solver, or selecting “Print all solutions” as well as “Statistics for solving” in the IDE). You should get the following sequence of numbers of solutions: 1, 0, 0, 1, 2, 1, 6, 12, 46, 92. To verify the sequence, you can search for it in the <em>On-Line Encyclopedia of Integer Sequences</em> (<a class="reference external" href="http://oeis.org">http://oeis.org</a>).</p>
<div class="literal-block-wrapper docutils container" id="ex-queens-sym">
<div class="code-block-caption"><span class="caption-number">Listing 2.48 </span><span class="caption-text">Partial model for n-queens with symmetry breaking (full model: <a class="reference download internal" href="_downloads/nqueens_sym.mzn" download=""><tt class="xref download docutils literal">nqueens_sym.mzn</tt></a>).</span><a class="headerlink" href="#ex-queens-sym" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% Map each position i,j to a Boolean telling us whether there is a queen at i,j</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">qb</span><span class="p">;</span><span class="s"></span>

<span class="c">% Channeling constraint</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">q</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="o">=</span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="c">% Lexicographic symmetry breaking constraints</span><span class="s"></span>
<span class="k">constraint</span><span class="s"></span>
<span class="s">    </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">),</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">),</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="o">/\</span><span class="s">  </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="nb">array1d</span><span class="p">(</span><span class="nv">qb</span><span class="p">),</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">qb</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nf">reverse</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)</span><span class="s"> </span><span class="p">])</span><span class="s"></span>
<span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="other-examples-of-symmetry">
<h3>2.6.7.2. Other Examples of Symmetry<a class="headerlink" href="#other-examples-of-symmetry" title="Permalink to this headline">¶</a></h3>
<p>Many other problems have inherent symmetries, and breaking these can often make a significant difference in solving performance. Here is a list of some common cases:</p>
<ul class="simple">
<li>Bin packing: when trying to pack items into bins, any two bins that have
the same capacity are symmetric.</li>
<li>Graph colouring: When trying to assign colours to nodes in a graph such
that adjacent nodes must have different colours, we typically model
colours as integer numbers. However, any permutation of colours is again a
valid graph colouring.</li>
<li>Vehicle routing: if the task is to assign customers to certain vehicles,
any two vehicles with the same capacity may be symmetric (this is similar
to the bin packing example).</li>
<li>Rostering/time tabling: two staff members with the same skill set may be
interchangeable, just like two rooms with the same capacity or technical
equipment.</li>
</ul>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, 2017, Peter J. Stuckey, Kim Marriott, Guido Tack.<br/>
    </p>
  </div>
</footer>
  </body>
</html>