<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.2.1. Global constraints &#8212; The MiniZinc Handbook 2.2.0</title>
    <link rel="stylesheet" href="static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="static/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4.2.2. Annotations" href="lib-annotations.html" />
    <link rel="prev" title="4.2. The MiniZinc library" href="lib.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="static/MiniZn_logo_2.svg"></span>
          The MiniZinc Handbook</a>
        <span class="navbar-text navbar-version pull-left"><b>2.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html">1.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html#structure">1.1.1. Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro.html#how-to-read-this">1.1.2. How to Read This</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">1.2. Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installation.html#binary-packages">1.2.1. Binary Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#compilation-from-source-code">1.2.2. Compilation from Source Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#adding-third-party-solvers">1.2.3. Adding Third-party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="basic_steps.html">1.3. First steps with MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-ide">1.3.1. The MiniZinc IDE</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-command-line-tool">1.3.2. The MiniZinc command line tool</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#our-first-example">2.1.1. Our First Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#an-arithmetic-optimisation-example">2.1.2. An Arithmetic Optimisation Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#datafiles-and-assertions">2.1.3. Datafiles and Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#real-number-solving">2.1.4. Real Number Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#basic-structure-of-a-model">2.1.5. Basic structure of a model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#arrays-and-sets">2.2.1. Arrays and Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#global-constraints">2.2.2. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#conditional-expressions">2.2.3. Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#enumerated-types">2.2.4. Enumerated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#complex-constraints">2.2.5. Complex Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#set-constraints">2.2.6. Set Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#putting-it-all-together">2.2.7. Putting it all together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#global-constraints">2.3.1. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-predicates">2.3.2. Defining Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-functions">2.3.3. Defining Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#reflection-functions">2.3.4. Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-variables">2.3.5. Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#context">2.3.6. Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-constraints">2.3.7. Local Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#domain-reflection-functions">2.3.8. Domain Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#scope">2.3.9. Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#declaring-and-using-option-types">2.4.1. Declaring and Using Option Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#hidden-option-types">2.4.2. Hidden Option Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#annotations">2.5.3. Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#effective-generators">2.6.2. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#redundant-constraints">2.6.3. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#modelling-choices">2.6.4. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#multiple-modelling-and-channels">2.6.5. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#symmetry">2.6.6. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-integers">2.7.1. Modelling Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#flattening-expressions">2.8.1. Flattening Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#linear-expressions">2.8.2. Linear Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#arrays">2.8.4. Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#reification">2.8.5. Reification</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#predicates">2.8.6. Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="command_line.html">3.1. The MiniZinc Command Line Tool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#basic-usage">3.1.1. Basic Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#adding-solvers">3.1.2. Adding Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#options">3.1.3. Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#user-configuration-files">3.1.4. User Configuration Files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="minizinc_ide.html">3.2. The MiniZinc IDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#editing-minizinc-model-files">3.2.1. Editing MiniZinc model files</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuring-and-running-the-solver">3.2.2. Configuring and Running the Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#working-with-projects">3.2.3. Working With Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#automatic-solution-checking">3.2.4. Automatic Solution Checking</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#submitting-solutions-to-online-courses">3.2.5. Submitting Solutions to Online Courses</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuration-options">3.2.6. Configuration Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#adding-third-party-solvers">3.2.7. Adding Third-Party Solvers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spec.html">4.1. Specification of MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spec.html#introduction">4.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#notation">4.1.2. Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#overview-of-a-model">4.1.3. Overview of a Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#syntax-overview">4.1.4. Syntax Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#high-level-model-structure">4.1.5. High-level Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#types-and-type-insts">4.1.6. Types and Type-insts</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#expressions">4.1.7. Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#items">4.1.8. Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#annotations">4.1.9. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#partiality">4.1.10. Partiality</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#built-in-operations">4.1.11. Built-in Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#content-types">4.1.12. Content-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#json-support">4.1.13. JSON support</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#full-grammar">4.1.14. Full grammar</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="lib.html">4.2. The MiniZinc library</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">4.2.1. Global constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-annotations.html">4.2.2. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-optiontypes.html">4.2.3. Option type support</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-options.html">4.2.4. Compiler options</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-builtins.html">4.2.5. Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-flatzinc.html">4.2.6. FlatZinc builtins</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-spec.html">4.3. Interfacing Solvers to Flatzinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#specification-of-flatzinc">4.3.1. Specification of FlatZinc</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#output">4.3.2. Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#solver-specific-libraries">4.3.3. Solver-specific Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#command-line-interface">4.3.4. Command Line Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#solver-configuration-files">4.3.5. Solver Configuration Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#grammar">4.3.6. Grammar</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">4.2.1. Global constraints</a><ul>
<li><a class="reference internal" href="#all-different-and-related-constraints">4.2.1.1. All-Different and related constraints</a></li>
<li><a class="reference internal" href="#lexicographic-constraints">4.2.1.2. Lexicographic constraints</a></li>
<li><a class="reference internal" href="#sorting-constraints">4.2.1.3. Sorting constraints</a></li>
<li><a class="reference internal" href="#channeling-constraints">4.2.1.4. Channeling constraints</a></li>
<li><a class="reference internal" href="#counting-constraints">4.2.1.5. Counting constraints</a></li>
<li><a class="reference internal" href="#packing-constraints">4.2.1.6. Packing constraints</a></li>
<li><a class="reference internal" href="#scheduling-constraints">4.2.1.7. Scheduling constraints</a></li>
<li><a class="reference internal" href="#extensional-constraints-table-regular-etc">4.2.1.8. Extensional constraints (table, regular etc.)</a></li>
<li><a class="reference internal" href="#other-declarations">4.2.1.9. Other declarations</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="lib.html" title="Previous Chapter: 4.2. The MiniZinc library"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 4.2. The Mini...</span>
    </a>
  </li>
  <li>
    <a href="lib-annotations.html" title="Next Chapter: 4.2.2. Annotations"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">4.2.2. Annotations &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="global-constraints">
<span id="ch-lib-globals"></span><h1>4.2.1. Global constraints<a class="headerlink" href="#global-constraints" title="Permalink to this headline">¶</a></h1>
<p>These constraints represent high-level modelling abstractions, for which
many solvers implement special, efficient inference algorithms.</p>
<div class="section" id="all-different-and-related-constraints">
<h2>4.2.1.1. All-Different and related constraints<a class="headerlink" href="#all-different-and-related-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers  <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/all_different_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers  <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/all_different_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_disjoint</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers  <tt class="docutils literal">S</tt>  to be pairwise disjoint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/all_disjoint.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-3"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers  <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/all_equal_int.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-4"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers  <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/all_equal_set.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-5"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alldifferent_except_0</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers  <tt class="docutils literal">vs</tt>  to be all different except those
elements that are assigned the value 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/alldifferent_except_0.mzn#L5-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-6"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of distinct values in  <tt class="docutils literal">x</tt>  is  <tt class="docutils literal">n</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/nvalue.mzn#L4-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-7"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of distinct values in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/nvalue_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">symmetric_all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires the array of integers  <tt class="docutils literal">x</tt>  to be all different, and for all  <tt class="docutils literal">i</tt> ,
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ]=j <span class="math notranslate nohighlight">\(\rightarrow\)</span>  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">j</tt> ]= <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/symmetric_all_different.mzn#L8-L10">More…</a></p>
</div>
<div class="section" id="lexicographic-constraints">
<h2>4.2.1.2. Lexicographic constraints<a class="headerlink" href="#lexicographic-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-9"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array  <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns may be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex2.mzn#L7-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-10"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greater.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-11"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greater.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-12"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greater.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-13"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greater.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-14"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greatereq.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-15"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greatereq.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-16"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greatereq.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-17"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_greatereq.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-18"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_less_bool.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-19"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_less_int.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-20"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_less_float.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-21"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_less_set.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-22"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_lesseq_bool.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-23"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_lesseq_float.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-24"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_lesseq_int.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-25"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array  <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/lex_lesseq_set.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-26"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">strict_lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array  <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns cannot be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/strict_lex2.mzn#L7-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-27"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">s</tt>  precede  <tt class="docutils literal">t</tt>  in the array  <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of  <tt class="docutils literal">x</tt>
is equal to  <tt class="docutils literal">t</tt> , then another element of  <tt class="docutils literal">x</tt>  with a  lower index is equal
to  <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/value_precede_int.mzn#L1-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-28"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">s</tt>  precede  <tt class="docutils literal">t</tt>  in the array  <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of  <tt class="docutils literal">x</tt>
contains  <tt class="docutils literal">t</tt>  but not  <tt class="docutils literal">s</tt> , then another element of  <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">s</tt>  but not  <tt class="docutils literal">t</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/value_precede_set.mzn#L1-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-29"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array  <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of  <tt class="docutils literal">x</tt>
is equal to  <tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt>  +1], then another element of  <tt class="docutils literal">x</tt>  with a  lower index is equal
to  <tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/value_precede_chain_int.mzn#L3-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-30"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array  <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of  <tt class="docutils literal">x</tt>
contains  <tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt>  +1] but not  <tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt> ], then another element of  <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt> ] but not  <tt class="docutils literal">\a</tt>  c[ <tt class="docutils literal">i</tt>  +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/value_precede_chain_set.mzn#L3-L6">More…</a></p>
</div>
<div class="section" id="sorting-constraints">
<h2>4.2.1.3. Sorting constraints<a class="headerlink" href="#sorting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-31"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation  <tt class="docutils literal">p</tt>  which causes  <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;=  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] =  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span>  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt;  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_sort.mzn#L7-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-32"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation  <tt class="docutils literal">p</tt>  which causes  <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;=  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] =  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span>  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt;  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_sort.mzn#L24-L32">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-33"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">p</tt>  to be the permutation which causes  <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;=  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] =  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span>  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt;  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_sort_int.mzn#L3-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-34"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">p</tt>  to be the permutation which causes  <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;=  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] =  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span>  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt;  <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_sort_float.mzn#L3-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-35"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/decreasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-36"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/decreasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-37"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/decreasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-38"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/decreasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-39"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/increasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-40"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/increasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-41"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/increasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-42"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array  <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/increasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-43"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the multiset of values in  <tt class="docutils literal">x</tt>  are the same as the
multiset of values in  <tt class="docutils literal">y</tt>  but  <tt class="docutils literal">y</tt>  is in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/sort.mzn#L8-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-44"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Return a multiset of values that is the same as the
multiset of values in  <tt class="docutils literal">x</tt>  but in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/sort_fn.mzn#L7-L11">More…</a></p>
</div>
<div class="section" id="channeling-constraints">
<h2>4.2.1.4. Channeling constraints<a class="headerlink" href="#channeling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-45"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">int_set_channel</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that array of int variables  <tt class="docutils literal">x</tt>  and array of set variables  <tt class="docutils literal">y</tt>
are related such that ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] =  <tt class="docutils literal">j</tt> ) &amp;#8596; ( <tt class="docutils literal">i</tt>  in  <tt class="docutils literal">y</tt> [ <tt class="docutils literal">j</tt> ]).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/int_set_channel.mzn#L5-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-46"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of int variables,  <tt class="docutils literal">f</tt>  and  <tt class="docutils literal">invf</tt> , to represent
inverse functions.  All the values in each array must be within the index
set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/inverse.mzn#L6-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-47"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Given a function  <tt class="docutils literal">f</tt>  represented as an array, return the inverse function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/inverse_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-48"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of set of int variables,  <tt class="docutils literal">f</tt>  and  <tt class="docutils literal">invf</tt> , so that
a  <tt class="docutils literal">j</tt>  in f[ <tt class="docutils literal">i</tt> ] iff  <tt class="docutils literal">i</tt>  in invf[ <tt class="docutils literal">j</tt> ].  All the values in each array’s sets
must be within the index set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/inverse_set.mzn#L6-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-49"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">link_set_to_booleans</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of Booleans  <tt class="docutils literal">b</tt>  to be a representation of the set  <tt class="docutils literal">s</tt> :
<tt class="docutils literal">i</tt>  in  <tt class="docutils literal">s</tt>  &amp;#8596;  <tt class="docutils literal">b</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The index set of  <tt class="docutils literal">b</tt>  must be a superset of the possible values of  <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/link_set_to_booleans.mzn#L7-L11">More…</a></p>
</div>
<div class="section" id="counting-constraints">
<h2>4.2.1.5. Counting constraints<a class="headerlink" href="#counting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-50"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take one of the values in  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/among.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-51"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of variables in  <tt class="docutils literal">x</tt>  that take one of the values in  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/among_fn.mzn#L6-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-52"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/at_least_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-53"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/at_least_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-54"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/at_most_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-55"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/at_most_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-56"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most1</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each pair of sets in  <tt class="docutils literal">s</tt>  overlap in at most one element.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/at_most1.mzn#L4-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-57"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be the number of occurrences of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_eq.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-58"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-59"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_eq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be the number of occurrences of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_eq.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-60"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_geq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be greater than or equal to the number of occurrences
of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_geq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-61"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_gt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be strictly greater than the number of occurrences
of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_gt.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-62"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_leq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be less than or equal to the number of occurrences
of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_leq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-63"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_lt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be strictly less than the number of occurrences
of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_lt.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-64"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_neq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">c</tt>  to be not equal to the number of occurrences
of  <tt class="docutils literal">y</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/count_neq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-65"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nb">card</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">card</tt> [ <tt class="docutils literal">i</tt> ] is the number of occurences of  <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in  <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/distribute.mzn#L5-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-66"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array of the number of occurences of  <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in  <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/distribute_fn.mzn#L7-L11">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-67"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/exactly_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-68"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly  <tt class="docutils literal">n</tt>  variables in  <tt class="docutils literal">x</tt>  to take the value  <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/exactly_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-69"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurrences of  <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in  <tt class="docutils literal">x</tt>  is  <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality.mzn#L6-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-70"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of  <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-71"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurences of  <tt class="docutils literal">i</tt>  in  <tt class="docutils literal">x</tt>  is  <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The elements of  <tt class="docutils literal">x</tt>  must take their values from  <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality_closed.mzn#L6-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-72"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array with number of occurences of  <tt class="docutils literal">i</tt>  in  <tt class="docutils literal">x</tt> .</p>
<p>The elements of  <tt class="docutils literal">x</tt>  must take their values from  <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality_closed_fn.mzn#L8-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-73"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all  <tt class="docutils literal">i</tt> , the value  <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least  <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most  <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality_low_up.mzn#L5-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-74"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all  <tt class="docutils literal">i</tt> , the value  <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least  <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most  <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array  <tt class="docutils literal">x</tt> .</p>
<p>The elements of  <tt class="docutils literal">x</tt>  must take their values from  <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/global_cardinality_low_up_closed.mzn#L7-L16">More…</a></p>
</div>
<div class="section" id="packing-constraints">
<h2>4.2.1.6. Packing constraints<a class="headerlink" href="#packing-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-75"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item  <tt class="docutils literal">i</tt>  with weight  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into  <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin does not exceed the
capacity  <tt class="docutils literal">c</tt> .</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
<li><tt class="docutils literal">c</tt>  &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/bin_packing.mzn#L11-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-76"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_capa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item  <tt class="docutils literal">i</tt>  with weight  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into  <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin  <tt class="docutils literal">b</tt>  does not exceed the
capacity  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
<li>forall  <tt class="docutils literal">b</tt> ,  <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/bin_packing_capa.mzn#L11-L30">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-77"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">load</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item  <tt class="docutils literal">i</tt>  with weight  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into  <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin  <tt class="docutils literal">b</tt>  is equal to
<tt class="docutils literal">load</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/bin_packing_load.mzn#L10-L26">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-78"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the load of each bin resulting from packing each item  <tt class="docutils literal">i</tt>  with
weight  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] into  <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ], where the load is defined as
the sum of the weights of the items in each bin.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/bin_packing_load_fn.mzn#L12-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-79"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles  <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ],  <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ],  <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can still not overlap with any other rectangle.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/diffn.mzn#L6-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-80"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box  <tt class="docutils literal">i</tt>
and dimension  <tt class="docutils literal">j</tt> ,  <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension  <tt class="docutils literal">j</tt> , and  <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in any dimension still cannot overlap with any other box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/diffn_k.mzn#L7-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-81"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles  <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ],  <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ],  <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/diffn_nonstrict.mzn#L6-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-82"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box  <tt class="docutils literal">i</tt>
and dimension  <tt class="docutils literal">j</tt> ,  <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension  <tt class="docutils literal">j</tt> , and  <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in at least one dimension can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/diffn_nonstrict_k.mzn#L7-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-83"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for  <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/geost.mzn#L14-L77">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in  <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in  <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the  <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object.  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object  <tt class="docutils literal">i</tt>  in. dimension  <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-84"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for  <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global  <tt class="docutils literal">k</tt>  dimensional bounding box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/geost.mzn#L96-L129">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in  <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in  <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the  <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object.  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object  <tt class="docutils literal">i</tt>  in dimension  <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds,  <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension  <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds,  <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension  <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-85"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_smallest_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for  <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global  <tt class="docutils literal">k</tt>  dimensional bounding box. In addition, it enforces that the bounding box is the smallest one containing all objects, i.e., each of the  <tt class="docutils literal">2k</tt>  boundaries is touched by at least by one object.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/geost.mzn#L147-L181">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in  <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in  <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the  <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object.  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object  <tt class="docutils literal">i</tt>  in dimension  <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds,  <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension  <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds,  <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension  <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-86"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">W</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">P</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that items are packed in a knapsack with certain weight and profit restrictions.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>Weights  <tt class="docutils literal">w</tt>  and profits  <tt class="docutils literal">p</tt>  must be non-negative</li>
<li><tt class="docutils literal">w</tt> ,  <tt class="docutils literal">p</tt>  and  <tt class="docutils literal">x</tt>  must have the same index sets</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/knapsack.mzn#L16-L33">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">w</tt>:  weight of each type of item</li>
<li><tt class="docutils literal">p</tt>:  profit of each type of item</li>
<li><tt class="docutils literal">x</tt>:  number of items of each type that are packed</li>
<li><tt class="docutils literal">W</tt>:  sum of sizes of all items in the knapsack</li>
<li><tt class="docutils literal">P</tt>:  sum of profits of all items in the knapsack</li>
</ul>
</div>
<div class="section" id="scheduling-constraints">
<h2>4.2.1.7. Scheduling constraints<a class="headerlink" href="#scheduling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-87"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alternative</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Alternative constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the
optional tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments
and at most one can occur</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/alternative.mzn#L8-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-88"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt> , durations  <tt class="docutils literal">d</tt> , and
resource requirements  <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and  <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/cumulative.mzn#L13-L46">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-89"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt> , durations  <tt class="docutils literal">d</tt> , and
resource requirements  <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:
- forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and  <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/cumulative_opt.mzn#L10-L31">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-90"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt>  and durations  <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/disjunctive.mzn#L12-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-91"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt>  and durations  <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/disjunctive_opt.mzn#L13-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-92"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt>  and durations  <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/disjunctive_strict.mzn#L10-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-93"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times  <tt class="docutils literal">s</tt>  and durations  <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall  <tt class="docutils literal">i</tt> ,  <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/disjunctive_strict_opt.mzn#L11-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-94"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">span</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Span constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the optional
tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/span.mzn#L5-L14">More…</a></p>
</div>
<div class="section" id="extensional-constraints-table-regular-etc">
<h2>4.2.1.8. Extensional constraints (table, regular etc.)<a class="headerlink" href="#extensional-constraints-table-regular-etc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-95"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array  <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the DFA of  <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function  <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; 0.. <tt class="docutils literal">Q</tt> )) and initial state  <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states  <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).  We reserve state 0 to be an always failing state.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/regular.mzn#L8-L45">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-96"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular_nfa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array  <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the NFA of  <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function  <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; set of 1.. <tt class="docutils literal">Q</tt> )) and initial state  <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states  <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/regular_nfa.mzn#L8-L45">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-97"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint  <tt class="docutils literal">x</tt>  in  <tt class="docutils literal">t</tt>  where we
consider each row in  <tt class="docutils literal">t</tt>  to be a tuple and  <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/table_bool.mzn#L6-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-98"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint  <tt class="docutils literal">x</tt>  in  <tt class="docutils literal">t</tt>  where we
consider each row in  <tt class="docutils literal">t</tt>  to be a tuple and  <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/table_int.mzn#L6-L28">More…</a></p>
</div>
<div class="section" id="other-declarations">
<h2>4.2.1.9. Other declarations<a class="headerlink" href="#other-declarations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-99"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_max.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-100"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_max.mzn#L12-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-101"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_min.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-102"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_min.mzn#L12-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-103"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">circuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of  <tt class="docutils literal">x</tt>  to define a circuit where  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] =  <tt class="docutils literal">j</tt>  means
that  <tt class="docutils literal">j</tt>  is the successor of  <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/circuit.mzn#L7-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-104"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjoint</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s1</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s2</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that sets  <tt class="docutils literal">s1</tt>  and  <tt class="docutils literal">s2</tt>  do not intersect.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/disjoint.mzn#L2-L3">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-105"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">m</tt>  to be the maximum of the values in  <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/redefinitions-2.0.mzn#L25-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-106"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">m</tt>  to be the maximum of the values in  <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/redefinitions-2.0.mzn#L36-L44">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-107"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain  <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_max_int.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-108"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain  <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_max_float.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-109"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">y</tt>  occurs in the array  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/member_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-110"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">y</tt>  occurs in the array  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/member_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-111"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">y</tt>  occurs in the array  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/member_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-112"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">y</tt>  occurs in the array  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/member_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-113"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">y</tt>  occurs in the set  <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/set_member.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-114"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">m</tt>  to be the minimum of the values in  <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/redefinitions-2.0.mzn#L58-L66">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-115"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains  <tt class="docutils literal">m</tt>  to be the minimum of the values in  <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/redefinitions-2.0.mzn#L47-L55">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-116"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain  <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_min_int.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-117"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain  <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array  <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/arg_min_float.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-118"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/network_flow.mzn#L9-L28">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc  <tt class="docutils literal">i</tt>  connects node  <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node  <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-119"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow_cost</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">weight</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cost</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint with cost.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/network_flow.mzn#L39-L63">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc  <tt class="docutils literal">i</tt>  connects node  <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node  <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">weight</tt>:  the unit cost of the flow through the arc.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
<li><tt class="docutils literal">cost</tt>:  the overall cost of the flow.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-120"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">partition_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">universe</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the sets in array  <tt class="docutils literal">S</tt>  to partition the  <tt class="docutils literal">universe</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/partition_set.mzn#L6-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-121"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the image of function  <tt class="docutils literal">x</tt>  (represented as an array) on set
of values  <tt class="docutils literal">s</tt>  is  <tt class="docutils literal">t</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/range.mzn#L6-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-122"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the image of function  <tt class="docutils literal">x</tt>  (represented as an array) on set
of values  <tt class="docutils literal">s</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/range_fn.mzn#L8-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-123"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in  <tt class="docutils literal">t</tt>  for all  <tt class="docutils literal">i</tt>  in  <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/roots.mzn#L4-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-124"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns  <tt class="docutils literal">s</tt>  such that  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in  <tt class="docutils literal">t</tt>  for all  <tt class="docutils literal">i</tt>  in  <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/roots_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-125"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sliding_sum</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">low</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">up</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">seq</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that in each subsequence  <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt> ], …,  <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt>  +  <tt class="docutils literal">seq</tt>  - 1] the sum of the
values belongs to the interval [ <tt class="docutils literal">low</tt> ,  <tt class="docutils literal">up</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/sliding_sum.mzn#L5-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-126"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">subcircuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of  <tt class="docutils literal">x</tt>  to define a subcircuit where  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] =  <tt class="docutils literal">j</tt>
means that  <tt class="docutils literal">j</tt>  is the successor of  <tt class="docutils literal">i</tt>  and  <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] =  <tt class="docutils literal">i</tt>  means that  <tt class="docutils literal">i</tt>
is not in the circuit.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/subcircuit.mzn#L8-L52">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-127"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sum_pred</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">sets</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cs</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the sum of  <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">i1</tt> ].. <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">iN</tt> ] equals  <tt class="docutils literal">s</tt> ,
where  <tt class="docutils literal">i1</tt> .. <tt class="docutils literal">iN</tt>  are the elements of the  <tt class="docutils literal">i</tt>  th set in  <tt class="docutils literal">sets</tt> .</p>
<p>Nb: not called ‘sum’ as in the constraints catalog because ‘sum’ is a
MiniZinc built-in function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.0/share/minizinc/std/sum_pred.mzn#L9-L11">More…</a></p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.<br/>
    </p>
  </div>
</footer>
  </body>
</html>