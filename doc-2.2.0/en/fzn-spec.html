<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.3. Interfacing Solvers to Flatzinc &#8212; The MiniZinc Handbook 2.2.0</title>
    <link rel="stylesheet" href="static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="static/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="4.2.6. FlatZinc builtins" href="lib-flatzinc.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="static/MiniZn_logo_2.svg"></span>
          The MiniZinc Handbook</a>
        <span class="navbar-text navbar-version pull-left"><b>2.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html">1.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html#structure">1.1.1. Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro.html#how-to-read-this">1.1.2. How to Read This</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">1.2. Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installation.html#binary-packages">1.2.1. Binary Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#compilation-from-source-code">1.2.2. Compilation from Source Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#adding-third-party-solvers">1.2.3. Adding Third-party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="basic_steps.html">1.3. First steps with MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-ide">1.3.1. The MiniZinc IDE</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-command-line-tool">1.3.2. The MiniZinc command line tool</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#our-first-example">2.1.1. Our First Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#an-arithmetic-optimisation-example">2.1.2. An Arithmetic Optimisation Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#datafiles-and-assertions">2.1.3. Datafiles and Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#real-number-solving">2.1.4. Real Number Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#basic-structure-of-a-model">2.1.5. Basic structure of a model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#arrays-and-sets">2.2.1. Arrays and Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#global-constraints">2.2.2. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#conditional-expressions">2.2.3. Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#enumerated-types">2.2.4. Enumerated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#complex-constraints">2.2.5. Complex Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#set-constraints">2.2.6. Set Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#putting-it-all-together">2.2.7. Putting it all together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#global-constraints">2.3.1. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-predicates">2.3.2. Defining Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-functions">2.3.3. Defining Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#reflection-functions">2.3.4. Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-variables">2.3.5. Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#context">2.3.6. Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-constraints">2.3.7. Local Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#domain-reflection-functions">2.3.8. Domain Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#scope">2.3.9. Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#declaring-and-using-option-types">2.4.1. Declaring and Using Option Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#hidden-option-types">2.4.2. Hidden Option Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#annotations">2.5.3. Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#effective-generators">2.6.2. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#redundant-constraints">2.6.3. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#modelling-choices">2.6.4. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#multiple-modelling-and-channels">2.6.5. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#symmetry">2.6.6. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-integers">2.7.1. Modelling Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li class="toctree-l3"><a class="reference internal" href="sat.html#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#flattening-expressions">2.8.1. Flattening Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#linear-expressions">2.8.2. Linear Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#arrays">2.8.4. Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#reification">2.8.5. Reification</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#predicates">2.8.6. Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="command_line.html">3.1. The MiniZinc Command Line Tool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#basic-usage">3.1.1. Basic Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#adding-solvers">3.1.2. Adding Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#options">3.1.3. Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#user-configuration-files">3.1.4. User Configuration Files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="minizinc_ide.html">3.2. The MiniZinc IDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#editing-minizinc-model-files">3.2.1. Editing MiniZinc model files</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuring-and-running-the-solver">3.2.2. Configuring and Running the Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#working-with-projects">3.2.3. Working With Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#automatic-solution-checking">3.2.4. Automatic Solution Checking</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#submitting-solutions-to-online-courses">3.2.5. Submitting Solutions to Online Courses</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuration-options">3.2.6. Configuration Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#adding-third-party-solvers">3.2.7. Adding Third-Party Solvers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spec.html">4.1. Specification of MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spec.html#introduction">4.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#notation">4.1.2. Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#overview-of-a-model">4.1.3. Overview of a Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#syntax-overview">4.1.4. Syntax Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#high-level-model-structure">4.1.5. High-level Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#types-and-type-insts">4.1.6. Types and Type-insts</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#expressions">4.1.7. Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#items">4.1.8. Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#annotations">4.1.9. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#partiality">4.1.10. Partiality</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#built-in-operations">4.1.11. Built-in Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#content-types">4.1.12. Content-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#json-support">4.1.13. JSON support</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#full-grammar">4.1.14. Full grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lib.html">4.2. The MiniZinc library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lib-globals.html">4.2.1. Global constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-annotations.html">4.2.2. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-optiontypes.html">4.2.3. Option type support</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-options.html">4.2.4. Compiler options</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-builtins.html">4.2.5. Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-flatzinc.html">4.2.6. FlatZinc builtins</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.3. Interfacing Solvers to Flatzinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#specification-of-flatzinc">4.3.1. Specification of FlatZinc</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output">4.3.2. Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solver-specific-libraries">4.3.3. Solver-specific Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-line-interface">4.3.4. Command Line Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solver-configuration-files">4.3.5. Solver Configuration Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grammar">4.3.6. Grammar</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">4.3. Interfacing Solvers to Flatzinc</a><ul>
<li><a class="reference internal" href="#specification-of-flatzinc">4.3.1. Specification of FlatZinc</a><ul>
<li><a class="reference internal" href="#comments">4.3.1.1. Comments</a></li>
<li><a class="reference internal" href="#types">4.3.1.2. Types</a><ul>
<li><a class="reference internal" href="#parameter-types">Parameter types</a></li>
<li><a class="reference internal" href="#variable-types">Variable types</a></li>
<li><a class="reference internal" href="#the-string-type">The string type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#values-and-expressions">4.3.1.3. Values and expressions</a></li>
<li><a class="reference internal" href="#flatzinc-models">4.3.1.4. FlatZinc models</a></li>
<li><a class="reference internal" href="#predicate-declarations">4.3.1.5. Predicate declarations</a></li>
<li><a class="reference internal" href="#parameter-declarations">4.3.1.6. Parameter declarations</a></li>
<li><a class="reference internal" href="#variable-declarations">4.3.1.7. Variable declarations</a></li>
<li><a class="reference internal" href="#constraints">4.3.1.8. Constraints</a></li>
<li><a class="reference internal" href="#solve-item">4.3.1.9. Solve item</a></li>
<li><a class="reference internal" href="#annotations">4.3.1.10. Annotations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#output">4.3.2. Output</a><ul>
<li><a class="reference internal" href="#solution-output">4.3.2.1. Solution output</a></li>
<li><a class="reference internal" href="#statistics-output">4.3.2.2. Statistics output</a></li>
<li><a class="reference internal" href="#error-and-warning-output">4.3.2.3. Error and warning output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solver-specific-libraries">4.3.3. Solver-specific Libraries</a><ul>
<li><a class="reference internal" href="#standard-predicates">4.3.3.1. Standard predicates</a></li>
<li><a class="reference internal" href="#solver-specific-predicates">4.3.3.2. Solver-specific predicates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#command-line-interface">4.3.4. Command Line Interface</a></li>
<li><a class="reference internal" href="#solver-configuration-files">4.3.5. Solver Configuration Files</a></li>
<li><a class="reference internal" href="#grammar">4.3.6. Grammar</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="lib-flatzinc.html" title="Previous Chapter: 4.2.6. FlatZinc builtins"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 4.2.6. FlatZi...</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="interfacing-solvers-to-flatzinc">
<span id="ch-fzn-interfacing"></span><h1>4.3. Interfacing Solvers to Flatzinc<a class="headerlink" href="#interfacing-solvers-to-flatzinc" title="Permalink to this headline">¶</a></h1>
<p>This document describes the interface between the MiniZinc system and FlatZinc solvers.</p>
<div class="section" id="specification-of-flatzinc">
<span id="ch-fzn-spec"></span><h2>4.3.1. Specification of FlatZinc<a class="headerlink" href="#specification-of-flatzinc" title="Permalink to this headline">¶</a></h2>
<p>This document is the specification of the FlatZinc modelling language.
It also includes a definition of the standard command line options a FlatZinc solver should support
in order to work with the <tt class="docutils literal">minizinc</tt> driver program (and the MiniZinc IDE).</p>
<p>FlatZinc is the target constraint modelling language into which MiniZinc
models are translated.
It is a very simple solver independent problem specification language,
requiring minimal implementation effort to support.</p>
<p>Throughout this document: <span class="math notranslate nohighlight">\(r_1\)</span>, <span class="math notranslate nohighlight">\(r_2\)</span> denote float literals; <span class="math notranslate nohighlight">\(x_1, x_2, \dots, x_k, i, j, k\)</span> denote int literals; <span class="math notranslate nohighlight">\(y_1, y_2, \dots, y_k, y_i\)</span> denote literal array elements.</p>
<div class="section" id="comments">
<h3>4.3.1.1. Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h3>
<p>Comments start with a percent sign <tt class="docutils literal">%</tt> and extend to the end of the line. Comments can appear anywhere in a model.</p>
</div>
<div class="section" id="types">
<h3>4.3.1.2. Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>There are three varieties of types in FlatZinc.</p>
<ul class="simple">
<li><em>Parameter</em> types apply to fixed values that are specified directly in the model.</li>
<li><em>Variable</em> types apply to values computed by the solver during search. Every parameter type has a corresponding variable type; the variable type being distinguished by a <tt class="docutils literal">var</tt> keyword.</li>
<li><em>Annotations</em> and <em>strings</em>: annotations can appear on variable declarations, constraints, and on the solve goal. They provide information about how a variable or constraint should be treated by the solver (e.g., whether a variable should be output as part of the result or whether a particular constraint should implemented using domain consistency). Strings may appear as arguments to annotations, but nowhere else.</li>
</ul>
<div class="section" id="parameter-types">
<h4>Parameter types<a class="headerlink" href="#parameter-types" title="Permalink to this headline">¶</a></h4>
<p>Parameters are fixed quantities explicitly specified in the model
(see rule <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;par-type&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal">bool</tt></td>
<td><tt class="docutils literal">true</tt> or <tt class="docutils literal">false</tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">float</tt></td>
<td>float</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">int</tt></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">set of int</tt></td>
<td>subset of int</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of bool</tt></td>
<td>array of bools</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of float</tt></td>
<td>array of floats</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of int</tt></td>
<td>array of ints</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of set of int</tt></td>
<td>array of sets of ints</td>
</tr>
</tbody>
</table>
<p>A parameter may be used where a variable is expected, but not vice versa.</p>
<p>In predicate declarations the following additional parameter types are allowed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math notranslate nohighlight">\(r_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(r_b\)</span></td>
<td>bounded float</td>
</tr>
<tr class="row-odd"><td><span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
<td>int in range</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">{</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
<td>int in set</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">set of</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
<td>subset of int range</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">set of</tt> <tt class="docutils literal">{</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
<td>subset of int set</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of</tt> <span class="math notranslate nohighlight">\(r_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(r_b\)</span></td>
<td>array of floats in range</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
<td>array of ints in range</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of set of</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
<td>array of sets of ints in range</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of set of</tt> <tt class="docutils literal">{</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
<td>array of subsets of set</td>
</tr>
</tbody>
</table>
<p>A range <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span> denotes a closed interval
<span class="math notranslate nohighlight">\(\{x | x_a \leq x \leq x_b\}\)</span> (same for float ranges).</p>
<p>An array type appearing in a predicate declaration may use just
<tt class="docutils literal">int</tt> instead of <tt class="docutils literal">1..</tt> <span class="math notranslate nohighlight">\(n\)</span> for the array index range
in cases where the array argument can be of any length.</p>
</div>
<div class="section" id="variable-types">
<h4>Variable types<a class="headerlink" href="#variable-types" title="Permalink to this headline">¶</a></h4>
<p>Variables are quantities decided by the solver
(see rules <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"></span></code> and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;array-var-type&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>).</p>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Variable type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal">var bool</tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">var float</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">var</tt> <span class="math notranslate nohighlight">\(r_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(r_b\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">var int</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">var</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">var</tt> <tt class="docutils literal">{</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">var set of</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">var set of {</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var bool</tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var float</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var</tt> <span class="math notranslate nohighlight">\(r_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(r_b\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var int</tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var set of</tt> <span class="math notranslate nohighlight">\(x_a\)</span> <tt class="docutils literal">..</tt> <span class="math notranslate nohighlight">\(x_b\)</span></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var set of {</tt> <span class="math notranslate nohighlight">\(x_a, x_b, \ldots, x_k\)</span> <tt class="docutils literal">}</tt></td>
</tr>
</tbody>
</table>
<p>In predicate declarations the following additional variable types are allowed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Variable type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal">var set of int</tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">array [1..</tt> <span class="math notranslate nohighlight">\(n\)</span> <tt class="docutils literal">] of var set of int</tt></td>
</tr>
</tbody>
</table>
<p>An array type appearing in a predicate declaration may use just
<tt class="docutils literal">int</tt> instead of <tt class="docutils literal">1..</tt> <span class="math notranslate nohighlight">\(n\)</span> for the array index range
in cases where the array argument can be of any length.</p>
</div>
<div class="section" id="the-string-type">
<h4>The string type<a class="headerlink" href="#the-string-type" title="Permalink to this headline">¶</a></h4>
<p>String literals and literal arrays of string literals can appear as
annotation arguments, but not elsewhere.
Strings have the same syntax as in C programs (namely, they are
delimited by double quotes and the backslash character is used for
escape sequences).</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;                              </span><span class="c">% The empty string.</span><span class="s"></span>
<span class="s">&quot;Hello.&quot;</span>
<span class="s">&quot;Hello,</span><span class="se">\n</span><span class="s">World</span><span class="se">\t\&quot;</span><span class="s">quoted!</span><span class="se">\&quot;</span><span class="s">&quot;    </span><span class="c">% A string with an embedded newline, tab and quotes.</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="values-and-expressions">
<h3>4.3.1.3. Values and expressions<a class="headerlink" href="#values-and-expressions" title="Permalink to this headline">¶</a></h3>
<p>(See rule <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;expr&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>Examples of literal values:</p>
<p>Type Literals
<tt class="docutils literal">bool</tt> <tt class="docutils literal">true</tt>, <tt class="docutils literal">false</tt>
<tt class="docutils literal">float</tt> <tt class="docutils literal">2.718</tt>, <tt class="docutils literal">-1.0</tt>, <tt class="docutils literal">3.0e8</tt>
<tt class="docutils literal">int</tt> <tt class="docutils literal">-42</tt>, <tt class="docutils literal">0</tt>, <tt class="docutils literal">69</tt>
<tt class="docutils literal">set of int</tt> <tt class="docutils literal">{}</tt>, <tt class="docutils literal">{2, 3, 5}</tt>, <tt class="docutils literal">1..10</tt>
<tt class="docutils literal">arrays</tt> <tt class="docutils literal">[]</tt>, <tt class="docutils literal">[</tt> <span class="math notranslate nohighlight">\(y_a, \ldots, y_k\)</span> <tt class="docutils literal">]</tt></p>
<p>where each array element <span class="math notranslate nohighlight">\(y_i\)</span> is either: a non-array literal, or the
name of a non-array parameter or variable, <tt class="docutils literal">v</tt>. For example:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]</span><span class="s">             </span><span class="c">% Just literals</span><span class="s"></span>
<span class="p">[</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">z</span><span class="p">]</span><span class="s">             </span><span class="c">% x, y, and z are variables or parameters.</span><span class="s"></span>
<span class="p">[</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]</span><span class="s">                </span><span class="c">% Mix of identifiers and literals</span><span class="s"></span>
</pre></div>
</div>
<p><a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a> gives the regular expressions specifying the
syntax for float and int literals.</p>
</div>
<div class="section" id="flatzinc-models">
<h3>4.3.1.4. FlatZinc models<a class="headerlink" href="#flatzinc-models" title="Permalink to this headline">¶</a></h3>
<p>A FlatZinc model consists of:</p>
<ol class="arabic simple">
<li>zero or more external predicate declarations (i.e., a non-standard predicate that is supported directly by the target solver);</li>
<li>zero or more parameter declarations;</li>
<li>zero or more variable declarations;</li>
<li>zero or more constraints;</li>
<li>a solve goal</li>
</ol>
<p>in that order.</p>
<p>FlatZinc uses the UTF-8 character set. Non-ASCII characters can only appear in string literals.</p>
<p>FlatZinc syntax is case sensitive (<tt class="docutils literal">foo</tt> and <tt class="docutils literal">Foo</tt> are different
names).
Identifiers start with a letter (<tt class="docutils literal">[A-Za-z]</tt>) and are followed by
any sequence of letters, digits, or underscores (<tt class="docutils literal">[A-Za-z0-9_]</tt>).
Additionally, identifiers of variable or parameter names may start with an underscore.
Identifiers that correspond to the names of predicates, predicate parameters
and annotations cannot have leading underscores.</p>
<p>The following keywords are reserved and cannot be used as identifiers:
<tt class="docutils literal">annotation</tt>,
<tt class="docutils literal">any</tt>,
<tt class="docutils literal">array</tt>,
<tt class="docutils literal">bool</tt>,
<tt class="docutils literal">case</tt>,
<tt class="docutils literal">constraint</tt>,
<tt class="docutils literal">diff</tt>,
<tt class="docutils literal">div</tt>,
<tt class="docutils literal">else</tt>,
<tt class="docutils literal">elseif</tt>,
<tt class="docutils literal">endif</tt>,
<tt class="docutils literal">enum</tt>,
<tt class="docutils literal">false</tt>,
<tt class="docutils literal">float</tt>,
<tt class="docutils literal">function</tt>,
<tt class="docutils literal">if</tt>,
<tt class="docutils literal">in</tt>,
<tt class="docutils literal">include</tt>,
<tt class="docutils literal">int</tt>,
<tt class="docutils literal">intersect</tt>,
<tt class="docutils literal">let</tt>,
<tt class="docutils literal">list</tt>,
<tt class="docutils literal">maximize</tt>,
<tt class="docutils literal">minimize</tt>,
<tt class="docutils literal">mod</tt>,
<tt class="docutils literal">not</tt>,
<tt class="docutils literal">of</tt>,
<tt class="docutils literal">satisfy</tt>,
<tt class="docutils literal">subset</tt>,
<tt class="docutils literal">superset</tt>,
<tt class="docutils literal">output</tt>,
<tt class="docutils literal">par</tt>,
<tt class="docutils literal">predicate</tt>,
<tt class="docutils literal">record</tt>,
<tt class="docutils literal">set</tt>,
<tt class="docutils literal">solve</tt>,
<tt class="docutils literal">string</tt>,
<tt class="docutils literal">symdiff</tt>,
<tt class="docutils literal">test</tt>,
<tt class="docutils literal">then</tt>,
<tt class="docutils literal">true</tt>,
<tt class="docutils literal">tuple</tt>,
<tt class="docutils literal">union</tt>,
<tt class="docutils literal">type</tt>,
<tt class="docutils literal">var</tt>,
<tt class="docutils literal">where</tt>,
<tt class="docutils literal">xor</tt>.
Note that some of these keywords are not used in FlatZinc.
They are reserved because they are keywords in Zinc and MiniZinc.</p>
<p>FlatZinc syntax is insensitive to whitespace.</p>
</div>
<div class="section" id="predicate-declarations">
<h3>4.3.1.5. Predicate declarations<a class="headerlink" href="#predicate-declarations" title="Permalink to this headline">¶</a></h3>
<p>(See rule <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;predicate-item&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>Predicates used in the model that are not standard FlatZinc must be
declared at the top of a FlatZinc model, before any other lexical items.
Predicate declarations take the form</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;predicate-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;predicate&quot; </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;pred-param-type&gt;</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;)&quot; &quot;;&quot;</span>
</pre></div>
</div>
<p>Annotations are not permitted anywhere in predicate declarations.</p>
<p>It is illegal to supply more than one predicate declaration for a given
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;identifier&gt;</span><span class="s"></span></code>.</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="s">    </span><span class="c">% m is the median value of {x, y, z}.</span><span class="s"></span>
<span class="s">    </span><span class="c">%</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">median_of_3</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">);</span><span class="s"></span>

<span class="s">    </span><span class="c">% all_different([x1, .., xn]) iff</span><span class="s"></span>
<span class="s">    </span><span class="c">% for all i, j in 1..n: xi != xj.</span><span class="s"></span>
<span class="s">    </span><span class="c">%</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">xs</span><span class="p">);</span><span class="s"></span>

<span class="s">    </span><span class="c">% exactly_one([x1, .., xn]) iff</span><span class="s"></span>
<span class="s">    </span><span class="c">% there exists an i in 1..n: xi = true</span><span class="s"></span>
<span class="s">    </span><span class="c">% and for all j in 1..n: j != i -&gt; xj = false.</span><span class="s"></span>
<span class="s">    </span><span class="c">%</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">exactly_one</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">xs</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-declarations">
<h3>4.3.1.6. Parameter declarations<a class="headerlink" href="#parameter-declarations" title="Permalink to this headline">¶</a></h3>
<p>(See rule <tt class="docutils literal">param_decl</tt> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>Parameters have fixed values and must be assigned values:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;par-decl-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;par-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;par-expr&gt;</span><span class="s"> &quot;;&quot;</span>
</pre></div>
</div>
<p>where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;par-type&gt;</span><span class="s"></span></code> is a parameter type, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"></span></code> is an identifier,
and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;par-expr&gt;</span><span class="s"></span></code> is a literal value (either a basic integer, float or bool literal, or a set or array of such literals).</p>
<p>Annotations are not permitted anywhere in parameter declarations.</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">pi</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3.141</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">fib</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">13</span><span class="p">];</span><span class="s"></span>
<span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">beer_is_good</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="l">true</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="variable-declarations">
<h3>4.3.1.7. Variable declarations<a class="headerlink" href="#variable-declarations" title="Permalink to this headline">¶</a></h3>
<p>(See rule <tt class="docutils literal">var_decl</tt> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>Variables have variable types and can be declared with optional assignments.
The assignment can fix a variable to a literal value, or create an alias to another
variable. Arrays of variables always have an assignment, defining them in terms of an array literal
that can contain identifiers of variables or constant literals.
Variables may be declared with zero or more annotations.</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;var-decl-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="cs">&lt;annotations&gt;</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"> &quot;;&quot;</span>
<span class="cs">                  |</span><span class="s"> </span><span class="cs">&lt;array-var-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;array-literal&gt;</span><span class="s"> &quot;;&quot;</span>
<span class="s">                  </span>
</pre></div>
</div>
<p>where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"></span></code> and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;array-var-type&gt;</span><span class="s"></span></code> are variable types, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"></span></code> is an identifier,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;annotations&gt;</span><span class="s"></span></code> is a (possibly empty) set of annotations, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;basic-expr&gt;</span><span class="s"></span></code> is an identifier or a literal, and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;array-literal&gt;</span><span class="s"></span></code> is a literal array
value.</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">digit</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0.0</span><span class="o">..</span><span class="m">1.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">mip</span><span class="p">;</span><span class="s">        </span><span class="c">% &#39;mip&#39; annotation: y should be a MIP variable.</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="nv">digit</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="constraints">
<h3>4.3.1.8. Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>(See rule <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;constraint-item&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>Constraints take the following form and may include zero or more annotations:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;constraint-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;constraint&quot; </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;)&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;;&quot;</span>
</pre></div>
</div>
<p>The arguments expressions (<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;expr&gt;</span><span class="s"></span></code>) can be literal values or identifiers.</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">int_le</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s">    </span><span class="c">% 0 &lt;= x</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lt</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">y</span><span class="p">);</span><span class="s">    </span><span class="c">% x &lt;  y</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_le</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="m">10</span><span class="p">);</span><span class="s">   </span><span class="c">% y &lt;= 10</span><span class="s"></span>
<span class="s">    </span><span class="c">% &#39;domain&#39;: use domain consistency for this constraint:</span><span class="s"></span>
<span class="s">    </span><span class="c">% 2x + 3y = 10</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">y</span><span class="p">],</span><span class="s"> </span><span class="m">10</span><span class="p">)</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">domain</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="solve-item">
<h3>4.3.1.9. Solve item<a class="headerlink" href="#solve-item" title="Permalink to this headline">¶</a></h3>
<p>(See rule <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;solve-item&gt;</span><span class="s"></span></code> in <a class="reference internal" href="#ch-fzn-syntax"><span class="std std-numref">Section 4.3.6</span></a>)</p>
<p>A model finishes with a solve item, taking one of the following forms:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;solve-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;satisfy&quot; &quot;;&quot;</span>
<span class="cs">               |</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;minimize&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> &quot;;&quot;</span>
<span class="cs">               |</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;maximize&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> &quot;;&quot;</span>
</pre></div>
</div>
<p>The first alternative searches for any satisfying assignment, the second one searches for an assignment minimizing the given expression, and the third one for an assignment maximizing the expression. The <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;basic-expr&gt;</span><span class="s"></span></code> can be either a variable identifier or a literal value (if the objective function is constant).</p>
<p>A solution consists of a complete assignment where all variables in the
model have been given a fixed value.</p>
<p>Examples:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s">      </span><span class="c">% Find any solution using the default strategy.</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">minimize</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s">   </span><span class="c">% Find a solution minimizing w, using the default strategy.</span><span class="s"></span>

<span class="s">    </span><span class="c">% First label the variables in xs in the order x[1], x[2], ...</span><span class="s"></span>
<span class="s">    </span><span class="c">% trying values in ascending order.</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">(</span><span class="nv">xs</span><span class="p">,</span><span class="s"> </span><span class="nv">input_order</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_min</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="k">satisfy</span><span class="p">;</span><span class="s">    </span><span class="c">% Find any solution.</span><span class="s"></span>

<span class="s">    </span><span class="c">% First use first-fail on these variables, splitting domains</span><span class="s"></span>
<span class="s">    </span><span class="c">% at each choice point.</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">int_search</span><span class="p">([</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">z</span><span class="p">],</span><span class="s"> </span><span class="nv">first_fail</span><span class="p">,</span><span class="s"> </span><span class="nv">indomain_split</span><span class="p">,</span><span class="s"> </span><span class="nv">complete</span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="k">maximize</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"> </span><span class="c">% Find a solution maximizing x.</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="annotations">
<h3>4.3.1.10. Annotations<a class="headerlink" href="#annotations" title="Permalink to this headline">¶</a></h3>
<p>Annotations are optional suggestions to the solver concerning how
individual variables and constraints should be handled (e.g., a
particular solver may have multiple representations for int variables)
and how search should proceed.
An implementation is free to ignore any annotations it does not
recognise, although it should print a warning on the standard error
stream if it does so.
Annotations are unordered and idempotent: annotations can be reordered
and duplicates can be removed without changing the meaning of the
annotations.</p>
<p>An annotation is prefixed by <tt class="docutils literal">::</tt>, and either just an identifier or an expression that looks like a predicate call:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;annotations&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;::&quot; </span><span class="cs">&lt;annotation&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>

<span class="cs">&lt;annotation&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"></span>
<span class="cs">               |</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="cs">&lt;ann-expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. &quot;)&quot;</span>

<span class="cs">&lt;ann-expr&gt;</span><span class="s">   </span><span class="p">:</span><span class="o">=</span><span class="s"> </span><span class="cs">&lt;expr&gt;</span><span class="s"></span>
<span class="cs">              |</span><span class="s"> </span><span class="cs">&lt;annotation&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>The arguments of the second alternative can be any expression or other annotations (without the leading <tt class="docutils literal">::</tt>).</p>
<p>While an implementation is free to ignore any or all annotations in a
model, it is recommended that implementations at least recognise the
following standard annotations for solve items.</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="nf">seq_search</span><span class="p">(</span><span class="sr">[&lt;searchannotation&gt;, ...]</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>allows more than one search annotation to be specified in a particular
order (otherwise annotations can be handled in any order).</p>
<p>A <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;searchannotation&gt;</span><span class="s"></span></code> is one of the following:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="nf">int_search</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoiceannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;assignmentannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;strategyannotation&gt;</span><span class="p">)</span><span class="s"></span>

<span class="nf">bool_search</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoiceannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;assignmentannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;strategyannotation&gt;</span><span class="p">)</span><span class="s"></span>

<span class="nf">set_search</span><span class="p">(</span><span class="cs">&lt;vars&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;varchoiceannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;assignmentannotation&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;strategyannotation&gt;</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;vars&gt;</span><span class="s"></span></code> is the identifier of an array variable or an array literal specifying
the variables to be assigned (ints, bools, or sets respectively). Note that these arrays may contain literal values.</p>
<p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;varchoiceannotation&gt;</span><span class="s"></span></code> specifies how the next variable to be assigned is
chosen at each choice point.
Possible choices are as follows (it is recommended that implementations
support the starred options):</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="11%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal">input_order</tt></td>
<td><span class="math notranslate nohighlight">\(\star\)</span></td>
<td>Choose variables in the order they appear in <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nv">vars</span><span class="s"></span></code>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">first_fail</tt></td>
<td><span class="math notranslate nohighlight">\(\star\)</span></td>
<td>Choose the variable with the smallest domain.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">anti_first_fail</tt></td>
<td>&#160;</td>
<td>Choose the variable with the largest domain.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">smallest</tt></td>
<td>&#160;</td>
<td>Choose the variable with the smallest value in its domain.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">largest</tt></td>
<td>&#160;</td>
<td>Choose the variable with the largest value in its domain.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">occurrence</tt></td>
<td>&#160;</td>
<td>Choose the variable with the largest number of attached constraints.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">most_constrained</tt></td>
<td>&#160;</td>
<td>Choose the variable with the smallest domain, breaking ties using the number of constraints.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">max_regret</tt></td>
<td>&#160;</td>
<td>Choose the variable with the largest difference between the two smallest values in its domain.</td>
</tr>
</tbody>
</table>
<p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;assignmentannotation&gt;</span><span class="s"></span></code> specifies how the chosen variable should be
constrained.
Possible choices are as follows (it is recommended that implementations
support the starred options):</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="10%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal">indomain_min</tt></td>
<td><span class="math notranslate nohighlight">\(\star\)</span></td>
<td>Assign the smallest value in the variable’s domain.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">indomain_max</tt></td>
<td><span class="math notranslate nohighlight">\(\star\)</span></td>
<td>Assign the largest value in the variable’s domain.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">indomain_middle</tt></td>
<td>&#160;</td>
<td>Assign the value in the variable’s domain closest to the mean of its current bounds.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">indomain_median</tt></td>
<td>&#160;</td>
<td>Assign the middle value in the variable’s domain.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">indomain</tt></td>
<td>&#160;</td>
<td>Nondeterministically assign values to the variable in ascending order.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">indomain_random</tt></td>
<td>&#160;</td>
<td>Assign a random value from the variable’s domain.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">indomain_split</tt></td>
<td>&#160;</td>
<td>Bisect the variable’s domain, excluding the upper half first.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">indomain_reverse_split</tt></td>
<td>&#160;</td>
<td>Bisect the variable’s domain, excluding the lower half first.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">indomain_interval</tt></td>
<td>&#160;</td>
<td>If the variable’s domain consists of several contiguous intervals,
reduce the domain to the first interval. Otherwise just split the variable’s domain.</td>
</tr>
</tbody>
</table>
<p>Of course, not all assignment strategies make sense for all search
annotations (e.g., <tt class="docutils literal">bool_search</tt> and <tt class="docutils literal">indomain_split</tt>).</p>
<p>Finally, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;strategyannotation&gt;</span><span class="s"></span></code> specifies a search strategy;
implementations should at least support <tt class="docutils literal">complete</tt> (i.e., exhaustive
search).</p>
<p>Model output is specified through variable annotations.
Non-array output variables are annotated with
<tt class="docutils literal">output_var</tt>.
Array output variables are annotated with
<tt class="docutils literal">output_array([</tt><span class="math notranslate nohighlight">\(x_1\\)</span>..`` <span class="math notranslate nohighlight">\(x_2\)</span> <tt class="docutils literal">, ... ])</tt>
where <span class="math notranslate nohighlight">\(x_1\\)</span>..`` <span class="math notranslate nohighlight">\(x_2\)</span> <tt class="docutils literal">, ...</tt> are the index set ranges of the
original MiniZinc array (which
may have had multiple dimensions and/or index sets that do not start at
1). See <a class="reference internal" href="#ch-fzn-output"><span class="std std-numref">Section 4.3.2</span></a> for details on the output format.</p>
<p>To support solvers capable of exploiting functional relationships, a
variable defined as a function of other variables may be annotated thus:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">is_defined_var</span><span class="p">;</span><span class="s"></span>

<span class="o">..</span><span class="s">.</span>

<span class="k">constraint</span><span class="s"> </span><span class="nf">int_plus</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">z</span><span class="p">,</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">defines_var</span><span class="p">(</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>(The <tt class="docutils literal">defines_var</tt> annotation should appear on exactly one
constraint.)
This allows a solver to represent <tt class="docutils literal">x</tt> internally as a representation
of <tt class="docutils literal">y+z</tt> rather than as a separate constrained variable.
The <tt class="docutils literal">is_defined_var</tt> annotation on the declaration of <tt class="docutils literal">x</tt>
provides “early warning” to the solver that such an option is
available.</p>
<p>Intermediate variables introduced during conversion of a MiniZinc
model to FlatZinc may be annotated thus:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">X_INTRODUCED_3</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">var_is_introduced</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>This information is potentially useful to the solver’s search strategy.</p>
<p>Annotations can be placed on constraints advising the solver how the
constraint should be implemented.
Here are some constraint annotations supported by some solvers:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal">bounds</tt> or <tt class="docutils literal">boundsZ</tt></td>
<td>Use integer bounds propagation.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">boundsR</tt></td>
<td>Use real bounds propagation.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">boundsD</tt></td>
<td>A tighter version of <tt class="docutils literal">boundsZ</tt> where support for the bounds must exist.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">domain</tt></td>
<td>Use domain propagation.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">priority(k)</tt></td>
<td>where <tt class="docutils literal">k</tt> is an integer constant indicating propagator priority.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="output">
<span id="ch-fzn-output"></span><h2>4.3.2. Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>An implementation can produce three types of output: solutions, statistics, and errors.</p>
<div class="section" id="solution-output">
<h3>4.3.2.1. Solution output<a class="headerlink" href="#solution-output" title="Permalink to this headline">¶</a></h3>
<p>An implementation must output values for all and only the variables
annotated with <tt class="docutils literal">output_var</tt> or <tt class="docutils literal">output_array</tt> (output
annotations must not appear on parameters). Output must be printed to
the standard output stream.</p>
<p>For example:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s">       </span><span class="c">% y is not output.</span><span class="s"></span>
<span class="s">    </span><span class="c">% Output zs as a &quot;flat&quot; representation of a 2D array:</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">zs</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">output_array</span><span class="p">([</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>All non-error output must be sent to the standard output stream.</p>
<p>Output must take the following form:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="cs">&lt;basic-literal-expr&gt;</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>or, for array variables,</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="kt">array</span><span class="cs">&lt;N&gt;</span><span class="nf">d</span><span class="p">(</span><span class="cs">&lt;a&gt;</span><span class="o">..</span><span class="cs">&lt;b&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="sr">[&lt;y1&gt;, &lt;y2&gt;, ... &lt;yk&gt;]</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>where <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;N&gt;</span><span class="s"></span></code> is the number of index sets specified in the
corresponding <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nv">output_array</span><span class="s"></span></code> annotation,
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;a&gt;</span><span class="o">..</span><span class="cs">&lt;b&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span></code> are the index set ranges,
and <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;y1&gt;</span><span class="p">,</span><span class="s"> </span><span class="cs">&lt;y2&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">. </span><span class="cs">&lt;yk&gt;</span><span class="s"></span></code> are literals of the element type.</p>
<p>Using this format, the output of a FlatZinc model solution is
suitable for input to a MiniZinc model as a data file (this is why
parameters are not included in the output).</p>
<p>Implementations must ensure that <em>all</em> model variables (not
just the output variables) have satisfying assignments before printing a
solution.</p>
<p>The output for a solution must be terminated with ten consecutive
minus signs on a separate line: <tt class="docutils literal">----------</tt>.</p>
<p>Multiple solutions may be output, one after the other, as search
proceeds. How many solutions should be output depends on the mode the solver is run in as controlled by the <tt class="docutils literal">-a</tt> command line flag (see <a class="reference internal" href="#fzn-cmdline-options"><span class="std std-numref">Section 4.3.4</span></a>).</p>
<p>If at least one solution has been found and search then terminates
having explored the whole search space, then ten
consecutive equals signs should be printed on a separate line:
<tt class="docutils literal">==========</tt>.</p>
<p>If no solutions have been found and search terminates having explored
the whole search space, then <tt class="docutils literal">=====UNSATISFIABLE=====</tt> should be
printed on a separate line.</p>
<p>If the objective of an optimization problem is unbounded, then
<tt class="docutils literal">=====UNBOUNDED=====</tt> should be printed on a separate line.</p>
<p>If no solutions have been found and search terminates having
<em>not</em> explored the whole search space, then
<tt class="docutils literal">=====UNKNOWN=====</tt> should be printed on a separate line.</p>
<p>Implementations may output further information about the solution(s),
or lack thereof, in the form of FlatZinc comments.</p>
<p>Examples:</p>
<p>Asking for a single solution to this model:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="s"></span>
</pre></div>
</div>
<p>might produce this output:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
</pre></div>
</div>
<p>Asking for all solutions to this model:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">xs</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nf">output_array</span><span class="p">([</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lt</span><span class="p">(</span><span class="nv">xs</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">xs</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span><span class="s">    </span><span class="c">% x[1] &lt; x[2].</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="s"></span>
</pre></div>
</div>
<p>might produce this output:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">xs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">]);</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="nv">xs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]);</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="nv">xs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">array1d</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]);</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="o">==========</span><span class="s"></span>
</pre></div>
</div>
<p>Asking for a single solution to this model:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>should produce this output:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">10</span><span class="p">;</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="o">==========</span><span class="s"></span>
</pre></div>
</div>
<p>The row of equals signs indicates that a complete search was performed
and that the last result printed is the optimal solution.</p>
<p>Running a solver on this model with some termination condition (such as a very short time-out):</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>might produce this output:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
<span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="p">;</span><span class="s"></span>
<span class="o">----------</span><span class="s"></span>
</pre></div>
</div>
<p>Because the output does not finish with <tt class="docutils literal">==========</tt>, search did not
finish, hence these results must be interpreted as approximate solutions
to the optimization problem.</p>
<p>Asking for a solution to this model:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">4</span><span class="o">..</span><span class="m">6</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">::</span><span class="s"> </span><span class="nv">output_var</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lt</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s">    </span><span class="c">% y &lt; x.</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>should produce this output:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="o">=====</span><span class="nv">UNSATISFIABLE</span><span class="o">=====</span><span class="s"></span>
</pre></div>
</div>
<p>indicating that a complete search was performed and no solutions were
found (i.e., the problem is unsatisfiable).</p>
</div>
<div class="section" id="statistics-output">
<h3>4.3.2.2. Statistics output<a class="headerlink" href="#statistics-output" title="Permalink to this headline">¶</a></h3>
<p>FlatZinc solvers can output statistics in a standard format so that it can be read by scripts, for example, in order to run experiments and automatically aggregate the results. Statistics should be printed to the standard output stream in the form of FlatZinc comments that follow a specific format. Statistics can be output at any time during the solving, i.e., before the first solution, between solutions, and after the search has finished.</p>
<p>Each value should be output on a line of its own in the following format:</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="c">%%%mzn-stat: &lt;name&gt;=&lt;value&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>The <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;name&gt;</span><span class="s"></span></code> describes the kind of statistics gathered, and the <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;value&gt;</span><span class="s"></span></code> can be any value of a MiniZinc type. The following names are considered standard statistics:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="8%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Explanation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal">nodes</tt></td>
<td>int</td>
<td>Number of search nodes</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">failures</tt></td>
<td>int</td>
<td>Number of leaf nodes that were failed</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">restarts</tt></td>
<td>int</td>
<td>Number of times the solver restarted the search</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">variables</tt></td>
<td>int</td>
<td>Number of variables</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">intVariables</tt></td>
<td>int</td>
<td>Number of integer variables created</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">boolVariables</tt></td>
<td>int</td>
<td>Number of bool variables created</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">floatVariables</tt></td>
<td>int</td>
<td>Number of float variables created</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">setVariables</tt></td>
<td>int</td>
<td>Number of set variables created</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">propagators</tt></td>
<td>int</td>
<td>Number of propagators created</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">propagations</tt></td>
<td>int</td>
<td>Number of propagator invocations</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">peakDepth</tt></td>
<td>int</td>
<td>Peak depth of search tree</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">nogoods</tt></td>
<td>int</td>
<td>Number of nogoods created</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">backjumps</tt></td>
<td>int</td>
<td>Number of backjumps</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">peakMem</tt></td>
<td>float</td>
<td>Peak memory (in Mbytes)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal">initTime</tt></td>
<td>float</td>
<td>Initialisation time (in seconds)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal">solveTime</tt></td>
<td>float</td>
<td>Solving time (in seconds)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="error-and-warning-output">
<h3>4.3.2.3. Error and warning output<a class="headerlink" href="#error-and-warning-output" title="Permalink to this headline">¶</a></h3>
<p>Errors and warnings must be output to the standard error stream. When an error occurs, the implementation should exit with a non-zero exit code, signaling failure.</p>
</div>
</div>
<div class="section" id="solver-specific-libraries">
<h2>4.3.3. Solver-specific Libraries<a class="headerlink" href="#solver-specific-libraries" title="Permalink to this headline">¶</a></h2>
<p>Constraints in FlatZinc can call standard predicates as well as solver-specific predicates. Standard predicates are the ones that the MiniZinc compiler assumes to be present in all solvers. Without further customisation, the compiler will try to compile the entire model into a set of these standard predicates.</p>
<p>Solvers can use custom predicates and <em>redefine</em> standard predicates by supplying a <em>solver specific library</em> of predicate declarations. Examples of such libraries can be found in the binary distribution of MiniZinc, inside the <tt class="docutils literal">share/minizinc/gecode</tt> and <tt class="docutils literal">share/minizinc/chuffed</tt> directories.</p>
<p>The solver-specific library needs to be made available to the MiniZinc compiler by specifying its location in the solver’s configuration file, see <a class="reference internal" href="#sec-cmdline-conffiles"><span class="std std-numref">Section 4.3.5</span></a>.</p>
<div class="section" id="standard-predicates">
<h3>4.3.3.1. Standard predicates<a class="headerlink" href="#standard-predicates" title="Permalink to this headline">¶</a></h3>
<p>FlatZinc solvers need to support the predicates listed as <tt class="docutils literal">FlatZinc builtins</tt> in the library reference documentation, see <a class="reference internal" href="lib-flatzinc.html#ch-lib-flatzinc"><span class="std std-numref">Section 4.2.6</span></a>.</p>
<p>Any standard predicate that is not supported by a solver needs to be <em>redefined</em>. This can be achieved by placing a file called <tt class="docutils literal">redefinitions.mzn</tt> in the solver’s MiniZinc library, which can contain alternative definitions of predicates, or define them as unsupported using the <tt class="docutils literal">abort</tt> predicate.</p>
<p>Example for a <tt class="docutils literal">redefinitions.mzn</tt>:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% Redefine float_sinh function in terms of exp</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">float_sinh</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">a</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="nv">b</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="p">(</span><span class="nb">exp</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span><span class="o">-</span><span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="nv">a</span><span class="p">))</span><span class="o">/</span><span class="m">2.0</span><span class="p">;</span><span class="s"></span>

<span class="c">% Mark float_tanh as unsupported</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">float_tanh</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">a</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="nb">abort</span><span class="p">(</span><span class="s">&quot;The builtin float_tanh is not supported by this solver.&quot;</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>The redefinition can use the full MiniZinc language. Note, however, that redefining builtin predicates in terms of MiniZinc expressions can lead to problems if the MiniZinc compiler translates the high-level expression back to the redefined builtin.</p>
<p>The reference documentation (<a class="reference internal" href="lib-flatzinc.html#ch-lib-flatzinc"><span class="std std-numref">Section 4.2.6</span></a>) also contains sections on builtins that were added in later versions of MiniZinc. In order to maintain backwards compatibility with solvers that don’t support these, they are organised in redefinition files with a version number attached, such as <tt class="docutils literal">redefinitions-2.0.mzn</tt>. In order to declare support for these builtins, the solver-specific library must contain the corresponding redefinitions file, with the predicates either redefined in terms of other predicates, or declared as supported natively by the solver by providing a predicate declaration without a body.</p>
<p>Example for a <tt class="docutils literal">redefinitions-2.0.mzn</tt> that declares native support for the predicates added in MiniZinc 2.0:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bool_clause_reif</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">as</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">bs</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">array_int_maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">array_float_maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">array_int_minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">array_float_minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="solver-specific-predicates">
<h3>4.3.3.2. Solver-specific predicates<a class="headerlink" href="#solver-specific-predicates" title="Permalink to this headline">¶</a></h3>
<p>Many solvers have built-in support for some of the constraints in the MiniZinc standard library. But without declaring which constraints they support, MiniZinc will assume that they don’t support any excpect for the standard FlatZinc builtins mentioned in the section above.</p>
<p>A solver can declare that it supports a non-standard constraint by overriding one of the files of the standard library in its own solver-specific library. For example, assume that a solver supports the <tt class="docutils literal">all_different</tt> constraint on integer variables. In the standard library, this constraint is defined in the file <tt class="docutils literal">all_different_int.mzn</tt>, with the following implementation:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">all_different_int</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">  </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>A solver, let’s call it <em>OptiSolve</em>, that supports this constraint natively can place a file with the same name, <tt class="docutils literal">all_different_int.mzn</tt>, in its library, and redefine it as follows:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">precicate</span><span class="s"> </span><span class="nf">optisolve_alldifferent</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>

<span class="k">predicate</span><span class="s"> </span><span class="nf">all_different_int</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">  </span><span class="nf">optisolve_alldifferent</span><span class="p">(</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>When a MiniZinc model that contains the <tt class="docutils literal">all_different</tt> constraint is now compiled with the <em>OptiSolve</em> library, it will contain calls to the newly defined predicate <tt class="docutils literal">optisolve_alldifferent</tt>.</p>
</div>
</div>
<div class="section" id="command-line-interface">
<span id="fzn-cmdline-options"></span><h2>4.3.4. Command Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>In order to work with the <tt class="docutils literal">minizinc</tt> command line driver, a FlatZinc solver must be an executable (which can include e.g. shell scripts) that can be invoked as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ &lt;executable-name&gt; <span class="o">[</span>options<span class="o">]</span> model.fzn
</pre></div>
</div>
<p>where <tt class="docutils literal"><executable-name></tt> is the name of the executable. Solvers may support the following standard options:</p>
<dl class="option">
<dt id="cmdoption-a">
<code class="descname">-a</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-a" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the solver to report <em>all</em> solutions in the case of satisfaction
problems, or print <em>intermediate</em> solutions of increasing quality in the case
of optimisation problems.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-n">
<code class="descname">-n</code><code class="descclassname"> &lt;i&gt;</code><a class="headerlink" href="#cmdoption-n" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the solver to stop after reporting <tt class="docutils literal">i</tt> solutions (only used with
satisfaction problems).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-f">
<code class="descname">-f</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-f" title="Permalink to this definition">¶</a></dt>
<dd><p>Instructs the solver to conduct a “free search”, i.e., ignore any search
annotations. The solver is not <em>required</em> to ignore the annotations, but it
is <em>allowed</em> to do so.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-s">
<code class="descname">-s</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-s" title="Permalink to this definition">¶</a></dt>
<dd><p>Print statistics during and/or after the search for solutions. Statistics
should be printed as FlatZinc comments to the standard output stream.
See below for a standard format for statistics.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-p">
<code class="descname">-p</code><code class="descclassname"> &lt;i&gt;</code><a class="headerlink" href="#cmdoption-p" title="Permalink to this definition">¶</a></dt>
<dd><p>Run with <tt class="docutils literal">i</tt> parallel threads (for multi-threded solvers).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-r">
<code class="descname">-r</code><code class="descclassname"> &lt;i&gt;</code><a class="headerlink" href="#cmdoption-r" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <tt class="docutils literal">i</tt> as the random seed (for any random number generators the solver
may be using).</p>
</dd></dl>

</div>
<div class="section" id="solver-configuration-files">
<span id="sec-cmdline-conffiles"></span><h2>4.3.5. Solver Configuration Files<a class="headerlink" href="#solver-configuration-files" title="Permalink to this headline">¶</a></h2>
<p>In order for a solver to be available to MiniZinc, it has to be described in a <em>solver configuration file</em>. This is a simple file, in JSON or <tt class="docutils literal">.dzn</tt> format, that contains some basic information such as the solver’s name, version, where its library of global constraints can be found, and a path to its executable.</p>
<p>A solver configuration file must have file extension <tt class="docutils literal">.msc</tt> (for MiniZinc Solver Configuration), and can be placed in any of the following locations:</p>
<ul class="simple">
<li>In the <tt class="docutils literal">minizinc/solvers/</tt> directory of the MiniZinc installation. If you install MiniZinc from the binary distribution, this directory can be found at <tt class="docutils literal">/usr/share/minizinc/solvers</tt> on Linux systems, inside the MiniZincIDE application on macOS system, and in the <tt class="docutils literal">Program Files\\MiniZinc IDE (bundled)</tt> folder on Windows.</li>
<li>In the directory <tt class="docutils literal">$HOME/.minizinc/solvers</tt> on Linux and macOS systems, and the Application Data directory on Windows systems.</li>
<li>In any directory listed on the <tt class="docutils literal">MZN_SOLVER_PATH</tt> environment variable (directories are separated by <tt class="docutils literal">:</tt> on Linux and macOS, and by <tt class="docutils literal">;</tt> on Windows systems).</li>
<li>In any directory listed in the <tt class="docutils literal">mzn_solver_path</tt> option of the global or user-specific configuration file (see <a class="reference internal" href="command_line.html#ch-user-config"><span class="std std-numref">Section 3.1.4</span></a>)</li>
<li>Alternatively, you can use the MiniZinc IDE to create solver configuration files, see <a class="reference internal" href="minizinc_ide.html#sec-ide-add-solvers"><span class="std std-numref">Section 3.2.7</span></a> for details.</li>
</ul>
<p>Solver configuration files must be valid JSON or <tt class="docutils literal">.dzn</tt> files. As a JSON file, it must be an object with certain fields. As a <tt class="docutils literal">.dzn</tt> file, it must consist of assignment items.</p>
<p>For example, a simple solver configuration in JSON format could look like this:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span> <span class="p">:</span> <span class="s2">&quot;My Solver&quot;</span><span class="p">,</span>
  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
  <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;org.myorg.my_solver&quot;</span><span class="p">,</span>
  <span class="nt">&quot;executable&quot;</span><span class="p">:</span> <span class="s2">&quot;fzn-mysolver&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same configuration in <tt class="docutils literal">.dzn</tt> format would look like this:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">name</span><span class="s"> </span><span class="o">=</span><span class="s"> &quot;My Solver&quot;</span><span class="p">;</span><span class="s"></span>
<span class="nv">version</span><span class="s"> </span><span class="o">=</span><span class="s"> &quot;1.0&quot;</span><span class="p">;</span><span class="s"></span>
<span class="nv">id</span><span class="s"> </span><span class="o">=</span><span class="s"> &quot;org.myorg.my_solver&quot;</span><span class="p">;</span><span class="s"></span>
<span class="nv">executable</span><span class="s"> </span><span class="o">=</span><span class="s"> &quot;fzn-mysolver&quot;</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>Here is a list of all configuration options recognised by the configuration file parser. Any valid configuration file must at least contain the fields <tt class="docutils literal">name</tt>, <tt class="docutils literal">version</tt>, <tt class="docutils literal">id</tt>, and <tt class="docutils literal">executable</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">name</tt> (string, required): The name of the solver (displayed, together with the version, when you call <tt class="docutils literal">minizinc --solvers</tt>, and in the MiniZinc IDE).</li>
<li><tt class="docutils literal">version</tt> (string, required): The version of the solver.</li>
<li><tt class="docutils literal">id</tt> (string, required): A unique identifier for the solver, “reverse domain name” notation.</li>
<li><tt class="docutils literal">executable</tt> (string, required): The executable for this solver that can run FlatZinc files. This can be just a file name (in which case the solver has to be on the current PATH), or an absolute path to the executable, or a relative path (which is interpreted relative to the location of the configuration file).</li>
<li><tt class="docutils literal">mznlib</tt> (string, default <tt class="docutils literal">""</tt>): The solver-specific library of global constraints and redefinitions. This should be the name of a directory (either an absolute path or a relative path, interpreted relative to the location of the configuration file). For solvers whose libraries are installed in the same location as the MiniZinc standard library, this can also take the form <tt class="docutils literal">-G<solverlib></tt>, e.g., <tt class="docutils literal">-Ggecode</tt> (this is mostly the case for solvers that ship with the MiniZinc binary distribution).</li>
<li><tt class="docutils literal">tags</tt> (list of strings, default empty): Each solver can have one or more tags that describe its features in an abstract way. Tags can be used for selecting a solver using the <tt class="docutils literal">--solver</tt> option. There is no fixed list of tags, however we recommend using the following tags if they match the solver’s behaviour:<ul>
<li><tt class="docutils literal">"cp"</tt>: for Constraint Programming solvers</li>
<li><tt class="docutils literal">"mip"</tt>: for Mixed Integer Programming solvers</li>
<li><tt class="docutils literal">"float"</tt>: for solvers that support float variables</li>
<li><tt class="docutils literal">"api"</tt>: for solvers that use the internal C++ API</li>
</ul>
</li>
<li><tt class="docutils literal">stdFlags</tt> (list of strings, default empty): Which of the standard solver command line flags are supported by this solver. The standard flags are <tt class="docutils literal">-a</tt>, <tt class="docutils literal">-n</tt>, <tt class="docutils literal">-s</tt>, <tt class="docutils literal">-p</tt>, <tt class="docutils literal">-r</tt>, <tt class="docutils literal">-f</tt>.</li>
<li><tt class="docutils literal">extraFlags</tt> (list of list of strings, default empty): Extra command line flags supported by the solver. Each entry should be a list two, three or four strings. The first string is the name of the option (e.g. <tt class="docutils literal">"--special-algorithm"</tt>). The second string is a description that can be used to generate help output (e.g. <tt class="docutils literal">"which special algorithm to use"</tt>). The third string specifies the type of the argument (as a MiniZinc type). The fourth string is the default value. If no type is specified, <tt class="docutils literal">"bool"</tt> is assumed.</li>
<li><tt class="docutils literal">supportsMzn</tt> (bool, default <tt class="docutils literal">false</tt>): Whether the solver can run MiniZinc directly (i.e., it implements its own compilation or interpretation of the model).</li>
<li><tt class="docutils literal">supportsFzn</tt> (bool, default <tt class="docutils literal">true</tt>): Whether the solver can run FlatZinc. This should be the case for most solvers</li>
<li><tt class="docutils literal">needsSolns2Out</tt> (bool, default <tt class="docutils literal">true</tt>): Whether the output of the solver needs to be passed through the MiniZinc output processor.</li>
<li><tt class="docutils literal">needsMznExecutable</tt> (bool, default <tt class="docutils literal">false</tt>): Whether the solver needs to know the location of the MiniZinc executable. If true, it will be passed to the solver using the <tt class="docutils literal">mzn-executable</tt> option.</li>
<li><tt class="docutils literal">needsStdlibDir</tt> (bool, default <tt class="docutils literal">false</tt>): Whether the solver needs to know the location of the MiniZinc standard library directory. If true, it will be passed to the solver using the <tt class="docutils literal">stdlib-dir</tt> option.</li>
<li><tt class="docutils literal">isGUIApplication</tt> (bool, default <tt class="docutils literal">false</tt>): Whether the solver has its own graphical user interface, which means that MiniZinc will detach from the process and not wait for it to finish or to produce any output.</li>
</ul>
</div>
<div class="section" id="grammar">
<span id="ch-fzn-syntax"></span><h2>4.3.6. Grammar<a class="headerlink" href="#grammar" title="Permalink to this headline">¶</a></h2>
<p>This is the full grammar for FlatZinc. It is a proper subset of the MiniZinc grammar (see <a class="reference internal" href="spec.html#spec-grammar"><span class="std std-numref">Section 4.1.14</span></a>). However, instead of specifying all the cases in the MiniZinc grammar that do <em>not</em> apply to FlatZinc, the BNF syntax below contains only the relevant syntactic constructs. It uses the same notation as in <a class="reference internal" href="spec.html#spec-syntax-notation"><span class="std std-numref">Section 4.1.2</span></a>.</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="c">% A FlatZinc model</span><span class="s"></span>
<span class="cs">&lt;model&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span>
<span class="s">  </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;predicate-item&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>
<span class="s">  </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;par-decl-item&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>
<span class="s">  </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;var-decl-item&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>
<span class="s">  </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;constraint-item&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>
<span class="s">  </span><span class="cs">&lt;solve-item&gt;</span><span class="s"></span>

<span class="c">% Predicate items</span><span class="s"></span>
<span class="cs">&lt;predicate-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;predicate&quot; </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;pred-param-type&gt;</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;)&quot; &quot;;&quot;</span>

<span class="c">% Identifiers</span><span class="s"></span>
<span class="cs">&lt;identifier&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="sr">[A-Za-z][A-Za-z0-9_]</span><span class="o">*</span><span class="s"></span>

<span class="cs">&lt;basic-par-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;bool&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;int&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;float&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;set of int&quot;</span>

<span class="cs">&lt;par-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-par-type&gt;</span><span class="s"></span>
<span class="cs">             |</span><span class="s"> &quot;array&quot; &quot;[&quot; </span><span class="cs">&lt;index-set&gt;</span><span class="s"> &quot;]&quot; &quot;of&quot; </span><span class="cs">&lt;basic-par-type&gt;</span><span class="s"></span>

<span class="cs">&lt;basic-var-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;var&quot; &quot;bool&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; &quot;int&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; &quot;{&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. &quot;}&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; &quot;float&quot;</span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; </span><span class="cs">&lt;float-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;float-literal&gt;</span><span class="s"></span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; &quot;set&quot; &quot;of&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                   |</span><span class="s"> &quot;var&quot; &quot;set&quot; &quot;of&quot; &quot;{&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;}&quot;</span>

<span class="cs">&lt;array-var-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;array&quot; &quot;[&quot; </span><span class="cs">&lt;index-set&gt;</span><span class="s"> &quot;]&quot; &quot;of&quot; </span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"></span>

<span class="cs">&lt;index-set&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;1&quot; &quot;..&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>

<span class="cs">&lt;basic-pred-param-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-par-type&gt;</span><span class="s"></span>
<span class="cs">                          |</span><span class="s"> </span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"></span>
<span class="cs">                          |</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                          |</span><span class="s"> </span><span class="cs">&lt;float-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;float-literal&gt;</span><span class="s"></span>
<span class="cs">                          |</span><span class="s"> &quot;{&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. &quot;}&quot;</span>
<span class="cs">                          |</span><span class="s"> &quot;set&quot; &quot;of&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                          |</span><span class="s"> &quot;set&quot; &quot;of&quot; &quot;{&quot; </span><span class="p">[</span><span class="s">  </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;}&quot;</span>
<span class="cs">                          |</span><span class="s"> &quot;var&quot; &quot;set&quot; &quot;of&quot; &quot;int&quot;</span>

<span class="cs">&lt;pred-param-type&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-pred-param-type&gt;</span><span class="s"></span>
<span class="cs">                    |</span><span class="s"> &quot;array&quot; &quot;[&quot; </span><span class="cs">&lt;pred-index-set&gt;</span><span class="s"> &quot;]&quot; &quot;of&quot; </span><span class="cs">&lt;basic-pred-param-type&gt;</span><span class="s"></span>

<span class="cs">&lt;pred-index-set&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;index-set&gt;</span><span class="s"></span>
<span class="cs">                   |</span><span class="s"> &quot;int&quot;</span>

<span class="cs">&lt;basic-literal-expr&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;bool-literal&gt;</span><span class="s"></span>
<span class="cs">                       |</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                       |</span><span class="s"> </span><span class="cs">&lt;float-literal&gt;</span><span class="s"></span>
<span class="cs">                       |</span><span class="s"> </span><span class="cs">&lt;set-literal&gt;</span><span class="s"></span>

<span class="cs">&lt;basic-expr&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-literal-expr&gt;</span><span class="s"></span>
<span class="cs">              |</span><span class="s"> </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"></span>

<span class="cs">&lt;expr&gt;</span><span class="s">       </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"></span>
<span class="cs">               |</span><span class="s"> </span><span class="cs">&lt;array-literal&gt;</span><span class="s"></span>

<span class="cs">&lt;par-expr&gt;</span><span class="s">   </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-literal-expr&gt;</span><span class="s"></span>
<span class="cs">               |</span><span class="s"> </span><span class="cs">&lt;par-array-literal&gt;</span><span class="s"></span>

<span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="sr">[A-Za-z_][A-Za-z0-9_]</span><span class="o">*</span><span class="s"></span>

<span class="c">% Boolean literals</span><span class="s"></span>
<span class="cs">&lt;bool-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;false&quot;</span>
<span class="cs">                 |</span><span class="s"> &quot;true&quot;</span>

<span class="c">% Integer literals</span><span class="s"></span>
<span class="cs">&lt;int-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="sr">[0-9]</span><span class="o">+</span><span class="s"></span>
<span class="cs">                |</span><span class="s"> </span><span class="m">0</span><span class="s">x</span><span class="sr">[0-9A-Fa-f]</span><span class="o">+</span><span class="s"></span>
<span class="cs">                |</span><span class="s"> </span><span class="m">0</span><span class="s">o</span><span class="sr">[0-7]</span><span class="o">+</span><span class="s"></span>

<span class="c">% Float literals</span><span class="s"></span>
<span class="cs">&lt;float-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="sr">[0-9]</span><span class="o">+</span><span class="s">.</span><span class="sr">[0-9]</span><span class="o">+</span><span class="s"></span>
<span class="cs">                  |</span><span class="s"> </span><span class="sr">[0-9]</span><span class="o">+</span><span class="s">.</span><span class="sr">[0-9]</span><span class="o">+</span><span class="sr">[Ee][-+]</span><span class="s">?</span><span class="sr">[0-9]</span><span class="o">+</span><span class="s"></span>
<span class="cs">                  |</span><span class="s"> </span><span class="sr">[0-9]</span><span class="o">+</span><span class="sr">[Ee][-+]</span><span class="s">?</span><span class="sr">[0-9]</span><span class="o">+</span><span class="s"></span>

<span class="c">% Set literals</span><span class="s"></span>
<span class="cs">&lt;set-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;{&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;}&quot;</span>
<span class="cs">                |</span><span class="s"> </span><span class="cs">&lt;int-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;int-literal&gt;</span><span class="s"></span>
<span class="cs">                |</span><span class="s"> &quot;{&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;float-literal&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;}&quot;</span>
<span class="cs">                |</span><span class="s"> </span><span class="cs">&lt;float-literal&gt;</span><span class="s"> &quot;..&quot; </span><span class="cs">&lt;float-literal&gt;</span><span class="s"></span>

<span class="cs">&lt;array-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;[&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;]&quot;</span>

<span class="cs">&lt;par-array-literal&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;[&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;basic-literal-expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;]&quot;</span>

<span class="c">% Parameter declarations</span><span class="s"></span>

<span class="cs">&lt;par-decl-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;par-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;par-expr&gt;</span><span class="s"> &quot;;&quot;</span>

<span class="c">% Variable declarations</span><span class="s"></span>

<span class="cs">&lt;var-decl-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;basic-var-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="cs">&lt;annotations&gt;</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"> &quot;;&quot;</span>
<span class="cs">                  |</span><span class="s"> </span><span class="cs">&lt;array-var-type&gt;</span><span class="s"> &quot;:&quot; </span><span class="cs">&lt;var-par-identifier&gt;</span><span class="s"> </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;=&quot; </span><span class="cs">&lt;array-literal&gt;</span><span class="s"> &quot;;&quot;</span>
<span class="s">                  </span>

<span class="c">% Constraint items</span><span class="s"></span>

<span class="cs">&lt;constraint-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;constraint&quot; </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="p">[</span><span class="s"> </span><span class="cs">&lt;expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. </span><span class="p">]</span><span class="s"> &quot;)&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;;&quot;</span>

<span class="c">% Solve item</span><span class="s"></span>

<span class="cs">&lt;solve-item&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;satisfy&quot; &quot;;&quot;</span>
<span class="cs">               |</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;minimize&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> &quot;;&quot;</span>
<span class="cs">               |</span><span class="s"> &quot;solve&quot; </span><span class="cs">&lt;annotations&gt;</span><span class="s"> &quot;maximize&quot; </span><span class="cs">&lt;basic-expr&gt;</span><span class="s"> &quot;;&quot;</span>

<span class="c">% Annotations</span><span class="s"></span>

<span class="cs">&lt;annotations&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;::&quot; </span><span class="cs">&lt;annotation&gt;</span><span class="s"> </span><span class="p">]</span><span class="o">*</span><span class="s"></span>

<span class="cs">&lt;annotation&gt;</span><span class="s"> </span><span class="cs">::=</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"></span>
<span class="cs">               |</span><span class="s"> </span><span class="cs">&lt;identifier&gt;</span><span class="s"> &quot;(&quot; </span><span class="cs">&lt;ann-expr&gt;</span><span class="s"> &quot;,&quot; </span><span class="o">..</span><span class="s">. &quot;)&quot;</span>

<span class="cs">&lt;ann-expr&gt;</span><span class="s">   </span><span class="p">:</span><span class="o">=</span><span class="s"> </span><span class="cs">&lt;expr&gt;</span><span class="s"></span>
<span class="cs">              |</span><span class="s"> </span><span class="cs">&lt;annotation&gt;</span><span class="s"></span>

<span class="c">% End of FlatZinc grammar</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.<br/>
    </p>
  </div>
</footer>
  </body>
</html>