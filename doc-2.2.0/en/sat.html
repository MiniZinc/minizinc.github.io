<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.7. Boolean Satisfiability Modelling in MiniZinc &#8212; The MiniZinc Handbook 2.2.0</title>
    <link rel="stylesheet" href="static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="static/style.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.8. FlatZinc and Flattening" href="flattening.html" />
    <link rel="prev" title="2.6. Effective Modelling Practices in MiniZinc" href="efficient.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="static/MiniZn_logo_2.svg"></span>
          The MiniZinc Handbook</a>
        <span class="navbar-text navbar-version pull-left"><b>2.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html">1.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html#structure">1.1.1. Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro.html#how-to-read-this">1.1.2. How to Read This</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="installation.html">1.2. Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installation.html#binary-packages">1.2.1. Binary Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#compilation-from-source-code">1.2.2. Compilation from Source Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="installation.html#adding-third-party-solvers">1.2.3. Adding Third-party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="basic_steps.html">1.3. First steps with MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-ide">1.3.1. The MiniZinc IDE</a></li>
<li class="toctree-l3"><a class="reference internal" href="basic_steps.html#the-minizinc-command-line-tool">1.3.2. The MiniZinc command line tool</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. Basic Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#our-first-example">2.1.1. Our First Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#an-arithmetic-optimisation-example">2.1.2. An Arithmetic Optimisation Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#datafiles-and-assertions">2.1.3. Datafiles and Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#real-number-solving">2.1.4. Real Number Solving</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling.html#basic-structure-of-a-model">2.1.5. Basic structure of a model</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. More Complex Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#arrays-and-sets">2.2.1. Arrays and Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#global-constraints">2.2.2. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#conditional-expressions">2.2.3. Conditional Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#enumerated-types">2.2.4. Enumerated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#complex-constraints">2.2.5. Complex Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#set-constraints">2.2.6. Set Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="modelling2.html#putting-it-all-together">2.2.7. Putting it all together</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. Predicates and Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#global-constraints">2.3.1. Global Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-predicates">2.3.2. Defining Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#defining-functions">2.3.3. Defining Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#reflection-functions">2.3.4. Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-variables">2.3.5. Local Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#context">2.3.6. Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#local-constraints">2.3.7. Local Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#domain-reflection-functions">2.3.8. Domain Reflection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="predicates.html#scope">2.3.9. Scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. Option Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#declaring-and-using-option-types">2.4.1. Declaring and Using Option Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="optiontypes.html#hidden-option-types">2.4.2. Hidden Option Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. Search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#finite-domain-search">2.5.1. Finite Domain Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#search-annotations">2.5.2. Search Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="mzn_search.html#annotations">2.5.3. Annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. Effective Modelling Practices in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#variable-bounds">2.6.1. Variable Bounds</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#effective-generators">2.6.2. Effective Generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#redundant-constraints">2.6.3. Redundant Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#modelling-choices">2.6.4. Modelling Choices</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#multiple-modelling-and-channels">2.6.5. Multiple Modelling and Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="efficient.html#symmetry">2.6.6. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modelling-integers">2.7.1. Modelling Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc and Flattening</a><ul>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#flattening-expressions">2.8.1. Flattening Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#linear-expressions">2.8.2. Linear Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#unrolling-expressions">2.8.3. Unrolling Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#arrays">2.8.4. Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#reification">2.8.5. Reification</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#predicates">2.8.6. Predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="flattening.html#let-expressions">2.8.7. Let Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="command_line.html">3.1. The MiniZinc Command Line Tool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#basic-usage">3.1.1. Basic Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#adding-solvers">3.1.2. Adding Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#options">3.1.3. Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="command_line.html#user-configuration-files">3.1.4. User Configuration Files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="minizinc_ide.html">3.2. The MiniZinc IDE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#editing-minizinc-model-files">3.2.1. Editing MiniZinc model files</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuring-and-running-the-solver">3.2.2. Configuring and Running the Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#working-with-projects">3.2.3. Working With Projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#automatic-solution-checking">3.2.4. Automatic Solution Checking</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#submitting-solutions-to-online-courses">3.2.5. Submitting Solutions to Online Courses</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#configuration-options">3.2.6. Configuration Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="minizinc_ide.html#adding-third-party-solvers">3.2.7. Adding Third-Party Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cpprofiler.html">3.3. CP-Profiler</a><ul>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#connecting-a-solver-execution">3.3.1. Connecting a Solver Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#the-protocol-high-level">3.3.2. The protocol (high level)</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#the-protocol-low-level">3.3.3. The protocol (low level)</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#traditional-tree-visualisation">3.3.4. Traditional Tree Visualisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#alternative-search-tree-visualisations">3.3.5. Alternative Search Tree Visualisations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#similar-subtree-analysis">3.3.6. Similar Subtree Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#execution-comparison-by-merging">3.3.7. Execution Comparison by Merging</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#replaying-search">3.3.8. Replaying Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpprofiler.html#nogood-analysis">3.3.9. Nogood Analysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="jupyter.html">3.4. Using MiniZinc in Jupyter Notebooks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spec.html">4.1. Specification of MiniZinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spec.html#introduction">4.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#notation">4.1.2. Notation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#overview-of-a-model">4.1.3. Overview of a Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#syntax-overview">4.1.4. Syntax Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#high-level-model-structure">4.1.5. High-level Model Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#types-and-type-insts">4.1.6. Types and Type-insts</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#expressions">4.1.7. Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#items">4.1.8. Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#annotations">4.1.9. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#partiality">4.1.10. Partiality</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#built-in-operations">4.1.11. Built-in Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#content-types">4.1.12. Content-types</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#json-support">4.1.13. JSON support</a></li>
<li class="toctree-l3"><a class="reference internal" href="spec.html#full-grammar">4.1.14. Full grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lib.html">4.2. The MiniZinc library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lib-globals.html">4.2.1. Global constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-annotations.html">4.2.2. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-optiontypes.html">4.2.3. Option type support</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-options.html">4.2.4. Compiler options</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-builtins.html">4.2.5. Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-flatzinc.html">4.2.6. FlatZinc builtins</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-spec.html">4.3. Interfacing Solvers to Flatzinc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#specification-of-flatzinc">4.3.1. Specification of FlatZinc</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#output">4.3.2. Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#solver-specific-libraries">4.3.3. Solver-specific Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#command-line-interface">4.3.4. Command Line Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#solver-configuration-files">4.3.5. Solver Configuration Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="fzn-spec.html#grammar">4.3.6. Grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api_interfacing.html">4.4. Interfacing to MiniZinc via its API</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">2.7. Boolean Satisfiability Modelling in MiniZinc</a><ul>
<li><a class="reference internal" href="#modelling-integers">2.7.1. Modelling Integers</a></li>
<li><a class="reference internal" href="#modelling-disequality">2.7.2. Modelling Disequality</a></li>
<li><a class="reference internal" href="#modelling-cardinality">2.7.3. Modelling Cardinality</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="efficient.html" title="Previous Chapter: 2.6. Effective Modelling Practices in MiniZinc"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 2.6. Effectiv...</span>
    </a>
  </li>
  <li>
    <a href="flattening.html" title="Next Chapter: 2.8. FlatZinc and Flattening"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">2.8. FlatZinc... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="boolean-satisfiability-modelling-in-minizinc">
<span id="sec-sat"></span><h1>2.7. Boolean Satisfiability Modelling in MiniZinc<a class="headerlink" href="#boolean-satisfiability-modelling-in-minizinc" title="Permalink to this headline">¶</a></h1>
<p>MiniZinc can be used to model Boolean satisfiability
problems where the variables are restricted to be Boolean (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">bool</span><span class="s"></span></code>).
MiniZinc can be used with efficient Boolean satisfiability
solvers to solve the resulting models efficiently.</p>
<div class="section" id="modelling-integers">
<h2>2.7.1. Modelling Integers<a class="headerlink" href="#modelling-integers" title="Permalink to this headline">¶</a></h2>
<p>Many times although we wish to use a Boolean satisfiability solver we may
need to model some integer parts of our problem.</p>
<p>There are three common ways of modelling an integer variables
<span class="math notranslate nohighlight">\(I\)</span> in the range <span class="math notranslate nohighlight">\(0 \dots m\)</span> where <span class="math notranslate nohighlight">\(m = 2^{k}-1\)</span>
using Boolean
variables.</p>
<ul>
<li><p class="first">Binary: <span class="math notranslate nohighlight">\(I\)</span> is represented by <span class="math notranslate nohighlight">\(k\)</span> binary variables
<span class="math notranslate nohighlight">\(i_0, \ldots, i_{k-1}\)</span> where
<span class="math notranslate nohighlight">\(I = 2^{k-1} i_{k-1} + 2^{k-2} i_{k-2} + \cdots + 2 i_1 + i_0\)</span>.
This can be represented in MiniZinc as</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">k</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s">  </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nb">pow</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="nv">k</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">I</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">k</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="nv">j</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
</li>
<li><p class="first">Unary: where <span class="math notranslate nohighlight">\(I\)</span> is represented by <span class="math notranslate nohighlight">\(m\)</span> binary variables
<span class="math notranslate nohighlight">\(i_1, \ldots, i_m\)</span>
and <span class="math notranslate nohighlight">\(i = \sum_{j=1}^m \mathtt{bool2int}(i_j)\)</span>.  Since there is massive redundancy in
the unary representation we usually require that
<span class="math notranslate nohighlight">\(i_j \rightarrow i_{j-1}, 1 &lt; j \leq m\)</span>. This can be represented in MiniZinc as</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">m</span><span class="p">]</span><span class="s">  </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="nv">m</span><span class="p">)(</span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="p">]);</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">:</span><span class="s"> </span><span class="nv">I</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">m</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
</li>
<li><p class="first">Value: where <span class="math notranslate nohighlight">\(I\)</span> is represented by <span class="math notranslate nohighlight">\(m+1\)</span> binary variables
<span class="math notranslate nohighlight">\(i_0, \ldots, i_m\)</span> where
<span class="math notranslate nohighlight">\(i = k \Leftrightarrow i_k\)</span>, and at most one of <span class="math notranslate nohighlight">\(i_0, \ldots, i_m\)</span> is true.
This can be represented in MiniZinc as</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">]</span><span class="s">  </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">:</span><span class="s"> </span><span class="nv">I</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">foall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">m</span><span class="p">)(</span><span class="nv">I</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">i</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
</li>
</ul>
<p>There are advantages and disadvantages to each representation.  It depends
on what operations on integers are to required in the model as to which is
preferable.</p>
</div>
<div class="section" id="modelling-disequality">
<h2>2.7.2. Modelling Disequality<a class="headerlink" href="#modelling-disequality" title="Permalink to this headline">¶</a></h2>
<p>Let us consider modelling a latin squares problem. A latin square
is an <span class="math notranslate nohighlight">\(n \times n\)</span> grid of numbers from <span class="math notranslate nohighlight">\(1..n\)</span> such that
each number appears exactly once in every row and column.
An integer model for latin squares is shown in <a class="reference internal" href="#ex-latin"><span class="std std-numref">Listing 2.7.1</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ex-latin">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.1 </span><span class="caption-text">Integer model for Latin Squares (<a class="reference download internal" href="downloads/latin.mzn" download=""><tt class="xref download docutils literal">latin.mzn</tt></a>).</span><a class="headerlink" href="#ex-latin" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"> </span><span class="c">% size of latin square</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">a</span><span class="p">;</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="s"></span>
<span class="s">             </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">             </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">a</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">])</span><span class="s"></span>
<span class="s">           </span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot; &quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">         </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The only constraint on the integers is in fact disequality, which is encoded
in the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> constraint.
The value representation is the best way of representing disequality.
A Boolean only model for latin squares is shown in
<a class="reference internal" href="#ex-latinbool"><span class="std std-numref">Listing 2.7.2</span></a>.
Note each integer array element <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> is replaced by an array of
Booleans.
We use the <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">exactlyone</span><span class="s"></span></code> predicate to encode that each value is used
exactly once in every row and every column, as well as to encode that exactly
one of the Booleans corresponding to integer array element <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> is true.</p>
<div class="literal-block-wrapper docutils container" id="ex-latinbool">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.2 </span><span class="caption-text">Boolean model for Latin Squares (<a class="reference download internal" href="downloads/latinbool.mzn" download=""><tt class="xref download docutils literal">latinbool.mzn</tt></a>).</span><a class="headerlink" href="#ex-latinbool" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"> </span><span class="c">% size of latin square</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">a</span><span class="p">;</span><span class="s"></span>

<span class="k">predicate</span><span class="s"> </span><span class="nf">atmostone</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="s"></span>
<span class="s">            </span><span class="p">(</span><span class="o">not</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="o">not</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">]));</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">exactlyone</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="nf">atmostone</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">exists</span><span class="p">(</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="s"></span>
<span class="s">             </span><span class="nf">exactlyone</span><span class="p">(</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">             </span><span class="nf">exactlyone</span><span class="p">(</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">             </span><span class="nf">exactlyone</span><span class="p">(</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="p">)(</span><span class="nv">a</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">           </span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="p">])</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">            </span><span class="nb">show</span><span class="p">(</span><span class="nv">k</span><span class="p">)</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot; &quot; </span><span class="k">endif</span><span class="s"> </span>
<span class="s">         </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="modelling-cardinality">
<h2>2.7.3. Modelling Cardinality<a class="headerlink" href="#modelling-cardinality" title="Permalink to this headline">¶</a></h2>
<p>Let us consider modelling the Light Up puzzle. The puzzle consists of a
rectangular grid of squares which are blank, or filled. Every filled square
may contain a number from 1 to 4, or may have no number. The aim is to place
lights
in the blank squares so that</p>
<ul class="simple">
<li>Each blank square is “illuminated”, that is can see a light through an
uninterupted line of blank squares</li>
<li>No two lights can see each other</li>
<li>The number of lights adjacent to a numbered filled square
is exactly the number in the filled square.</li>
</ul>
<p>An example of a Light Up puzzle is shown in <a class="reference internal" href="#fig-lightup"><span class="std std-numref">Fig. 2.7.1</span></a>
with its solution in <a class="reference internal" href="#fig-lightup-sol"><span class="std std-numref">Fig. 2.7.2</span></a>.</p>
<div class="figure" id="id1">
<span id="fig-lightup"></span><img alt="images/lightup.svg" src="images/lightup.svg" /><p class="caption"><span class="caption-number">Fig. 2.7.1 </span><span class="caption-text">An example of a Light Up puzzle</span></p>
</div>
<div class="figure" id="id2">
<span id="fig-lightup-sol"></span><img alt="images/lightup2.svg" src="images/lightup2.svg" /><p class="caption"><span class="caption-number">Fig. 2.7.2 </span><span class="caption-text">The completed solution of the Light Up puzzle</span></p>
</div>
<p>It is natural to model this problem
using Boolean variables to determine which
squares contain a light and which do not, but there is some integer
arithmetic to consider for the filled squares.</p>
<div class="literal-block-wrapper docutils container" id="ex-lightup">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.3 </span><span class="caption-text">SAT Model for the Light Up puzzle (<a class="reference download internal" href="downloads/lightup.mzn" download=""><tt class="xref download docutils literal">lightup.mzn</tt></a>).</span><a class="headerlink" href="#ex-lightup" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">h</span><span class="p">;</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">H</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">h</span><span class="p">;</span><span class="s"> </span><span class="c">% board height</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">w</span><span class="p">;</span><span class="s"> </span><span class="c">% board width</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">H</span><span class="p">,</span><span class="nv">W</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">;</span><span class="s">       </span><span class="c">% board</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s">                  </span><span class="c">% empty square</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">4</span><span class="p">;</span><span class="s">         </span><span class="c">% filled and numbered square</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="s"> </span><span class="o">=</span><span class="s">  </span><span class="m">5</span><span class="p">;</span><span class="s">                  </span><span class="c">% filled unnumbered square</span><span class="s"></span>

<span class="c">% position (i1,j1) is visible to (i2,j2)</span><span class="s"></span>
<span class="k">test</span><span class="s"> </span><span class="nf">visible</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i1</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">j1</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i2</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">j2</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"> </span>
<span class="s">    </span><span class="p">((</span><span class="nv">i1</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">i2</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">j1</span><span class="p">,</span><span class="nv">j2</span><span class="p">)</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">j1</span><span class="p">,</span><span class="nv">j2</span><span class="p">))(</span><span class="nv">b</span><span class="p">[</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">E</span><span class="p">))</span><span class="s"></span>
<span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="p">((</span><span class="nv">j1</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">j2</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">min</span><span class="p">(</span><span class="nv">i1</span><span class="p">,</span><span class="nv">i2</span><span class="p">)</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">i1</span><span class="p">,</span><span class="nv">i2</span><span class="p">))(</span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j1</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">E</span><span class="p">));</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="nv">H</span><span class="p">,</span><span class="nv">W</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">;</span><span class="s"> </span><span class="c">% is there a light</span><span class="s"></span>

<span class="c">% filled squares have no lights</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="p">,</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">E</span><span class="p">)(</span><span class="nv">l</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="p">);</span><span class="s"></span>
<span class="c">% lights next to filled numbered square agree</span><span class="s"></span>
<span class="k">include</span><span class="s"> &quot;boolsum.mzn&quot;</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">N</span><span class="p">)(</span><span class="s"></span>
<span class="s">    </span><span class="nf">bool_sum_eq</span><span class="p">([</span><span class="s"> </span><span class="nv">l</span><span class="p">[</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j1</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">j1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="s"> </span><span class="k">where</span><span class="s"></span>
<span class="s">                             </span><span class="nb">abs</span><span class="p">(</span><span class="nv">i1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">j1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">                             </span><span class="nv">i1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">j1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="p">],</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]));</span><span class="s"></span>
<span class="c">% each blank square is illuminated</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">E</span><span class="p">)(</span><span class="s"></span>
<span class="s">             </span><span class="nf">exists</span><span class="p">(</span><span class="nv">j1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nf">visible</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">i</span><span class="p">,</span><span class="nv">j1</span><span class="p">))(</span><span class="nv">l</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j1</span><span class="p">])</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">             </span><span class="nf">exists</span><span class="p">(</span><span class="nv">i1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nf">visible</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">,</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j</span><span class="p">))(</span><span class="nv">l</span><span class="p">[</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span>
<span class="s">           </span><span class="p">);</span><span class="s"></span>
<span class="c">% no two lights see each other</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i1</span><span class="p">,</span><span class="nv">i2</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="p">,</span><span class="s"> </span><span class="nv">j1</span><span class="p">,</span><span class="nv">j2</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="s"> </span><span class="k">where</span><span class="s"> </span>
<span class="s">                  </span><span class="p">(</span><span class="nv">i1</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">i2</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">j1</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">j2</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j1</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span>
<span class="s">                  </span><span class="o">/\</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i2</span><span class="p">,</span><span class="nv">j2</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">visible</span><span class="p">(</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j1</span><span class="p">,</span><span class="nv">i2</span><span class="p">,</span><span class="nv">j2</span><span class="p">))(</span><span class="s"></span>
<span class="s">             </span><span class="o">not</span><span class="s"> </span><span class="nv">l</span><span class="p">[</span><span class="nv">i1</span><span class="p">,</span><span class="nv">j1</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="o">not</span><span class="s"> </span><span class="nv">l</span><span class="p">[</span><span class="nv">i2</span><span class="p">,</span><span class="nv">j2</span><span class="p">]</span><span class="s"></span>
<span class="s">           </span><span class="p">);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">b</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
<span class="s">         </span><span class="k">else</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">l</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;L&quot; </span><span class="k">else</span><span class="s"> &quot;.&quot; </span><span class="k">endif</span><span class="s"></span>
<span class="s">         </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">w</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot; &quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">         </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">H</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">W</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>A model for the problem is given in <a class="reference internal" href="#ex-lightup"><span class="std std-numref">Listing 2.7.3</span></a>.
A data file for the problem shown in <a class="reference internal" href="#fig-lightup"><span class="std std-numref">Fig. 2.7.1</span></a>
is shown in <a class="reference internal" href="#fig-lightupdzn"><span class="std std-numref">Listing 2.7.4</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-lightupdzn">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.4 </span><span class="caption-text">Datafile for the Light Up puzzle instance shown in <a class="reference internal" href="#fig-lightup"><span class="std std-numref">Fig. 2.7.1</span></a>.</span><a class="headerlink" href="#fig-lightupdzn" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">h</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="p">;</span><span class="s"></span>
<span class="nv">w</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">7</span><span class="p">;</span><span class="s"></span>
<span class="nv">b</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"> </span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s">  </span><span class="m">0</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s">  </span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="o">-</span><span class="m">1</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>The model makes use of a Boolean sum predicate</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bool_sum_eq</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">s</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>which requires that the sum of an array of Boolean equals some fixed
integer. There are a number of ways of modelling such
<em>cardinality</em> constraints using Booleans.</p>
<ul class="simple">
<li>Adder networks: we can use a network of adders to
build a binary Boolean representation of the sum of the Booleans</li>
<li>Sorting networks: we can use a sorting network to sort
the array of Booleans to create a unary representation of the sum
of the Booleans</li>
<li>Binary decision diagrams: we can create a binary decision diagram
(BDD) that encodes the cardinality constraint.</li>
</ul>
<div class="literal-block-wrapper docutils container" id="ex-bboolsum">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.5 </span><span class="caption-text">Cardinality constraints by binary adder networks (<a class="reference download internal" href="downloads/bboolsum.mzn" download=""><tt class="xref download docutils literal">bboolsum.mzn</tt></a>).</span><a class="headerlink" href="#ex-bboolsum" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% the sum of booleans x = s</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">bool_sum_eq</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">s</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">     </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">     </span><span class="k">if</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="l">false</span><span class="s"> </span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="c">% cp = number of bits required for representing 0..c</span><span class="s"></span>
<span class="s">                </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cp</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">floor</span><span class="p">(</span><span class="nb">log2</span><span class="p">(</span><span class="nb">int2float</span><span class="p">(</span><span class="nv">c</span><span class="p">))),</span><span class="s"></span>
<span class="s">                </span><span class="c">% z is sum of x in binary </span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">cp</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">z</span><span class="s">  </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">          </span><span class="nf">binary_sum</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span>
<span class="s">          </span><span class="c">% z == s</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">cp</span><span class="p">)(</span><span class="nv">z</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="p">((</span><span class="nv">s</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nb">pow</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="nv">i</span><span class="p">))</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="p">))</span><span class="s"> </span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">true</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">else</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;binarysum.mzn&quot;</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-binarysum">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.6 </span><span class="caption-text">Code for building binary addition networks (<a class="reference download internal" href="downloads/binarysum.mzn" download=""><tt class="xref download docutils literal">binarysum.mzn</tt></a>).</span><a class="headerlink" href="#ex-binarysum" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% the sum of bits x = s in binary. </span><span class="s"></span>
<span class="c">%            s[0], s[1], ..., s[k] where 2^k &gt;= length(x) &gt; 2^(k-1)</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">binary_sum</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span>
<span class="s">                     </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">s</span><span class="p">)</span><span class="o">=</span><span class="s"></span>
<span class="s">     </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span>
<span class="s">     </span><span class="k">if</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="k">then</span><span class="s"> </span>
<span class="s">             </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">xor</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="s"></span>
<span class="s">     </span><span class="k">else</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ll</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">l</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">),</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">ll</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">ll</span><span class="s"> </span><span class="p">],</span><span class="s"> </span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">ll</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">ll</span><span class="o">+</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="o">*</span><span class="nv">ll</span><span class="p">],</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">ll</span><span class="o">*</span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">l</span><span class="p">]</span><span class="s"> </span><span class="k">endif</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cp</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">floor</span><span class="p">(</span><span class="nb">log2</span><span class="p">(</span><span class="nb">int2float</span><span class="p">(</span><span class="nv">ll</span><span class="p">))),</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">cp</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">fs</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">cp</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ts</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">                </span><span class="nf">binary_sum</span><span class="p">(</span><span class="nv">f</span><span class="p">,</span><span class="s"> </span><span class="nv">fs</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">binary_sum</span><span class="p">(</span><span class="nv">t</span><span class="p">,</span><span class="s"> </span><span class="nv">ts</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">                </span><span class="nf">binary_add</span><span class="p">(</span><span class="nv">fs</span><span class="p">,</span><span class="s"> </span><span class="nv">ts</span><span class="p">,</span><span class="s"> </span><span class="nv">b</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>

<span class="c">% add two binary numbers x, and y and carry in bit ci to get binary s</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">binary_add</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ci</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">l</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">),</span><span class="s"> </span>
<span class="s">          </span><span class="kt">int</span><span class="p">:</span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">s</span><span class="p">),</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s">  </span>
<span class="s">    </span><span class="nb">assert</span><span class="p">(</span><span class="nv">l</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">y</span><span class="p">),</span><span class="s"></span>
<span class="s">          &quot;length of binary_add input args must be same&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">    </span><span class="nb">assert</span><span class="p">(</span><span class="nv">n</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">l</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="s"> &quot;length of binary_add output &quot; </span><span class="o">++</span><span class="s"></span>
<span class="s">                         &quot;must be equal or one more than inputs&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">    </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">l</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">    </span><span class="nf">full_adder</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">0</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="m">0</span><span class="p">],</span><span class="s"> </span><span class="nv">ci</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">],</span><span class="s"> </span><span class="nv">c</span><span class="p">[</span><span class="m">0</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">l</span><span class="p">)(</span><span class="nf">full_adder</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">],</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">],</span><span class="s"> </span><span class="nv">c</span><span class="p">[</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">],</span><span class="s"> </span><span class="nv">c</span><span class="p">[</span><span class="nv">i</span><span class="p">]))</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">if</span><span class="s"> </span><span class="nv">n</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="nv">l</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">c</span><span class="p">[</span><span class="nv">l</span><span class="p">]</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="nv">c</span><span class="p">[</span><span class="nv">l</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="k">endif</span><span class="s"> </span><span class="p">));</span><span class="s"></span>
<span class="s">    </span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">full_adder</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ci</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">co</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">xy</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">xor</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span>
<span class="s">          </span><span class="nv">s</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">xy</span><span class="s"> </span><span class="o">xor</span><span class="s"> </span><span class="nv">ci</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">co</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="p">(</span><span class="nv">ci</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">xy</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>We can implement <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bool_sum_eq</span><span class="s"></span></code> using binary adder networks
using the code shown in <a class="reference internal" href="#ex-bboolsum"><span class="std std-numref">Listing 2.7.5</span></a>.
The predicate <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">binary_sum</span><span class="s"></span></code>
defined in <a class="reference internal" href="#ex-binarysum"><span class="std std-numref">Listing 2.7.6</span></a>
creates a binary representation
of the sum of <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> by splitting the list into two,
summing up each half to create a binary representation
and then summing these two binary numbers using <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">binary_add</span><span class="s"></span></code>.
If the list <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> is odd the last bit is saved to use as a carry in
to the binary addition.</p>
<div class="literal-block-wrapper docutils container" id="ex-uboolsum">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.7 </span><span class="caption-text">Cardinality constraints by sorting networks (<a class="reference download internal" href="downloads/uboolsum.mzn" download=""><tt class="xref download docutils literal">uboolsum.mzn</tt></a>).</span><a class="headerlink" href="#ex-uboolsum" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% the sum of booleans x = s</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">bool_sum_eq</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">s</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">     </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">     </span><span class="k">if</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="l">false</span><span class="s"> </span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="c">% cp = nearest power of 2 &gt;= c</span><span class="s"></span>
<span class="s">                </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cp</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">pow</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="nb">ceil</span><span class="p">(</span><span class="nb">log2</span><span class="p">(</span><span class="nb">int2float</span><span class="p">(</span><span class="nv">c</span><span class="p">)))),</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">cp</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="c">% y is padded version of x</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">cp</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">z</span><span class="s">  </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">c</span><span class="o">+</span><span class="m">1</span><span class="o">..</span><span class="nv">cp</span><span class="p">)(</span><span class="nv">y</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">          </span><span class="nf">oesort</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="p">[</span><span class="nv">s</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">true</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="p">[</span><span class="nv">s</span><span class="o">+</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">true</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">else</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;oesort.mzn&quot;</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-oesort">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.8 </span><span class="caption-text">Odd-even merge sorting networks (<a class="reference download internal" href="downloads/oesort.mzn" download=""><tt class="xref download docutils literal">oesort.mzn</tt></a>).</span><a class="headerlink" href="#ex-oesort" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">%% odd-even sort</span><span class="s"></span>
<span class="c">%% y is the sorted version of x, all trues before falses</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">oesort</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">y</span><span class="p">)</span><span class="o">=</span><span class="s"></span>
<span class="s">  </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">))</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">  </span><span class="k">if</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span>
<span class="s">  </span><span class="k">elseif</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nf">comparator</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="s"></span>
<span class="s">  </span><span class="k">else</span><span class="s"></span>
<span class="s">    </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span>
<span class="s">      </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">xf</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">],</span><span class="s"></span>
<span class="s">      </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">xl</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">+</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">],</span><span class="s"></span>
<span class="s">      </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">tf</span><span class="p">,</span><span class="s"></span>
<span class="s">      </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">tl</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">    </span><span class="nf">oesort</span><span class="p">(</span><span class="nv">xf</span><span class="p">,</span><span class="nv">tf</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">oesort</span><span class="p">(</span><span class="nv">xl</span><span class="p">,</span><span class="nv">tl</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">oemerge</span><span class="p">(</span><span class="nv">tf</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="nv">tl</span><span class="p">,</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
<span class="s">  </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>

<span class="c">%% odd-even merge</span><span class="s"></span>
<span class="c">%% y is the sorted version of x, all trues before falses</span><span class="s"></span>
<span class="c">%% assumes first half of x is sorted, and second half of x</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">oemerge</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">y</span><span class="p">)</span><span class="o">=</span><span class="s"></span>
<span class="s">  </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">card</span><span class="p">(</span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">))</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">  </span><span class="k">if</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span>
<span class="s">  </span><span class="k">elseif</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nf">comparator</span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">2</span><span class="p">])</span><span class="s"></span>
<span class="s">  </span><span class="k">else</span><span class="s"></span>
<span class="s">    </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">xo</span><span class="s"> </span><span class="o">=</span><span class="s"> </span>
<span class="s">            </span><span class="p">[</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"></span>
<span class="s">          </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">xe</span><span class="s"> </span><span class="o">=</span><span class="s"> </span>
<span class="s">            </span><span class="p">[</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="p">],</span><span class="s"></span>
<span class="s">          </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">          </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">te</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">      </span><span class="nf">oemerge</span><span class="p">(</span><span class="nv">xo</span><span class="p">,</span><span class="nv">to</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">oemerge</span><span class="p">(</span><span class="nv">xe</span><span class="p">,</span><span class="nv">te</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">      </span><span class="nv">y</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">to</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">      </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="s"></span>
<span class="s">        </span><span class="nf">comparator</span><span class="p">(</span><span class="nv">te</span><span class="p">[</span><span class="nv">i</span><span class="p">],</span><span class="nv">to</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">2</span><span class="o">*</span><span class="nv">i</span><span class="p">],</span><span class="nv">y</span><span class="p">[</span><span class="m">2</span><span class="o">*</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">]))</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span>
<span class="s">      </span><span class="nv">y</span><span class="p">[</span><span class="nv">c</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">te</span><span class="p">[</span><span class="nv">c</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="m">2</span><span class="p">]</span><span class="s"></span>
<span class="s">  </span><span class="k">endif</span><span class="gr">))</span><span class="p">;</span><span class="s"></span>
<span class="s"> </span>
<span class="c">% comparator o1 = max(i1,i2), o2 = min(i1,i2)</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">comparator</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">i1</span><span class="p">,</span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">i2</span><span class="p">,</span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">o1</span><span class="p">,</span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">o2</span><span class="p">)</span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="p">(</span><span class="nv">o1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">i1</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">i2</span><span class="p">))</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="p">(</span><span class="nv">o2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nv">i1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">i2</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>We can implement <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bool_sum_eq</span><span class="s"></span></code> using unary sorting networks
using the code shown in <a class="reference internal" href="#ex-uboolsum"><span class="std std-numref">Listing 2.7.7</span></a>.
The cardinality constraint is defined by expanding the input
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> to have length a power of 2, and sorting the resulting bits
using an odd-even merge sorting network.
The odd-even merge sorter shown in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">ex</span><span class="o">-</span><span class="nv">oesort</span><span class="s"></span></code> works
recursively by splitting
the input list in 2, sorting each list and merging the two
sorted lists.</p>
<div class="literal-block-wrapper docutils container" id="ex-bddsum">
<div class="code-block-caption"><span class="caption-number">Listing 2.7.9 </span><span class="caption-text">Cardinality constraints by binary decision diagrams (<a class="reference download internal" href="downloads/bddsum.mzn" download=""><tt class="xref download docutils literal">bddsum.mzn</tt></a>).</span><a class="headerlink" href="#ex-bddsum" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% the sum of booleans x = s</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">bool_sum_eq</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">s</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">     </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">),</span><span class="s"></span>
<span class="s">           </span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">c</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">)]</span><span class="s"> </span>
<span class="s">     </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">     </span><span class="nf">rec_bool_sum_eq</span><span class="p">(</span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">);</span><span class="s"></span>

<span class="k">predicate</span><span class="s"> </span><span class="nf">rec_bool_sum_eq</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">s</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">     </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">length</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">     </span><span class="k">if</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="l">false</span><span class="s"> </span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">f</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">f</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">f</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">true</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">rec_bool_sum_eq</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">f</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">s</span><span class="o">-</span><span class="m">1</span><span class="p">))</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">          </span><span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="nv">f</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nf">rec_bool_sum_eq</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">f</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">s</span><span class="p">))</span><span class="s"></span>
<span class="s">     </span><span class="k">elseif</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">c</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">f</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">          </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">f</span><span class="o">..</span><span class="nv">c</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="l">true</span><span class="p">)</span><span class="s"></span>
<span class="s">     </span><span class="k">else</span><span class="s"> </span><span class="l">false</span><span class="s"> </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>We can implement <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">bool_sum_eq</span><span class="s"></span></code> using binary decision diagrams
using the code shown in <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">ex</span><span class="p">:</span><span class="nv">bddsum</span><span class="s"></span></code>.
The cardinality constraint is broken into two cases:
either the first element <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"></span></code> is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">true</span><span class="s"></span></code>,
and the sum of the remaining bits
is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="o">-</span><span class="m">1</span><span class="s"></span></code>, or <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"></span></code> is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">false</span><span class="s"></span></code> and the sum of the remaining bits
is <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code>. For efficiency this relies on common subexpression elimination
to avoid creating many equivalent constraints.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.<br/>
    </p>
  </div>
</footer>
  </body>
</html>