

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head><!-- analytics -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-63390311-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-63390311-1');
</script>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.2.6. Global constraints &mdash; The MiniZinc Handbook 2.3.2</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/lib-globals.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4.2.7. Additional declarations for Gecode" href="lib-gecode.html" />
    <link rel="prev" title="4.2.5. FlatZinc builtins" href="lib-flatzinc.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_2_tutorial.html">2. A MiniZinc Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spec.html">4.1. Specification of MiniZinc</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="lib.html">4.2. The MiniZinc library</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lib-annotations.html">4.2.1. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-optiontypes.html">4.2.2. Option type support</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-options.html">4.2.3. Compiler options</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-builtins.html">4.2.4. Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-flatzinc.html">4.2.5. FlatZinc builtins</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">4.2.6. Global constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#all-different-and-related-constraints">4.2.6.1. All-Different and related constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lexicographic-constraints">4.2.6.2. Lexicographic constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sorting-constraints">4.2.6.3. Sorting constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#channeling-constraints">4.2.6.4. Channeling constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counting-constraints">4.2.6.5. Counting constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packing-constraints">4.2.6.6. Packing constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scheduling-constraints">4.2.6.7. Scheduling constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#graph-constraints">4.2.6.8. Graph constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extensional-constraints-table-regular-etc">4.2.6.9. Extensional constraints (table, regular etc.)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-declarations">4.2.6.10. Other declarations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lib-gecode.html">4.2.7. Additional declarations for Gecode</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-chuffed.html">4.2.8. Additional declarations for Chuffed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-spec.html">4.3. Interfacing Solvers to Flatzinc</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_4_reference.html">4. Reference Manual</a> &raquo;</li>
        
          <li><a href="lib.html">4.2. The MiniZinc library</a> &raquo;</li>
        
      <li>4.2.6. Global constraints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="global-constraints">
<span id="ch-lib-globals"></span><h1>4.2.6. Global constraints<a class="headerlink" href="#global-constraints" title="Permalink to this headline">¶</a></h1>
<p>These constraints represent high-level modelling abstractions, for which
many solvers implement special, efficient inference algorithms.</p>
<div class="section" id="all-different-and-related-constraints">
<h2>4.2.6.1. All-Different and related constraints<a class="headerlink" href="#all-different-and-related-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//all_different.mzn#L8-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//all_different.mzn#L15-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_disjoint</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">S</tt>  to be pairwise disjoint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//all_disjoint.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-3"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//all_equal.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-4"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//all_equal.mzn#L13-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-5"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alldifferent_except_0</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">vs</tt>  to be all different except those
elements that are assigned the value 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//alldifferent_except_0.mzn#L8-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-6"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of distinct values in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">n</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_nvalue.mzn#L1-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-7"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of distinct values in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//nvalue_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">symmetric_all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires the array of integers <tt class="docutils literal">x</tt>  to be all different, and for all <tt class="docutils literal">i</tt> ,
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ]=j <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">x</tt> [ <tt class="docutils literal">j</tt> ]= <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//symmetric_all_different.mzn#L9-L11">More…</a></p>
</div>
<div class="section" id="lexicographic-constraints">
<h2>4.2.6.2. Lexicographic constraints<a class="headerlink" href="#lexicographic-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-9"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns may be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex2.mzn#L3-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-10"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greater.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-11"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greater.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-12"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greater.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-13"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greater.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-14"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greatereq.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-15"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greatereq.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-16"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greatereq.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-17"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//lex_greatereq.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-18"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_less_bool.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-19"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_less_int.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-20"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_less_float.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-21"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_less_set.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-22"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_lesseq_bool.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-23"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_lesseq_float.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-24"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_lesseq_int.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-25"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_lex_lesseq_set.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-26"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">seq_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">i</tt>  precedes <tt class="docutils literal">i</tt> +1 in the array <tt class="docutils literal">x</tt>  for all positive <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//seq_precede_chain.mzn#L9-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-27"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">seq_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">i</tt>  appears in a set in array <tt class="docutils literal">x</tt>  before <tt class="docutils literal">i</tt> +1 for all positive <tt class="docutils literal">i</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//seq_precede_chain.mzn#L15-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-28"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">strict_lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns cannot be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_strict_lex2.mzn#L3-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-29"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">s</tt>  precede <tt class="docutils literal">t</tt>  in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of <tt class="docutils literal">x</tt>
is equal to <tt class="docutils literal">t</tt> , then another element of <tt class="docutils literal">x</tt>  with a  lower index is equal
to <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_value_precede_int.mzn#L1-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-30"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">s</tt>  precede <tt class="docutils literal">t</tt>  in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of <tt class="docutils literal">x</tt>
contains <tt class="docutils literal">t</tt>  but not <tt class="docutils literal">s</tt> , then another element of <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">s</tt>  but not <tt class="docutils literal">t</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_value_precede_set.mzn#L1-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-31"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of <tt class="docutils literal">x</tt>
is equal to <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1], then another element of <tt class="docutils literal">x</tt>  with a  lower index is equal
to <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//value_precede_chain_int.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-32"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of <tt class="docutils literal">x</tt>
contains <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] but not <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ], then another element of <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] but not <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_value_precede_chain_set.mzn#L3-L6">More…</a></p>
</div>
<div class="section" id="sorting-constraints">
<h2>4.2.6.3. Sorting constraints<a class="headerlink" href="#sorting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-33"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation <tt class="docutils literal">p</tt>  which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_sort.mzn#L11-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-34"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation <tt class="docutils literal">p</tt>  which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_sort.mzn#L29-L38">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-35"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">p</tt>  to be the permutation which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_sort_int.mzn#L3-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-36"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">p</tt>  to be the permutation which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_sort_float.mzn#L4-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-37"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_decreasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-38"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_decreasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-39"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_decreasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-40"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_decreasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-41"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_increasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-42"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_increasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-43"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_increasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-44"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_increasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-45"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the multiset of values in <tt class="docutils literal">x</tt>  are the same as the
multiset of values in <tt class="docutils literal">y</tt>  but <tt class="docutils literal">y</tt>  is in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//sort.mzn#L8-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-46"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Return a multiset of values that is the same as the
multiset of values in <tt class="docutils literal">x</tt>  but in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//sort_fn.mzn#L7-L11">More…</a></p>
</div>
<div class="section" id="channeling-constraints">
<h2>4.2.6.4. Channeling constraints<a class="headerlink" href="#channeling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-47"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">int_set_channel</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that array of int variables <tt class="docutils literal">x</tt>  and array of set variables <tt class="docutils literal">y</tt>
are related such that ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt> ) &amp;#8596; ( <tt class="docutils literal">i</tt>  in <tt class="docutils literal">y</tt> [ <tt class="docutils literal">j</tt> ]).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_int_set_channel.mzn#L1-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-48"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of int variables, <tt class="docutils literal">f</tt>  and <tt class="docutils literal">invf</tt> , to represent
inverse functions.  All the values in each array must be within the index
set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//inverse.mzn#L10-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-49"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Given a function <tt class="docutils literal">f</tt>  represented as an array, return the inverse function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//inverse_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-50"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of set of int variables, <tt class="docutils literal">f</tt>  and <tt class="docutils literal">invf</tt> , so that
a <tt class="docutils literal">j</tt>  in f[ <tt class="docutils literal">i</tt> ] iff <tt class="docutils literal">i</tt>  in invf[ <tt class="docutils literal">j</tt> ].  All the values in each array’s sets
must be within the index set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_inverse_set.mzn#L1-L11">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-51"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">link_set_to_booleans</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of Booleans <tt class="docutils literal">b</tt>  to be a representation of the set <tt class="docutils literal">s</tt> :
<tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt>  &amp;#8596; <tt class="docutils literal">b</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The index set of <tt class="docutils literal">b</tt>  must be a superset of the possible values of <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//link_set_to_booleans.mzn#L10-L14">More…</a></p>
</div>
<div class="section" id="counting-constraints">
<h2>4.2.6.5. Counting constraints<a class="headerlink" href="#counting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-52"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take one of the values in <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_among.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-53"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of variables in <tt class="docutils literal">x</tt>  that take one of the values in <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//among_fn.mzn#L6-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-54"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_at_least_int.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-55"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_at_least_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-56"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_at_most_int.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-57"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_at_most_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-58"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most1</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each pair of sets in <tt class="docutils literal">s</tt>  overlap in at most one element.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_at_most1.mzn#L1-L3">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-59"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_eq.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-60"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//count_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-61"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_eq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_eq.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-62"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count_eq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//count_eq.mzn#L13-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-63"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_geq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be greater than or equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_geq.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-64"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_gt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be strictly greater than the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_gt.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-65"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_leq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be less than or equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_leq.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-66"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_lt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be strictly less than the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_lt.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-67"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_neq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be not equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_count_neq.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-68"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nb">card</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">card</tt> [ <tt class="docutils literal">i</tt> ] is the number of occurences of <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//distribute.mzn#L8-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-69"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array of the number of occurences of <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//distribute_fn.mzn#L7-L11">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-70"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_exactly_int.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-71"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_exactly_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-72"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurrences of <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//global_cardinality.mzn#L7-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-73"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//global_cardinality_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-74"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurences of <tt class="docutils literal">i</tt>  in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//global_cardinality_closed.mzn#L9-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-75"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array with number of occurences of <tt class="docutils literal">i</tt>  in <tt class="docutils literal">x</tt> .</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//global_cardinality_closed_fn.mzn#L8-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-76"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all <tt class="docutils literal">i</tt> , the value <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_global_cardinality_low_up.mzn#L1-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-77"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all <tt class="docutils literal">i</tt> , the value <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array <tt class="docutils literal">x</tt> .</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_global_cardinality_low_up_closed.mzn#L1-L10">More…</a></p>
</div>
<div class="section" id="packing-constraints">
<h2>4.2.6.6. Packing constraints<a class="headerlink" href="#packing-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-78"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin does not exceed the
capacity <tt class="docutils literal">c</tt> .</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0
- <tt class="docutils literal">c</tt>  &gt;=0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bin_packing.mzn#L13-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-79"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_capa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin <tt class="docutils literal">b</tt>  does not exceed the
capacity <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0
- forall <tt class="docutils literal">b</tt> , <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ] &gt;=0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bin_packing_capa.mzn#L13-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-80"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">load</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin <tt class="docutils literal">b</tt>  is equal to
<tt class="docutils literal">load</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bin_packing_load.mzn#L12-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-81"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the load of each bin resulting from packing each item <tt class="docutils literal">i</tt>  with
weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ], where the load is defined as
the sum of the weights of the items in each bin.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bin_packing_load_fn.mzn#L12-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-82"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can still not overlap with any other rectangle.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//diffn.mzn#L9-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-83"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box <tt class="docutils literal">i</tt>
and dimension <tt class="docutils literal">j</tt> , <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension <tt class="docutils literal">j</tt> , and <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in any dimension still cannot overlap with any other box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//diffn_k.mzn#L10-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-84"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//diffn_nonstrict.mzn#L9-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-85"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box <tt class="docutils literal">i</tt>
and dimension <tt class="docutils literal">j</tt> , <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension <tt class="docutils literal">j</tt> , and <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in at least one dimension can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//diffn_nonstrict_k.mzn#L10-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-86"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//geost.mzn#L23-L51">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in. dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-87"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global <tt class="docutils literal">k</tt>  dimensional bounding box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//geost.mzn#L70-L106">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds, <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds, <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-88"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">geost_nonoverlap_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x1</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w1</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x2</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w2</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">2</tt>  dimensional objects. It enforces that no two objects overlap
and zero-length objects do not appear in the middle of other objects.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//geost.mzn#L182-L197">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">x1</tt>:  first coordinate of each object</li>
<li><tt class="docutils literal">w2</tt>:  width in first dimension for each object</li>
<li><tt class="docutils literal">x2</tt>:  second coordinate of each object</li>
<li><tt class="docutils literal">w2</tt>:  width in second dimension for each object</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-89"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_smallest_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global <tt class="docutils literal">k</tt>  dimensional bounding box. In addition, it enforces that the bounding box is the smallest one containing all objects, i.e., each of the <tt class="docutils literal">2k</tt>  boundaries is touched by at least by one object.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//geost.mzn#L124-L171">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds, <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds, <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-90"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">W</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">P</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that items are packed in a knapsack with certain weight and profit restrictions.</p>
<dl class="docutils">
<dt>Assumptions:</dt>
<dd><ul class="first last simple">
<li>Weights <tt class="docutils literal">w</tt>  and profits <tt class="docutils literal">p</tt>  must be non-negative</li>
<li><tt class="docutils literal">w</tt> , <tt class="docutils literal">p</tt>  and <tt class="docutils literal">x</tt>  must have the same index sets</li>
</ul>
</dd>
</dl>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//knapsack.mzn#L17-L26">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">w</tt>:  weight of each type of item</li>
<li><tt class="docutils literal">p</tt>:  profit of each type of item</li>
<li><tt class="docutils literal">x</tt>:  number of items of each type that are packed</li>
<li><tt class="docutils literal">W</tt>:  sum of sizes of all items in the knapsack</li>
<li><tt class="docutils literal">P</tt>:  sum of profits of all items in the knapsack</li>
</ul>
</div>
<div class="section" id="scheduling-constraints">
<h2>4.2.6.7. Scheduling constraints<a class="headerlink" href="#scheduling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-91"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alternative</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Alternative constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the
optional tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments
and at most one can occur</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//alternative.mzn#L9-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-92"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt> , durations <tt class="docutils literal">d</tt> , and
resource requirements <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//cumulative.mzn#L14-L34">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-93"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt> , durations <tt class="docutils literal">d</tt> , and
resource requirements <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//cumulative_opt.mzn#L13-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-94"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//disjunctive.mzn#L13-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-95"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//disjunctive_opt.mzn#L14-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-96"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//disjunctive_strict.mzn#L12-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-97"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//disjunctive_strict_opt.mzn#L13-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-98"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">span</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Span constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the optional
tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//span.mzn#L8-L14">More…</a></p>
</div>
<div class="section" id="graph-constraints">
<h2>4.2.6.8. Graph constraints<a class="headerlink" href="#graph-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-99"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bounded_dpath</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt>  of weight <tt class="docutils literal">K</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the cost of the path</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bounded_path.mzn#L15-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-100"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bounded_dpath</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt>  of weight <tt class="docutils literal">K</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the cost of the path</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bounded_path.mzn#L36-L43">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-101"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bounded_path</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt>  of weight <tt class="docutils literal">K</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the cost of the path</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bounded_path.mzn#L60-L67">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-102"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">bounded_path</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt>  of weight <tt class="docutils literal">K</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the cost of the path</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//bounded_path.mzn#L82-L89">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-103"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">connected</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be connected.</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//connected.mzn#L32-L38">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-104"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">d_weighted_spanning_tree</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the set of edges <tt class="docutils literal">es</tt>  of a given directed graph to be a weighted spanning tree rooted at <tt class="docutils literal">r</tt>  of weight <tt class="docutils literal">W</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the weight of the tree</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//weighted_spanning_tree.mzn#L18-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-105"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dag</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a DAG.</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//dag.mzn#L12-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-106"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dconnected</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be connected.</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//connected.mzn#L14-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-107"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dpath</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//path.mzn#L22-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-108"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dpath</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//path.mzn#L40-L46">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-109"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dreachable</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be reachable from <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//reachable.mzn#L21-L27">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-110"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dreachable</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be reachable from <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//reachable.mzn#L38-L44">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-111"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dsteiner</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a weighted spanning tree rooted at <tt class="docutils literal">r</tt>  of weight <tt class="docutils literal">W</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the weight of the tree</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//steiner.mzn#L20-L31">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-112"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dtree</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be a tree rooted at <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//tree.mzn#L21-L27">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-113"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">dtree</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given directed graph to be at tree rooted at <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//tree.mzn#L38-L44">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-114"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">path</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//path.mzn#L62-L68">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-115"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">path</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be a path from <tt class="docutils literal">s</tt>  to <tt class="docutils literal">t</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">s</tt>  is the source node (which may be variable)
<tt class="docutils literal">t</tt>  is the dest node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//path.mzn#L80-L86">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-116"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">reachable</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be reachable from <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//reachable.mzn#L59-L65">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-117"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">reachable</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be reachable from <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//reachable.mzn#L76-L82">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-118"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">steiner</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the set of edges <tt class="docutils literal">es</tt>  of a given undirected graph to be a weighted spanning tree of weight <tt class="docutils literal">W</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the weight of the tree
*</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//steiner.mzn#L45-L56">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-119"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">subgraph</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains that <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  is a subgraph of a given directed graph.</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//subgraph.mzn#L16-L22">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-120"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">subgraph</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains that <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  is a subgraph of a given directed graph.</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//subgraph.mzn#L32-L38">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-121"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">tree</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be a tree rooted at <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//tree.mzn#L59-L65">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-122"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">tree</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">ns</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the subgraph <tt class="docutils literal">ns</tt>  and <tt class="docutils literal">es</tt>  of a given undirected graph to be at tree rooted at <tt class="docutils literal">r</tt> .</p>
<p><tt class="docutils literal">from</tt>  is the leaving node for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge
<tt class="docutils literal">r</tt>  is the root node (which may be variable)
<tt class="docutils literal">ns</tt>  is a Boolean for each node whether it is in the subgraph
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//tree.mzn#L76-L82">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-123"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">weighted_spanning_tree</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">es</span><span class="p">,</span><span class="s"></span>
<span class="s">                                 </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">K</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the set of edges <tt class="docutils literal">es</tt>  of a given undirected graph to be a weighted spanning tree of weight <tt class="docutils literal">W</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes in the given graph
<tt class="docutils literal">E</tt>  is the number of edges in the given graph
<tt class="docutils literal">from</tt>  is the leaving node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">to</tt>  is the entering node 1.. <tt class="docutils literal">N</tt>  for each edge
<tt class="docutils literal">w</tt>  is the weight of each edge
<tt class="docutils literal">es</tt>  is a Boolean for each edge whether it is in the subgraph
<tt class="docutils literal">K</tt>  is the weight of the tree
*</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//weighted_spanning_tree.mzn#L37-L43">More…</a></p>
</div>
<div class="section" id="extensional-constraints-table-regular-etc">
<h2>4.2.6.9. Extensional constraints (table, regular etc.)<a class="headerlink" href="#extensional-constraints-table-regular-etc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-124"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">cost_mdd</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">level</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">label</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cost</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">totalcost</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">x</tt>  defines a path in the cost MDD with total edge weight <tt class="docutils literal">totalcost</tt> .</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes, the root node is node 1
<tt class="docutils literal">level</tt>  is the level of each node, the root is level 1, T is level <tt class="docutils literal">length</tt> (x)+1
<tt class="docutils literal">E</tt>  is the number of edges
<tt class="docutils literal">from</tt>  is the leaving node (1.. <tt class="docutils literal">N</tt> )for each edge
<tt class="docutils literal">label</tt>  is the set of value of the x variable for each edge
<tt class="docutils literal">cost</tt>  is the cost for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge, where 0 = T node
<tt class="docutils literal">totalcost</tt>  is the total cost of the path defined by <tt class="docutils literal">x</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//cost_mdd.mzn#L17-L54">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-125"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">cost_regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">C</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the DFA of <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; 0.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).  We reserve state 0 to be an always failing state. Each edge has an associated cost <tt class="docutils literal">c</tt> ,
and <tt class="docutils literal">C</tt>  is the sum of costs taken on the accepting path for <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//cost_regular.mzn#L12-L40">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-126"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">mdd</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">level</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">label</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">x</tt>  defines a path from root to true node T through the (deterministic) MDD defined by</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes, the root node is node 1
<tt class="docutils literal">level</tt>  is the level of each node, the root is level 1, T is level <tt class="docutils literal">length</tt> (x)+1
<tt class="docutils literal">E</tt>  is the number of edges
<tt class="docutils literal">from</tt>  is the leaving node (1.. <tt class="docutils literal">N</tt> )for each edge
<tt class="docutils literal">label</tt>  is the set of values of the <tt class="docutils literal">x</tt>  variable for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge, where 0 = T node</p>
<p>The MDD must be deterministic, i.e., there cannot be two edges
with the same label leaving the same node.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//mdd.mzn#L17-L45">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-127"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">mdd_nondet</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">level</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">from</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">label</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">to</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">x</tt>  defines a path from root to true node T through the (nondeterministic) MDD defined by</p>
<p><tt class="docutils literal">N</tt>  is the number of nodes, the root node is node 1
<tt class="docutils literal">level</tt>  is the level of each node, the root is level 1, T is level <tt class="docutils literal">length</tt> (x)+1
<tt class="docutils literal">E</tt>  is the number of edges
<tt class="docutils literal">from</tt>  is the leaving node (1.. <tt class="docutils literal">N</tt> )for each edge
<tt class="docutils literal">label</tt>  is the set of values of the <tt class="docutils literal">x</tt>  variable for each edge
<tt class="docutils literal">to</tt>  is the entering node for each edge, where 0 = T node</p>
<p>The MDD can be nondeterministic, i.e., there can be two edges
with the same label leaving the same node.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//mdd_nondet.mzn#L17-L42">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-128"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the DFA of <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; 0.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).  We reserve state 0 to be an always failing state.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//regular.mzn#L11-L34">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-129"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the set <tt class="docutils literal">S</tt> )
is accepted by the DFA of <tt class="docutils literal">Q</tt>  states with input <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , <tt class="docutils literal">S</tt> ) -&gt; 0.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).  We reserve state 0 to be an always failing state.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//regular_set.mzn#L11-L34">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-130"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">string</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>   is accepted by the regular
expression <tt class="docutils literal">r</tt> . This constraint generates it’s DFA equivalent.</p>
<p>Regular expressions can use the following syntax:</p>
<ul class="simple">
<li>Selection:<ul>
<li>Concatenation: “12 34”, 12 followed by 34.
(Characters are assumed to be the part of the same number unless split
by syntax or whitespace.)</li>
<li>Union: “7|11”, a 7 or 11.</li>
<li>Groups: “7(6|8)”, a 7 followed by a 6 or an 8.</li>
<li>Wildcard: “.”, any value within the domain.</li>
<li>Classes: “[3-6 7]”, a 3,4,5,6, or 7.</li>
<li>Negated classes: “[^3 5]”, any value within the domain except for a 3 or a 5.</li>
</ul>
</li>
<li>Quantifiers:<ul>
<li>Asterisk: “12*”, 0 or more times a 12.</li>
<li>Question mark: “5?”, 0 or 1 times a 5. (optional)</li>
<li>Plus sign: “42+”, 1 or more time a 42.</li>
<li>Exact: “1{3}”, exactly 3 times a 1.</li>
<li>At least: “9{5,}”, 5 or more times a 9.</li>
<li>Between: “7{3,5}”, at least 3 times, but at most 5 times a 7.</li>
</ul>
</li>
</ul>
<p>Members of enumerated types can be used in place of any integer (e.g., “A B”,
A followed by B). Enumerated identifiers still use whitespace for concatenation.</p>
<div class="highlight-minizinc notranslate" id="index-131"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular_nfa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the NFA of <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; set of 1.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//regular_nfa.mzn#L13-L37">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-132"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular_nfa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range <tt class="docutils literal">S</tt> )
is accepted by the NFA of <tt class="docutils literal">Q</tt>  states with input <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , <tt class="docutils literal">S</tt> ) -&gt; set of 1.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//regular_nfa.mzn#L46-L73">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-133"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint <tt class="docutils literal">x</tt>  in <tt class="docutils literal">t</tt>  where we
consider each row in <tt class="docutils literal">t</tt>  to be a tuple and <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//table.mzn#L8-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-134"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint <tt class="docutils literal">x</tt>  in <tt class="docutils literal">t</tt>  where we
consider each row in <tt class="docutils literal">t</tt>  to be a tuple and <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//table.mzn#L19-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-135"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">neural_net</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">inputs</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">input_ids</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">outputs</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">output_ids</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">bias</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">edge_weight</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">edge_parent</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">first_edge</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="nv">NEURON_TYPE</span><span class="p">:</span><span class="s"> </span><span class="nv">neuron_type</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>constrain the output layer of a neural net to take the value defined by the input layer.
the arguments are
<tt class="docutils literal">inputs</tt> : an array of float variables
<tt class="docutils literal">input_ids</tt> : array[int] of node
<tt class="docutils literal">outputs</tt> : an array of float variables
<tt class="docutils literal">output_ids</tt> : array[int] of node
<tt class="docutils literal">bias</tt> : array[node] of float
<tt class="docutils literal">edge_weight</tt> : array[edge] of float (dummy one at end!)
<tt class="docutils literal">edge_parent</tt> : array[edge] of neuron (start neuron for edge)
<tt class="docutils literal">first_edge</tt> : array[node] of 1..m+1
<tt class="docutils literal">neuron_type</tt> : { NT_RELU, NT_STEP, NT_LINEAR, NT_SOFTPLUS }</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//neural_net.mzn#L20-L59">More…</a></p>
</div>
<div class="section" id="other-declarations">
<h2>4.2.6.10. Other declarations<a class="headerlink" href="#other-declarations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-136"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_max.mzn#L9-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-137"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_max.mzn#L16-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-138"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_max.mzn#L23-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-139"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_min.mzn#L10-L11">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-140"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_min.mzn#L17-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-141"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> $$</span><span class="nv">E</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$$</span><span class="nv">E</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//arg_min.mzn#L24-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-142"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">circuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of <tt class="docutils literal">x</tt>  to define a circuit where <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt>  means
that <tt class="docutils literal">j</tt>  is the successor of <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_circuit.mzn#L3-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-143"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjoint</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s1</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s2</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that sets <tt class="docutils literal">s1</tt>  and <tt class="docutils literal">s2</tt>  do not intersect.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_disjoint.mzn#L1-L2">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-144"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the maximum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//redefinitions-2.0.mzn#L25-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-145"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the maximum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//redefinitions-2.0.mzn#L36-L44">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-146"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_max_int.mzn#L1-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-147"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_max_bool.mzn#L1-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-148"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_max_float.mzn#L1-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-149"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_member_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-150"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_member_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-151"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_member_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-152"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_member_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-153"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the set <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_set_member.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-154"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the minimum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//redefinitions-2.0.mzn#L58-L66">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-155"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the minimum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//redefinitions-2.0.mzn#L47-L55">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-156"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_min_int.mzn#L1-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-157"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_min_bool.mzn#L1-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-158"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_arg_min_float.mzn#L1-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-159"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//network_flow.mzn#L14-L28">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc <tt class="docutils literal">i</tt>  connects node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-160"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow_cost</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">weight</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cost</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint with cost.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//network_flow.mzn#L39-L55">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc <tt class="docutils literal">i</tt>  connects node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">weight</tt>:  the unit cost of the flow through the arc.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
<li><tt class="docutils literal">cost</tt>:  the overall cost of the flow.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-161"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">partition_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">universe</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the sets in array <tt class="docutils literal">S</tt>  to partition the <tt class="docutils literal">universe</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_partition_set.mzn#L3-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-162"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nf">piecewise_linear</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">xi</span><span class="p">,</span><span class="s"></span>
<span class="s">                                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">vi</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Return a piecewise-linear interpolation
of the given point sequence as a function of <tt class="docutils literal">x</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//piecewise_linear.mzn#L8-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-163"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">piecewise_linear</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">xi</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">vi</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">y</tt> ( <tt class="docutils literal">x</tt> ) to be a piecewise-linear interpolation of
the provided point sequence.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_piecewise_linear.mzn#L20-L29">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-164"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the image of function <tt class="docutils literal">x</tt>  (represented as an array) on set
of values <tt class="docutils literal">s</tt>  is <tt class="docutils literal">t</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//range.mzn#L9-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-165"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the image of function <tt class="docutils literal">x</tt>  (represented as an array) on set
of values <tt class="docutils literal">s</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//range_fn.mzn#L8-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-166"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">t</tt>  for all <tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//roots.mzn#L7-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-167"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns <tt class="docutils literal">s</tt>  such that <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">t</tt>  for all <tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//roots_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-168"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sliding_sum</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">low</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">up</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">seq</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that in each subsequence <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt> ], …, <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt>  + <tt class="docutils literal">seq</tt>  - 1] the sum of the
values belongs to the interval [ <tt class="docutils literal">low</tt> , <tt class="docutils literal">up</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_sliding_sum.mzn#L1-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-169"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">subcircuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of <tt class="docutils literal">x</tt>  to define a subcircuit where <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt>
means that <tt class="docutils literal">j</tt>  is the successor of <tt class="docutils literal">i</tt>  and <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">i</tt>  means that <tt class="docutils literal">i</tt>
is not in the circuit.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_subcircuit.mzn#L3-L48">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-170"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sum_pred</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">sets</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cs</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the sum of <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">i1</tt> ].. <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">iN</tt> ] equals <tt class="docutils literal">s</tt> ,
where <tt class="docutils literal">i1</tt> .. <tt class="docutils literal">iN</tt>  are the elements of the <tt class="docutils literal">i</tt>  th set in <tt class="docutils literal">sets</tt> .</p>
<p>Nb: not called ‘sum’ as in the constraints catalog because ‘sum’ is a
MiniZinc built-in function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_sum_pred.mzn#L1-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-171"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">sum_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ws</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the sum of the weights <tt class="docutils literal">ws</tt> [ <tt class="docutils literal">i1</tt> ].. <tt class="docutils literal">ws</tt> [ <tt class="docutils literal">iN</tt> ] equals <tt class="docutils literal">s</tt> ,
where <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i1</tt> ].. <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">iN</tt> ] are the elements appearing in set <tt class="docutils literal">x</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.3.2/share/minizinc/std//fzn_sum_set.mzn#L1-L3">More…</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lib-gecode.html" class="btn btn-neutral float-right" title="4.2.7. Additional declarations for Gecode" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lib-flatzinc.html" class="btn btn-neutral" title="4.2.5. FlatZinc builtins" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.3.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
