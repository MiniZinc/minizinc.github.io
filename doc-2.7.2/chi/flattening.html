

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.8. FlatZinc和展平 &mdash; The MiniZinc Handbook 2.7.2</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/flattening.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. User Manual" href="part_3_user_manual.html" />
    <link rel="prev" title="2.7. 在MiniZinc中对布尔可满足性问题建模" href="sat.html" />
    <link rel="apple-touch-icon" sizes="57x57" href="static/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="static/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="static/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="static/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="static/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="static/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="static/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="static/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="static/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="static/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="static/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon/favicon-16x16.png">
    <link rel="manifest" href="static/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="static/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.7.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. Minizinc 指南</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. MiniZinc基本模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="modelling2.html">2.2. 更多复杂模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. 谓词和函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. 选项类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. 搜索</a></li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. MiniZinc中的有效建模实践</a></li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. 在MiniZinc中对布尔可满足性问题建模</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.8. FlatZinc和展平</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">2.8.1. 展平表达式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.8.1.1. 简化和求值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sec-flat-sub">2.8.1.2. 定义子表达式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sec-flat-fzn">2.8.1.3. FlatZinc约束形式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2.8.1.4. 边界分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.8.1.5. 目标函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">2.8.2. 线性表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-unroll">2.8.3. 展开表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">2.8.4. 数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">2.8.5. 具体化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">2.8.6. 谓词</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let">2.8.7. Let表达式</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_2_tutorial.html">2. Minizinc 指南</a> &raquo;</li>
        
      <li>2.8. FlatZinc和展平</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="flatzinc">
<span id="sec-flattening"></span><h1>2.8. FlatZinc和展平<a class="headerlink" href="#flatzinc" title="Permalink to this headline">¶</a></h1>
<p>约束求解器不会直接支持MiniZinc模型.为了运行一个MiniZinc模型,它被翻译成一个MiniZinc的简单子集叫FlatZinc.
FlatZinc反映了大多数约束求解器只会求解具有 <span class="math notranslate nohighlight">\(\bar{exists} c_1 \wedge \cdots \wedge c_m\)</span> 的满足问题
或者有 <span class="math notranslate nohighlight">\(\text{minimize } z \text{ subject to }  c_1 \wedge \cdots \wedge c_m\)</span> 的优化问题, 其中
<span class="math notranslate nohighlight">\(c_i\)</span> 是基本的约束而 <span class="math notranslate nohighlight">\(z\)</span> 是一个具有某些限定形式的整型或者浮点表达式.</p>
<p id="index-0"><tt class="docutils literal">minizinc</tt> 工具包含了MiniZinc <em>编译器</em> ,它可以用一个MiniZinc模型和数据文件来创建
一个展平后的FlatZinc模型,它等价于给定数据的MiniZinc模型表达为之前提到的受限制的形式.
通常来说构建一个给求解器的FlatZinc模型是对用户隐藏的,不过你也可以通过以下命令查看结合
数据 <tt class="docutils literal">data.dzn</tt> 来展平一个模型 <tt class="docutils literal">model.mzn</tt> 的结果:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>minizinc -c model.mzn data.dzn
</pre></div>
</div>
<p>这会创建一个FlatZinc模型叫 <tt class="docutils literal">model.fzn</tt> .</p>
<p>在这一章中我们探索把MiniZinc翻译成FlatZinc的过程.</p>
<div class="section" id="id1">
<h2>2.8.1. 展平表达式<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>底层求解器的限制意味着复杂的MiniZinc表达式需要被 <em>展平</em> 为内部不具有更复杂结构项的基本约束的合取式.</p>
<p>思考以下保证两个在长方形箱子的两个圆不会重叠的模型:</p>
<div class="literal-block-wrapper docutils container" id="fig-nonoverlap">
<div class="code-block-caption"><span class="caption-number">Listing 2.8.1 </span><span class="caption-text">两个不会重叠的圆的模型 (<a class="reference download internal" href="downloads/cnonoverlap.mzn" download=""><tt class="xref download docutils literal">cnonoverlap.mzn</tt></a>).</span><a class="headerlink" href="#fig-nonoverlap" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">width</span><span class="p">;</span><span class="s">          </span><span class="c">% 包含圆的长方形的宽</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">height</span><span class="p">;</span><span class="s">         </span><span class="c">% 包含圆的长方形的高</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">r1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r1</span><span class="o">..</span><span class="nv">width</span><span class="o">-</span><span class="nv">r1</span><span class="p">:</span><span class="s">  </span><span class="nv">x1</span><span class="p">;</span><span class="s"> </span><span class="c">% (x1,y1) 是第一个圆的中心</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r1</span><span class="o">..</span><span class="nv">height</span><span class="o">-</span><span class="nv">r1</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">r2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r2</span><span class="o">..</span><span class="nv">width</span><span class="o">-</span><span class="nv">r2</span><span class="p">:</span><span class="s">  </span><span class="nv">x2</span><span class="p">;</span><span class="s"> </span><span class="c">% (x2,y2) 是第二个圆的中心</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">r2</span><span class="o">..</span><span class="nv">height</span><span class="o">-</span><span class="nv">r2</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="s">                       </span><span class="c">% 中心之间至少有r1 + r2的距离</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x1</span><span class="o">-</span><span class="nv">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">x1</span><span class="o">-</span><span class="nv">x2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="nv">y1</span><span class="o">-</span><span class="nv">y2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">y1</span><span class="o">-</span><span class="nv">y2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>2.8.1.1. 简化和求值<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>给定数据文件</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">width</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">10.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">height</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">8.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">r1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">r2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3.0</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>转换到FlatZinc首先通过替换所有参数为它们的值来简化模型, 然后求出所有取值已经固定的表达式的值.
在这步简化后参数的值将不再需要.
一个例外是大型数组的参数值.如果它们被适用多于一次,那么为了避免重复大的表达式这个参数会被保留.</p>
<p>在简化后, <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.8.1</span></a> 的模型的变量和参数声明部分变为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> .. </span><span class="m">8.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> .. </span><span class="m">6.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> .. </span><span class="m">7.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> .. </span><span class="m">5.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="sec-flat-sub">
<span id="id3"></span><h3>2.8.1.2. 定义子表达式<a class="headerlink" href="#sec-flat-sub" title="Permalink to this headline">¶</a></h3>
<p>现在没有约束求解器可以直接处理像在 <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.8.1</span></a> 里复杂的约束表达式.
作为替代,我们可以命名表达式中的每一个子表达式,我们创建约束来构建及代表子表达式的数值.
让我们来看看约束表达式的子表达式. <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="s"></span></code> 是一个子表达式, 如果我们将它命名为
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"></span></code> 我们可以定义它为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span></code> . 注意到这个表达式
只在模型中出现两次. 我们只需要构建这个值一次,然后我们可以重复使用它. 这就是 <em>共同子表达式消除</em> .
子表达式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">)</span><span class="s"></span></code> 可以命名为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code> , 而我们可以定义它为
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span></code> . 我们可以命名 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span></code>
和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span></code> 最后 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span></code> .
不等约束本身则变成 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">25.0</span><span class="p">;</span><span class="s"></span></code> 因为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">(</span><span class="nv">r1</span><span class="o">+</span><span class="nv">r2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">r1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">r2</span><span class="p">)</span><span class="s"></span></code> 计算出结果为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">25.0</span><span class="s"></span></code> .
于是这个约束被展平为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">25.0</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="sec-flat-fzn">
<span id="id4"></span><h3>2.8.1.3. FlatZinc约束形式<a class="headerlink" href="#sec-flat-fzn" title="Permalink to this headline">¶</a></h3>
<p>展平的最后步骤是把约束的形式转换成标准的FlatZinc形式,它总是以 <span class="math notranslate nohighlight">\(p(a_1, \ldots, a_n)\)</span> 的形式出现.
其中的 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> 是某个基础约束, <span class="math notranslate nohighlight">\(a_1, \ldots, a_n\)</span> 是参数. FlatZinc尝试使用最少的
不同约束形式. 所以 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="s"></span></code> 首先尝试重写为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">x2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"></span></code>
然后使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">float_plus</span><span class="s"></span></code> 输出基本的约束. 得出的约束形式如下:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">x2</span><span class="p">,</span><span class="s"> </span><span class="nv">x1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">y2</span><span class="p">,</span><span class="s"> </span><span class="nv">y1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT02</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>2.8.1.4. 边界分析<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>我们仍然缺少一项,声明引入的变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"></span></code> , …,
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT05</span><span class="s"></span></code> . 这些可以被声明为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="s"></span></code> . 不过为了令求解器的任务更简单,
MiniZinc尝试通过简单的分析确定新引入变量的上界和下界. 比如因为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">x2</span><span class="s"></span></code>
和 <span class="math notranslate nohighlight">\(2.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x1</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 8.0\)</span> 还有 <span class="math notranslate nohighlight">\(3.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x2</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 7.0\)</span>, 所以可以得出 <span class="math notranslate nohighlight">\(- 5.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT01</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 5.0\)</span>
然后我们可以看到 <span class="math notranslate nohighlight">\(-25.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 25.0\)</span> (尽管注意到如果我们发现
相乘实际上是平方,我们可以给出更精确的边界 <span class="math notranslate nohighlight">\(0.0 \leq\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT02</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\leq 25.0\)</span> ).</p>
<p>细心的读者会发现在 <a class="reference internal" href="#sec-flat-sub"><span class="std std-ref">定义子表达式</span></a> 和 <a class="reference internal" href="#sec-flat-fzn"><span class="std std-ref">FlatZinc约束形式</span></a> 里约束的展平形式的一点不同.
在后面没有非等约束. 因为一元的不等式可以完全被一个变量的边界表示出来,不等关系可以令 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">FLOAT05</span><span class="s"></span></code>
的下界变为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">25.0</span><span class="s"></span></code> , 然后这会变得冗余. 最后 <a class="reference internal" href="#fig-nonoverlap"><span class="std std-numref">Listing 2.8.1</span></a> 的展平后形式是:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% 变量</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> .. </span><span class="m">8.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2.0</span><span class="s"> .. </span><span class="m">6.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> .. </span><span class="m">7.0</span><span class="p">:</span><span class="s"> </span><span class="nv">x2</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3.0</span><span class="s"> .. </span><span class="m">5.0</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="c">%</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">5.0</span><span class="o">..</span><span class="m">5.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT01</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">25.0</span><span class="o">..</span><span class="m">25.0</span><span class="p">:</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">3.0</span><span class="o">..</span><span class="m">3.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT03</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9.0</span><span class="o">..</span><span class="m">9.0</span><span class="p">:</span><span class="s">   </span><span class="nv">FLOAT04</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">25.0</span><span class="o">..</span><span class="m">34.0</span><span class="p">:</span><span class="s">  </span><span class="nv">FLOAT05</span><span class="p">;</span><span class="s"></span>
<span class="c">% 约束</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">x2</span><span class="p">,</span><span class="s"> </span><span class="nv">x1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">y2</span><span class="p">,</span><span class="s"> </span><span class="nv">y1</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_plus</span><span class="p">(</span><span class="nv">FLOAT02</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT01</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">float_times</span><span class="p">(</span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT03</span><span class="p">,</span><span class="s"> </span><span class="nv">FLOAT04</span><span class="p">);</span><span class="s"></span>
<span class="c">%</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>2.8.1.5. 目标函数<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>MiniZinc 就像展平约束一样, 展平最小化和最大化目标函数. 跟其他表达式一样, 目标表达式
被展平时创建一个变量. 在FlatZinc输出求解项永远是单一变量. 看一下例子 <a class="reference internal" href="#sec-let"><span class="std std-ref">Let表达式</span></a> .</p>
</div>
</div>
<div class="section" id="id7">
<h2>2.8.2. 线性表达式<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>约束的一个最重要的而广泛用于建模的形式是线性约束</p>
<div class="math notranslate nohighlight">
\[\begin{split}a_1 x_1 + \cdots + a_n x_n \begin{array}[c]{c} = \\ \leq \\ &lt; \end{array} a_0\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(a_i\)</span> 是整数或者浮点数约束, 而 <span class="math notranslate nohighlight">\(x_i\)</span> 是整数或者浮点数变量.
它们非常有表达能力,同时也是(整数)线性规划约束求解器唯一支持的形式.
从MiniZinc到FlatZinc的翻译器尝试创建线性约束, 而不是把线性约束变成许多子表达式.</p>
<div class="literal-block-wrapper docutils container" id="fig-lflat">
<div class="code-block-caption"><span class="caption-number">Listing 2.8.2 </span><span class="caption-text">说明线性约束展平的MiniZinc模型 (<a class="reference download internal" href="downloads/linear.mzn" download=""><tt class="xref download docutils literal">linear.mzn</tt></a>).</span><a class="headerlink" href="#fig-lflat" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s">       </span><span class="nv">d</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">10</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="o">..</span><span class="m">6</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">3</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s">  </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">3</span><span class="o">*</span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">19</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">4</span><span class="o">*</span><span class="nv">d</span><span class="p">;</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>考虑在 <a class="reference internal" href="#fig-lflat"><span class="std std-numref">Listing 2.8.2</span></a> 中的模型. 这里并没有为所有子表达式 <span class="math notranslate nohighlight">\(3*x\)</span>, <span class="math notranslate nohighlight">\(3*x - y\)</span> , <span class="math notranslate nohighlight">\(x * z\)</span> , <span class="math notranslate nohighlight">\(3*x - y + x*z\)</span> ,
<span class="math notranslate nohighlight">\(x + y + z\)</span> , <span class="math notranslate nohighlight">\(d * (x + y + z)\)</span> , <span class="math notranslate nohighlight">\(19 + d * (x + y + z)\)</span> ,
和 <span class="math notranslate nohighlight">\(19 + d * (x + y + z) - 4*d\)</span> 创建一个变量. 这里的翻译在创建一个FlatZinc约束时, 会尝试创建一个尽可能记录大部分原约束内容的线性约束.</p>
<p>展平会创建线性表达式并将其视为一个单位, 而不视为每个字表达是构建中间变量.这也使创建的表达式简单化.
从约束中抽取出线性表达式为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">80</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4</span><span class="o">*</span><span class="nv">x</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">23</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>注意到 <em>非线性表达式</em> <span class="math notranslate nohighlight">\(x \times z\)</span> 是如何被抽取出来作为一个新的子表达式并赋予名字的,
与此同时剩下的项会被收集起来从而使每个变量只出现一次 (的确变量 <span class="math notranslate nohighlight">\(y\)</span> 的项被移除了)</p>
<p>最后每个约束被写到FlatZinc形式, 从而得到:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">80</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le</span><span class="p">([</span><span class="m">1,4</span><span class="p">,</span><span class="m">1</span><span class="p">],[</span><span class="nv">INT01</span><span class="p">,</span><span class="nv">x</span><span class="p">,</span><span class="nv">z</span><span class="p">],</span><span class="m">23</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_times</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">z</span><span class="p">,</span><span class="nv">INT01</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="sec-unroll">
<span id="id8"></span><h2>2.8.3. 展开表达式<a class="headerlink" href="#sec-unroll" title="Permalink to this headline">¶</a></h2>
<p>大多数的模型需要创建一些基于输入数据的约束.
MiniZinc通过数组类型,列表和列生成解析还有聚合函数来支持这些模型.</p>
<p>考虑以下从生产调度例子 <a class="reference internal" href="modelling2.html#ex-prod-planning"><span class="std std-numref">Listing 2.2.2</span></a> 中出现的聚合函数表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"></span>
<span class="s">                     </span><span class="p">(</span><span class="nb">min</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"></span>
<span class="s">                                     </span><span class="p">(</span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]));</span><span class="s"></span>
</pre></div>
</div>
<p>由于这用到生成器语法,我们可以把它重写成可以被编译器处理的相等的形式:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="p">([</span><span class="s"> </span><span class="nb">min</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"></span>
<span class="s">                           </span><span class="p">|</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">]</span><span class="gr">)</span><span class="s"></span>
<span class="s">                     </span><span class="p">|</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>给定数据</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">nproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="nv">nresources</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="nv">capacity</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">4000</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">2000</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">];</span><span class="s"></span>
<span class="nv">consumption</span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">250</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="p">,</span><span class="s"> </span><span class="m">100</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="p">|</span><span class="s"> </span><span class="m">200</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
<p>这首先创建 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code> 的数组</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"></span>
<span class="s">                           </span><span class="p">|</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
<p>也就是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">16</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">26</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">]</span><span class="s"></span></code> 然后计算最小值为3. 它之后为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code> 建立相同的数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">20</span><span class="p">,</span><span class="s"> </span><span class="m">13</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">]</span><span class="s"></span></code> ,
并计算最小的数值为3. 然后创建数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">]</span><span class="s"></span></code> 并计算最大值为3. 在FlatZinc里面没有
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> 的表示, 这种通过计算数值3的方法会被用来代替 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> .</p>
<p>在约束模型中最常见的聚合表达式是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> . Forall表达式会被展开成为多个约束.</p>
<p>考虑以下在SEND-MORE-MONEY例子 <a class="reference internal" href="modelling2.html#ex-smm"><span class="std std-numref">Listing 2.2.4</span></a> 中使用预设的
分解 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 出现的MiniZinc片段.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> 表达式为每一对需要满足 <span class="math notranslate nohighlight">\(i &lt; j\)</span> 的 <span class="math notranslate nohighlight">\(i, j\)</span> 创建一个约束,
所以创建</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="s"> </span><span class="c">% S != E</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">3</span><span class="p">];</span><span class="s"> </span><span class="c">% S != N</span><span class="s"></span>
<span class="s">...</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"> </span><span class="c">% S != Y</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">3</span><span class="p">];</span><span class="s"> </span><span class="c">% E != N</span><span class="s"></span>
<span class="s">...</span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"> </span><span class="c">% R != Y</span><span class="s"></span>
</pre></div>
</div>
<p>在FlatZinc中形成</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">N</span><span class="p">);</span><span class="s"></span>
<span class="s">...</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">Y</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">);</span><span class="s"></span>
<span class="s">...</span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq</span><span class="p">(</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>注意到临时的数组变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> 是如何在FlatZinc的输出中被原来的变量替换的.</p>
</div>
<div class="section" id="id9">
<h2>2.8.4. 数组<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>一维变量在MiniZinc中可以有任意的下标,只要它们是相邻的整数.
在FlatZinc所有数组都被 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">1</span><span class="o">..</span><span class="nv">l</span><span class="s"></span></code> 标注, 其中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">l</span><span class="s"></span></code> 是数组的长度.
这意味着数组查询时需要被转换成FlatZinc下标的形式.</p>
<p>考虑以下MiniZinc模型来使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 个1kg砝码来平衡一个长为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">l2</span><span class="s"></span></code> 的跷跷板, 其中上面有一个重为
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">cw</span><span class="s"></span></code> kg小孩.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s">                               </span><span class="c">% 小孩重量</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l2</span><span class="p">;</span><span class="s">                               </span><span class="c">% 一半跷跷板长度</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">;</span><span class="s">                                </span><span class="c">% 1kg砝码的数量</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">m</span><span class="p">,</span><span class="nv">cw</span><span class="p">):</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"> </span><span class="c">% 在每个点的重量</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">;</span><span class="s">                        </span><span class="c">% 孩子的位置</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">)(</span><span class="nv">i</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"> </span><span class="c">% 平衡</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="o">-</span><span class="nv">l2</span><span class="o">..</span><span class="nv">l2</span><span class="p">)(</span><span class="nv">w</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">m</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s"> </span><span class="c">% 所有使用的砝码</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">cw</span><span class="p">;</span><span class="s">                  </span><span class="c">% 孩子在位置p</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>给定 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">cw</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code>, <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">l2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code>, 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="s"></span></code> , 展开可以产生约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">0</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>不过FlatZinc坚持 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> 数组从下标1开始.
这意味着我们需要重写所有数组获取来使用新的下标数值.
对于固定值数组查找这很简单,对于变量值数组查找我们可能需要创建一个新的变量.
以上公式的结果为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">0</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="o">*</span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="nv">INT01</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT01</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>最后我们重写约束成FlatZinc的形式. 注意到变量数组下标查找的形式是如何映射到 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">array_var_int_element</span><span class="s"></span></code> 上的.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">:</span><span class="s"> </span><span class="nv">INT01</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">],</span><span class="s"> </span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">w</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">4</span><span class="p">],</span><span class="nv">w</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="m">5</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_var_int_element</span><span class="p">(</span><span class="nv">INT01</span><span class="p">,</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT01</span><span class="p">,</span><span class="s"> </span><span class="nv">p</span><span class="p">],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>MiniZinc支持多维数组,但是(目前来说)FlatZinc只支持单维度数组.
这意味着多维度数组必须映射到单维度数组上,而且多维度数组访问必须映射到
单维度数组访问.</p>
<p>考虑在有限元平面模型 <a class="reference internal" href="modelling2.html#ex-laplace"><span class="std std-numref">Listing 2.2.1</span></a>: 的Laplace等式约束:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">HEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">h</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">h</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">WIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">w</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s">  </span>
<span class="kt">array</span><span class="p">[</span><span class="nv">HEIGHT</span><span class="p">,</span><span class="nv">WIDTH</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% 在点（i,j）处的温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">left</span><span class="p">;</span><span class="s">   </span><span class="c">% 左侧温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">right</span><span class="p">;</span><span class="s">  </span><span class="c">% 右侧温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">top</span><span class="p">;</span><span class="s">    </span><span class="c">% 顶部温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">bottom</span><span class="p">;</span><span class="s"> </span><span class="c">% 底部温度</span><span class="s"></span>

<span class="c">% 拉普拉斯方程：每一个内部点温度是它相邻点的平均值</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="s"></span>
<span class="s">              </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>假设 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">h</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> ,这会创建约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="m">4,0</span><span class="o">..</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% temperature at point (i,j)</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,4</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,4</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,0</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">3,3</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3,4</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>25个元素的2维数组被转换成一维数组,而且下标也会相应改变: 所以 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> 下标会变成
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">]</span><span class="s"></span></code> .</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">25</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">10</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">11</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">15</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">12</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">16</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">22</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">23</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="m">19</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">14</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">18</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">24</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">20</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>2.8.5. 具体化<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p id="index-1">FlatZinc模型包含了只有变量和参数声明,和一系列原始的约束. 所以当我们在MiniZinc用
布尔连接符而不是析取式来建模时,需要进行一些处理.
处理使用连接符而不只是析取式来构建的复杂公式,其核心的方法是具体化.
具体化一个约束 <span class="math notranslate nohighlight">\(c\)</span> 创建新的约束等价于 <span class="math notranslate nohighlight">\(b \leftrightarrow c\)</span> ,
即如果约束满足则布尔变量 <span class="math notranslate nohighlight">\(b\)</span> 的值是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">true</span><span class="s"></span></code> , 否则为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">false</span><span class="s"></span></code> .</p>
<p>当我们有能力 <em>具体化</em> 约束,对待复杂公式的方式跟数学表达式并无不同. 我们为子表达式创建了一个名称和一个展平的约束来约束子表达式的数值.</p>
<p>考虑以下任务调度例子 <a class="reference internal" href="modelling2.html#ex-jobshop"><span class="std std-numref">Listing 2.2.8</span></a> 中出现在约束表达式:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="c">%% 保证任务之间没有重叠</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">tasks</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">jobs</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>对于数据文件</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">jobs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="nv">tasks</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">3</span><span class="p">;</span><span class="s"></span>
<span class="nv">d</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="p">|]</span><span class="s"></span>
</pre></div>
</div>
<p>然后展开过程生成</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>具体化在析取式中出现的约束创建新的布尔变量来定义每个表达式的数值.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2,1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">23</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL02</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,1</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL04</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,2</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,2</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL06</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2,3</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1,3</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>每个基础的约束现在会映射到FlatZinc形式下.
注意到二维数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> 是如何映射到一维数组里面的.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">23</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">4</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">4</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">5</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">6</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_le_reif</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">s</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">6</span><span class="p">]],</span><span class="s"> </span><span class="o">-</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL02</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL03</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL04</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL05</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL06</span><span class="p">],</span><span class="s"> </span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_lin_le_reif</span><span class="s"></span></code> 是线性约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_lin_le</span><span class="s"></span></code> 的具体化形式.</p>
<p>大多数FlatZinc基本约束 <span class="math notranslate nohighlight">\(p(\bar{x})\)</span> 有一个具体化形式 <span class="math notranslate nohighlight">\(\mathit{p\_reif}(\bar{x},b)\)</span> ,
它利用最后额外的参数 <span class="math notranslate nohighlight">\(b\)</span> 来定义一个约束 <span class="math notranslate nohighlight">\(b \leftrightarrow p(\bar{x})\)</span> .
定义像 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_plus</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">int_plus</span><span class="s"></span></code> 的函数式关系的FlatZinc基本约束
不需要支持具体化. 反而,有结果的函数的等式被具体化了.</p>
<p>具体化的另外一个重要作用出现在当我们使用强制转换函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> (可能是显式地或者隐式地把布尔表达式使用成整数表达式使用). 平整过程将创建一个布尔变量来保存一个布尔表达式参数,
以及一个整型变量 (限制到 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="s"></span></code> )来保存这个数值.</p>
<p>考虑 <a class="reference internal" href="modelling2.html#ex-magic-series"><span class="std std-numref">Listing 2.2.12</span></a> 中的魔术序列问题.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">))));</span><span class="s"></span>
</pre></div>
</div>
<p>给定 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"></span></code> , 展开创造了</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>和展平创造了</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL01</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL03</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL05</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">BOOL07</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT02</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT04</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT06</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">INT08</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">INT02</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT04</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">INT06</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">INT08</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>最后的FlatZinc形式是</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">BOOL07</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT02</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT04</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT06</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">INT08</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_eq_reif</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL01</span><span class="p">,</span><span class="s"> </span><span class="nv">INT02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL03</span><span class="p">,</span><span class="s"> </span><span class="nv">INT04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL05</span><span class="p">,</span><span class="s"> </span><span class="nv">INT06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">BOOL07</span><span class="p">,</span><span class="s"> </span><span class="nv">INT08</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT02</span><span class="p">,</span><span class="s"> </span><span class="nv">INT04</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">1</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_lin_eq</span><span class="p">([</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">],</span><span class="s"> </span><span class="p">[</span><span class="nv">INT06</span><span class="p">,</span><span class="s"> </span><span class="nv">INT08</span><span class="p">,</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="m">2</span><span class="p">]],</span><span class="s"> </span><span class="m">0</span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>2.8.6. 谓词<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>MiniZinc支持许多不同求解器的的一个重要的因素是全局约束 (还有真正的FlatZinc约束)可以根据不同的
求解器专业化.</p>
<p>每一个求解器生命一个谓词有时会,但有时并不会提供具体的定义. 举个例子一个求解器有一个
内建的全局 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 谓词,会包含定义</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>在全局约束库中,同时一个求解器预设的分解会有定义</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="kt">array</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">x</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">x</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>谓词调用 <span class="math notranslate nohighlight">\(p(\bar{t})\)</span> 在平整时, 首先为每个参数项 <span class="math notranslate nohighlight">\(t_i\)</span> 创建对应变量 <span class="math notranslate nohighlight">\(v_i\)</span> .
如果谓词没有定义我们只需要使用创建的参数 <span class="math notranslate nohighlight">\(p(\bar{v})\)</span> 来调用谓词. 如果一个谓词
有一个定义 <span class="math notranslate nohighlight">\(p(\bar{x}) = \phi(\bar{x})\)</span> 然后我们将用谓词的定义来替换这个谓词调用 <span class="math notranslate nohighlight">\(p(\bar{t})\)</span> 当中形式参数被替换为对应的参数变量, 即 <span class="math notranslate nohighlight">\(\phi(\bar{v})\)</span>.
注意到如果一个谓词调用 <span class="math notranslate nohighlight">\(p(\bar{t})\)</span> 出现在具体化位置而且它没有定义,我们则
检查我们适用这个谓词的具体化版本 <span class="math notranslate nohighlight">\(\mathit{p\_reif}(\bar{x},b)\)</span> .</p>
<p>考虑在SEND-MORE-MONEY例子 <a class="reference internal" href="modelling2.html#ex-smm"><span class="std std-numref">Listing 2.2.4</span></a> 中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 约束的:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>如果这个求解器有一个内建的 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 我们只需要为这个参数创建一个新的变量, 然后在调用时替换它.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>注意到边界分析尝试在新的数组变量上找到一个紧的边界. 建造这个数组参数的理由就是,如果我们中使用
相同的数组两次,FlatZinc求解器不会创建它两次. 在这种情况下因为它不是使用两次,后面的转换会把 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> 替换成它的定义.</p>
<p>如果求解器使用预设的定义 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 呢?
然后变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> 会正常地定义,谓词调用会被替换为一个当中变量被重命名的版本, 其中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">v</span><span class="s"></span></code> 替换了形式参数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code>.
结果的程序是</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)(</span><span class="nv">v</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>我们可以在 <a class="reference internal" href="#sec-unroll"><span class="std std-ref">展开表达式</span></a> 中看到.</p>
<p>考虑到以下约束, 其中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 在一个具体化位置出现.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">])</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nf">alldifferent</span><span class="p">([</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>如果求解器有 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">alldifferent</span><span class="s"></span></code> 的具体化形式, 这将会被展平为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent_reif</span><span class="p">([</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">],</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">alldifferent_reif</span><span class="p">([</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">],</span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">],</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>适用这个预设的分解,谓词替换会首先创建</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">];</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="p">)(</span><span class="nv">v1</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v1</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="o">&lt;</span><span class="nv">j</span><span class="p">)(</span><span class="nv">v2</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v2</span><span class="p">[</span><span class="nv">j</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>它最终会展平成FlatZinc形式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">BOOL01</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">C</span><span class="p">,</span><span class="nv">BOOL03</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_and</span><span class="p">([</span><span class="nv">BOOL01</span><span class="p">,</span><span class="nv">BOOL02</span><span class="p">,</span><span class="nv">BOOL03</span><span class="p">],</span><span class="nv">BOOL04</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">BOOL05</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">int_neq_reif</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">BOOL06</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_and</span><span class="p">([</span><span class="nv">BOOL03</span><span class="p">,</span><span class="nv">BOOL05</span><span class="p">,</span><span class="nv">BOOL06</span><span class="p">],</span><span class="nv">BOOL07</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nf">array_bool_or</span><span class="p">([</span><span class="nv">BOOL04</span><span class="p">,</span><span class="nv">BOOL07</span><span class="p">],</span><span class="l">true</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>注意到共同子表达式消除是如何利用具体化不等式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">B</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">C</span><span class="s"></span></code> 的.
(虽然有一个更好的转换把共同约束提升到最顶层的合取式中)</p>
</div>
<div class="section" id="let">
<span id="sec-let"></span><h2>2.8.7. Let表达式<a class="headerlink" href="#let" title="Permalink to this headline">¶</a></h2>
<p>Let表达式是MiniZinc中可用于引入新的变量的非常强大的工具.
在展平时,let表达式被转换成变量和约束声明. 这个MiniZinc的关系语义意味着这些约束必须像在第一个包含的布尔表达式中出现.</p>
<p>let表达式的一个重要特征是每一次它们被使用时它们都创建新的变量.</p>
<p>考虑一下展平的代码</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="nv">u</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="nv">v</span><span class="p">);</span><span class="s"></span>
<span class="k">predicate</span><span class="s"> </span><span class="nf">even</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"> </span><span class="o">=</span><span class="s"></span>
<span class="s">          </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>首先谓词调用被他们的定义取代.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>然后let变量会另外被重命名</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y1</span><span class="p">)</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">           </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y2</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>最后变量声明会被抽取到第一层</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y1</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">u</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y1</span><span class="s"> </span><span class="o">\/</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y2</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>一旦let表达式被清除我们可以像之前那样展平.</p>
<p>记住let表达式可以定义新引入的变量 (对某些参数的确需要这样做).
这些隐式地定义了必须满足的约束.</p>
<p>考虑婚礼座位问题 <a class="reference internal" href="predicates.html#ex-wedding2"><span class="std std-numref">Listing 2.3.10</span></a> 的复杂的目标函数.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">h</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Hatreds</span><span class="p">)(</span><span class="s"></span>
<span class="s">      </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s">  </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h1</span><span class="p">[</span><span class="nv">h</span><span class="p">]],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h2</span><span class="p">[</span><span class="nv">h</span><span class="p">]],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">      </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>为了简介我们假设只使用前两个相互敌视的人,所以</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Hatreds</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">groom</span><span class="p">,</span><span class="s"> </span><span class="nv">carol</span><span class="p">];</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">clara</span><span class="p">,</span><span class="s"> </span><span class="nv">bestman</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>展平的第一步是展开 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">sum</span><span class="s"></span></code> 表达式,给定(为了简洁我们保留客人名字和参数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Seats</span><span class="s"></span></code> ,
在实际中他们会被他们的定义取代):</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">))</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>然后每一个在let表达式的新变量会被分别命名为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same1</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">))</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">],</span><span class="s"></span>
<span class="s">             </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">       </span><span class="nv">same2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same2</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">));</span><span class="s"></span>
</pre></div>
</div>
<p>在let表达式的变量会被抽取到第一层,并且定义约束会被抽取到正确的层(在这里是最顶层).</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p11</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p21</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">clara</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">same1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p21</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">);</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="s"> </span><span class="nv">p12</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="s"> </span><span class="nv">p22</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">same2</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">carol</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">bestman</span><span class="p">];</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">same2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p22</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="gr">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"></span>
<span class="s">      </span><span class="nv">same1</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same1</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p11</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p21</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="gr">)</span><span class="s"></span>
<span class="s">      </span><span class="o">+</span><span class="s"></span>
<span class="s">      </span><span class="nv">same2</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="nv">same2</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p12</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p22</span><span class="p">)</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="gr">)</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>现在我们已经构成不需要使用let表达式的等价的MiniZinc代码,和展平可以正常进行.</p>
<p>为了说明没有出现在最顶层的let表达式的情况,看看以下模型</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">                     </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>我们抽取变量定义到最顶层,约束到第一个围住的布尔语境,这里是蕴含的右手边.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>注意到如果我们知道定义一个变量的等式的真值不会为假,我们可以抽取它到最顶层. 这通常可以是求解大幅加快.</p>
<p>对于上面的例子,因为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> 的值域对于 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code> 并不够大, 所以约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"></span></code> 可能失败.
不过约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code> 不可以(实际上边界分析会给予 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">z</span><span class="s"></span></code> 足够大的边界来包含 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code> 所有的可能值).
一个更好的展平可以给出</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>现在MiniZinc编译器通过总是使引入变量声明的边界足够大,它应该可以包含所有它定义的表达式的值.
然后在正确的语境中为let表达式加入边界约束.在上面的例子中这个结果是</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9</span><span class="o">..</span><span class="m">72</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">14</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>这个转换可以使求解更加高效,因为let变量的所有可能的复杂计算并没有被具体化.</p>
<p>这种方法的另外一个原因是在引入变量出现在取反语境的时候它也可以被使用(只要它们有一个定义). 考虑一下与之前相似的这个例子:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"></span>
<span class="s">           </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="p">(</span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>这个let表达式出现在否定语境中,不过每个引入变量都被定义了.展平后的代码是</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">1</span><span class="o">..</span><span class="m">8</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="o">-</span><span class="m">9</span><span class="o">..</span><span class="m">72</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>注意到作为对比的let消除方法不能给出一个正确的转换:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">14</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>以上转换对于所有 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> 的可能值给出结果,而原来的约束除掉了 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="s"></span></code> 的可能性.</p>
<p>对于在let表达式中的处理跟对定义的变量的处理是相似的. 你可以认为一个约束等价于定义一个新的布尔变量.
新的布尔变量定义可以从最顶层中抽取出来, 而布尔保存在正确的语境下.</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="s"></span>
<span class="s">                    </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>可以处理成</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="k">let</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">),</span><span class="s"></span>
<span class="s">                          </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="p">),</span><span class="s"></span>
<span class="s">                          </span><span class="k">constraint</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">b2</span><span class="s"></span>
<span class="s">                    </span><span class="p">}</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>然后展平成</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">b1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">((</span><span class="nv">x</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s">  </span><span class="o">-&gt;</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="o">-</span><span class="nv">x</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">z</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span><span class="p">(</span><span class="nv">b1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">b2</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nv">y</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="m">2</span><span class="p">)</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="nv">z</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="part_3_user_manual.html" class="btn btn-neutral float-right" title="3. User Manual" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sat.html" class="btn btn-neutral" title="2.7. 在MiniZinc中对布尔可满足性问题建模" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, 2019, 2020 Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.7.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/js/doc-links.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>