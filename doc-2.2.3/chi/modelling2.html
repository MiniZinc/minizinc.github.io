

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.2. 更多复杂模型 &mdash; The MiniZinc Handbook 2.2.2</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/modelling2.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2.3. 谓词和函数" href="predicates.html" />
    <link rel="prev" title="2.1. MiniZinc基本模型" href="modelling.html" /> 

  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_2_tutorial.html">2. Minizinc 指南</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="modelling.html">2.1. MiniZinc基本模型</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.2. 更多复杂模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sec-arrayset">2.2.1. 数组和集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">2.2.2. 全局约束</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">2.2.3. 条件表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-enum">2.2.4. 枚举类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sec-complex">2.2.5. 复杂约束</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">2.2.6. 集合约束</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">2.2.7. 汇总</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">2.3. 谓词和函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="optiontypes.html">2.4. 选项类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="mzn_search.html">2.5. 搜索</a></li>
<li class="toctree-l2"><a class="reference internal" href="efficient.html">2.6. MiniZinc中的有效建模实践</a></li>
<li class="toctree-l2"><a class="reference internal" href="sat.html">2.7. 在MiniZinc中对布尔可满足性问题建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="flattening.html">2.8. FlatZinc和展平</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_2_tutorial.html">2. Minizinc 指南</a> &raquo;</li>
        
      <li>2.2. 更多复杂模型</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>2.2. 更多复杂模型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>在上一节中，我们介绍了MiniZinc模型的基本结构。在这一节中，我们介绍数组和集合数据结构，枚举类型，以及更加复杂的约束。</p>
<div class="section" id="sec-arrayset">
<span id="id2"></span><h2>2.2.1. 数组和集合<a class="headerlink" href="#sec-arrayset" title="Permalink to this headline">¶</a></h2>
<p>在绝大多数情况下，我们都是有兴趣建一个约束和变量的个数依赖于输入数据的模型。
为了达到此目的，我们通常会使用 <span class="target" id="index-0"></span>数组 。</p>
<p>考虑一个关于金属矩形板温度的简单有限元素模型。通过把矩形板在2维的矩阵上分成有限个的元素，
我们近似计算矩形板上的温度。
一个模型在 <a class="reference internal" href="#ex-laplace"><span class="std std-numref">Listing 2.2.1</span></a> 中给出。它声明了有限元素模型的宽 <tt class="docutils literal">w</tt> 和高 <tt class="docutils literal">h</tt> 。</p>
<p>声明</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">HEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">h</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">h</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">WIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">w</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s">  </span>
<span class="kt">array</span><span class="p">[</span><span class="nv">HEIGHT</span><span class="p">,</span><span class="nv">WIDTH</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% 在点（i,j）处的温度</span><span class="s"></span>
</pre></div>
</div>
<p>声明了四个固定的整型集合来描述有限元素模型的尺寸： <tt class="docutils literal">HEIGHT</tt> 是整个模型的整体高度，而 <tt class="docutils literal">CHEIGHT</tt> 是省略了顶部和底部的中心高度， <tt class="docutils literal">WIDTH</tt> 是模型的整体宽度，而 <tt class="docutils literal">CWIDTH</tt> 是省略了左侧和右侧的中心宽度。最后，声明了一个浮点型变量组成的行编号从 <span class="math notranslate nohighlight">\(0\)</span> 到 <span class="math notranslate nohighlight">\(w\)</span> ，列编号从 <span class="math notranslate nohighlight">\(0\)</span> 到 <span class="math notranslate nohighlight">\(h\)</span> 的两维数组 <tt class="docutils literal">t</tt> 用来表示金属板上每一点的温度。
我们可以用表达式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> 来得到数组中第 <span class="math notranslate nohighlight">\(i^{th}\)</span> 行和第 <span class="math notranslate nohighlight">\(j^{th}\)</span> 列的元素。</p>
<p>拉普拉斯方程规定当金属板达到一个稳定状态时，每一个内部点的温度是它的正交相邻点的平均值。约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="s"></span>
<span class="s">              </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>保证了每一个内部点 <span class="math notranslate nohighlight">\((i,j)\)</span> 是它的四个正交相邻点的平均值。
约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% 边约束</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">left</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">right</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="m">0</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">top</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">bottom</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>限制了每一个边的温度必须是相等的，并且给了这些温度名字：<tt class="docutils literal">left</tt> ， <tt class="docutils literal">right</tt> ， <tt class="docutils literal">top</tt> 和 <tt class="docutils literal">bottom</tt>。
而约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% 角约束</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,0</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="m">0</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"> </span>
</pre></div>
</div>
<p>确保了角的温度（这些是不相干的）被设置为0.0。
我们可以用 <a class="reference internal" href="#ex-laplace"><span class="std std-numref">Listing 2.2.1</span></a> 中给出的模型来决定一个被分成5 <span class="math notranslate nohighlight">\(\times\)</span> 5个元素的金属板的温度。其中左右下侧的温度为0，上侧的温度为100。</p>
<div class="literal-block-wrapper docutils container" id="ex-laplace">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.1 </span><span class="caption-text">决定稳定状态温度的有限元平板模型 (<a class="reference download internal" href="downloads/laplace.mzn" download=""><tt class="xref download docutils literal">laplace.mzn</tt></a>).</span><a class="headerlink" href="#ex-laplace" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">h</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">4</span><span class="p">;</span><span class="s"></span>

<span class="c">% arraydec</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">HEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">h</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">h</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">WIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">w</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">w</span><span class="o">-</span><span class="m">1</span><span class="p">;</span><span class="s">  </span>
<span class="kt">array</span><span class="p">[</span><span class="nv">HEIGHT</span><span class="p">,</span><span class="nv">WIDTH</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"> </span><span class="c">% 在点（i,j）处的温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">left</span><span class="p">;</span><span class="s">   </span><span class="c">% 左侧温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">right</span><span class="p">;</span><span class="s">  </span><span class="c">% 右侧温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">top</span><span class="p">;</span><span class="s">    </span><span class="c">% 顶部温度</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">bottom</span><span class="p">;</span><span class="s"> </span><span class="c">% 底部温度</span><span class="s"></span>

<span class="c">% 拉普拉斯方程：每一个内部点温度是它相邻点的平均值</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="s"></span>
<span class="s">              </span><span class="m">4.0</span><span class="o">*</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="p">]);</span><span class="s"></span>

<span class="c">% sides</span><span class="s"></span>
<span class="c">% 边约束</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="m">0</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">left</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CHEIGHT</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">right</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="m">0</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">top</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">CWIDTH</span><span class="p">)(</span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">bottom</span><span class="p">);</span><span class="s"></span>

<span class="c">% 角约束</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0,0</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="m">0</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="m">0</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">h</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="o">=</span><span class="m">0.0</span><span class="p">;</span><span class="s"> </span>
<span class="nv">left</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">right</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">top</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">100.0</span><span class="p">;</span><span class="s"></span>
<span class="nv">bottom</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">0.0</span><span class="p">;</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">show_float</span><span class="p">(</span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="nv">t</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">++</span><span class="s"> </span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">h</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot; &quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">         </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">HEIGHT</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">WIDTH</span><span class="s"></span>
<span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>运行命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver osicbc laplace.mzn
</pre></div>
</div>
<p>得到输出</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  0.00 100.00 100.00 100.00   0.00
  0.00  42.86  52.68  42.86   0.00
  0.00  18.75  25.00  18.75   0.00
  0.00   7.14   9.82   7.14   0.00
  0.00   0.00   0.00   0.00   0.00
----------
</pre></div>
</div>
<div class="admonition- admonition" id="defblock-0">
<p class="first admonition-title">集合</p>
<p id="index-1">集合变量用以下方式声明</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="o">&lt;</span><span class="s">类型</span><span class="o">-</span><span class="s">实例化</span><span class="o">&gt;</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>整型，枚举型（参见后面），浮点型和布尔型集合都可以定义。
决策变量集合只可以是类型为整型或者枚举型的变量集合。
集合常量有以下形式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"> </span><span class="p">}</span><span class="s"></span>
</pre></div>
</div>
<p>或者是以下形式的整型，枚举型或浮点型 <span class="target" id="index-2"></span>范围 表达式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"> </span><span class="o">..</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">2</span><span class="o">&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>标准的 <span class="target" id="index-3"></span>集合操作符 有：元素属于
(<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">in</span><span class="s"></span></code>),
(非严格的) 集合包含 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">subset</span><span class="s"></span></code>),
(非严格的) 超集关系 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">superset</span><span class="s"></span></code>), 并集
(<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">union</span><span class="s"></span></code>),
交集 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">intersect</span><span class="s"></span></code>),
集合差运算 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">diff</span><span class="s"></span></code>),
集合对称差 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">symdiff</span><span class="s"></span></code>)
和集合元素的个数 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">card</span><span class="s"></span></code>).</p>
<p class="last">我们已经看到集合变量和集合常量（包含范围）可以被用来作为变量声明时的隐式类型。
在这种情况下变量拥有集合元素中的类型并且被隐式地约束为集合中的一个成员。</p>
</div>
<p>我们的烤蛋糕问题是一个非常简单的批量生产计划问题例子。在这类问题中，我们希望
去决定每种类型的产品要制造多少来最大化利润。同时制造一个产品会消耗不同数量固定的资源。
我们可以扩展 <a class="reference internal" href="modelling.html#ex-cakes2"><span class="std std-numref">Listing 2.1.3</span></a> 中的MiniZinc模型为一个不限制资源和产品类型的模型去处理这种类型的问题。
这个模型在 <a class="reference internal" href="#ex-prod-planning"><span class="std std-numref">Listing 2.2.2</span></a> 中给出。一个（烤蛋糕问题的）数据文件例子在 <a class="reference internal" href="#fig-prod-planning-data"><span class="std std-numref">Listing 2.2.3</span></a> 中给出。</p>
<div class="literal-block-wrapper docutils container" id="ex-prod-planning">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.2 </span><span class="caption-text">简单批量生产计划模型 (<a class="reference download internal" href="downloads/simple-prod-planning.mzn" download=""><tt class="xref download docutils literal">simple-prod-planning.mzn</tt></a>).</span><a class="headerlink" href="#ex-prod-planning" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% 要制造的产品</span><span class="s"></span>
<span class="kt">enum</span><span class="s"> </span><span class="nv">Products</span><span class="p">;</span><span class="s">  </span>
<span class="c">% 每种产品的单位利润</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">profit</span><span class="p">;</span><span class="s"></span>
<span class="c">% 用到的资源</span><span class="s"></span>
<span class="kt">enum</span><span class="s"> </span><span class="nv">Resources</span><span class="p">;</span><span class="s"></span>
<span class="c">% 每种资源可获得的数量</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Resources</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">capacity</span><span class="p">;</span><span class="s"> </span>

<span class="c">% 制造一个单位的产品需要的资源单位量</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">,</span><span class="s"> </span><span class="nv">Resources</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">consumption</span><span class="p">;</span><span class="s"> </span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">assert</span><span class="p">(</span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="p">,</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"> </span>
<span class="s">           </span><span class="p">(</span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;=</span><span class="s"> </span><span class="m">0</span><span class="p">),</span><span class="s"> &quot;Error: negative consumption&quot;</span><span class="p">);</span><span class="s"></span>

<span class="c">% 产品数量的界</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"> </span>
<span class="s">                     </span><span class="p">(</span><span class="nb">min</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"> </span>
<span class="s">                          </span><span class="p">(</span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]));</span><span class="s"></span>

<span class="c">% 变量：每种产品我们需要制造多少</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">mproducts</span><span class="p">:</span><span class="s"> </span><span class="nv">produce</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Resources</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">capacity</span><span class="p">):</span><span class="s"> </span><span class="nv">used</span><span class="p">;</span><span class="s"></span>

<span class="c">% 产量不可以使用超过可获得的资源量：</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s">     </span>
<span class="s">      </span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)(</span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="s"> </span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">])</span><span class="s"> </span>
<span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s">     </span>
<span class="s">      </span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"></span>
<span class="p">);</span><span class="s">    </span>

<span class="c">% 最大化利润</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">profit</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="o">*</span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">]);</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;</span><span class="p">\(</span><span class="nv">p</span><span class="p">)</span><span class="s"> = </span><span class="p">\(</span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">])</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">|</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">       </span><span class="p">[</span><span class="s"> &quot;</span><span class="p">\(</span><span class="nv">r</span><span class="p">)</span><span class="s"> = </span><span class="p">\(</span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">])</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">|</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="fig-prod-planning-data">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.3 </span><span class="caption-text">简单批量生产计划模型的数据文件例子 (<a class="reference download internal" href="downloads/simple-prod-planning-data.dzn" download=""><tt class="xref download docutils literal">simple-prod-planning-data.dzn</tt></a>).</span><a class="headerlink" href="#fig-prod-planning-data" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="c">% 简单批量生产计划模型的数据文件</span><span class="s"></span>
<span class="nv">Products</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="nv">BananaCake</span><span class="p">,</span><span class="s"> </span><span class="nv">ChocolateCake</span><span class="s"> </span><span class="p">};</span><span class="s"></span>
<span class="nv">profit</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">400</span><span class="p">,</span><span class="s"> </span><span class="m">450</span><span class="p">];</span><span class="s"> </span><span class="c">% 以分为单位</span><span class="s"></span>

<span class="nv">Resources</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="nv">Flour</span><span class="p">,</span><span class="s"> </span><span class="nv">Banana</span><span class="p">,</span><span class="s"> </span><span class="nv">Sugar</span><span class="p">,</span><span class="s"> </span><span class="nv">Butter</span><span class="p">,</span><span class="s"> </span><span class="nv">Cocoa</span><span class="s"> </span><span class="p">};</span><span class="s"></span>
<span class="nv">capacity</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">4000</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">2000</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">];</span><span class="s"></span>

<span class="nv">consumption</span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">250</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="p">,</span><span class="s"> </span><span class="m">100</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="p">|</span><span class="s"> </span><span class="m">200</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>这个模型的新特征是只用枚举类型 <span class="target" id="index-4"></span>枚举类型 。
这使得我们可以把资源和产品的选择作为模型的参数。
模型的第一个项</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="nv">Products</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>声明 <tt class="docutils literal">Products</tt> 为 <em>未知的</em> 产品集合。</p>
<div class="admonition- admonition" id="defblock-1">
<p class="first admonition-title">枚举类型</p>
<p id="index-5">枚举类型，我们称为 <tt class="docutils literal">enums</tt> , 用以下方式声明</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>一个枚举类型用以下赋值的方式定义</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"> </span><span class="p">}</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p class="last">其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"></span></code>, …, <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"></span></code> 是名为 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"></span></code> 的枚举类型中的元素。
通过这个定义，枚举类型中的每个元素也被有效地声明为这个类型的一个新的常量。
声明和定义可以像往常一样结合为一行。</p>
</div>
<p>第二个项声明了一个整型数组：</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">profit</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p><tt class="docutils literal">profit</tt> 数组的 <span class="target" id="index-6"></span>下标集合 是 <tt class="docutils literal">Products</tt> 。理想情况下，这种声明方式表明只有集合 <tt class="docutils literal">Products</tt> 中的元素才能被用来做数组的下标。</p>
<p>有 <span class="math notranslate nohighlight">\(n\)</span> 个元素组成的枚举类型中的元素的行为方式和整数 <span class="math notranslate nohighlight">\(1\dots n\)</span> 的行为方式很像。它们可以被比较，它们可以按照它们出现在枚举类型定义中的顺序被排序，它们可以遍历，它们可以作为数组的下标，实际上，它们可以出现在一个整数可以出现的任何地方。</p>
<p>在数据文件例子中，我们用一列整数来初始化数组</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">Products</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="nv">BananaCake</span><span class="p">,</span><span class="s"> </span><span class="nv">ChocolateCake</span><span class="s"> </span><span class="p">};</span><span class="s"></span>
<span class="nv">profit</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">400,450</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
<p>意思是香蕉蛋糕的利润是400，而巧克力蛋糕的利润是450。
在内部， <tt class="docutils literal">BananaCake</tt> 会被看成是像整数1一样，而 <tt class="docutils literal">ChocolateCake</tt> 会被看成像整数2一样。MiniZinc虽然不提供明确的列表类型，但用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">1</span><span class="o">..</span><span class="nv">n</span><span class="s"></span></code> 为下标集合的一维数组表现起来就像列表。我们有时候也会称它们为列表 <span class="target" id="index-7"></span>lists 。</p>
<p>根据同样的方法，接下来的两项中我们声明了一个资源集合 <tt class="docutils literal">Resources</tt> ，
一个表明每种资源可获得量的数组 <tt class="docutils literal">capacity</tt>。</p>
<p>更有趣的是项</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">,</span><span class="s"> </span><span class="nv">Resources</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">consumption</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>声明了一个两维数组 <tt class="docutils literal">consumption</tt> 。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"></span></code> 的值是制造一单位的产品 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> 所需要的资源 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 的数量。其中第一个下标是行下标，而第二个下标是列下标。</p>
<p>数据文件包含了一个两维数组的初始化例子:</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">consumption</span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">250</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="p">,</span><span class="s">  </span><span class="m">100</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"></span>
<span class="s">              </span><span class="p">|</span><span class="s"> </span><span class="m">200</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">150</span><span class="p">,</span><span class="s"> </span><span class="m">75</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
<p>注意分隔符 <tt class="docutils literal">|</tt> 是怎样被用来分隔行的。</p>
<div class="admonition- admonition" id="defblock-2">
<p class="first admonition-title">数组</p>
<p>因此，MiniZinc提供一维和多维数组。它们用以下类型来声明：</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="o">&lt;</span><span class="s">下标集合</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">下标集合</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="o">&lt;</span><span class="s">类型</span><span class="o">-</span><span class="s">实例化</span><span class="o">&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>MiniZinc要求数组声明要给出每一维的下标集合。下标集合或者是一个整型范围，一个
被初始化为整型范围的集合变量，或者是一个 <span class="target" id="index-8"></span>枚举类型 。
数组可以是所有的基类型：整型，枚举型，布尔型，浮点型或者字符串型。
这些可以是固定的或者不固定的，除了字符串型，它只可以是参数。数组也可以作用于
集合但是不可以作用于数组。</p>
<p><span class="target" id="index-9"></span>一维数组常量 有以下格式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
<p>而 <span class="target" id="index-10"></span>二维数组常量 有以下格式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="sr">[| &lt;表达式-1-1&gt;, ..., &lt;表达式-1-n&gt; |</span>
<span class="s">   </span><span class="o">..</span><span class="s">.                         </span><span class="gr">|</span><span class="s"></span>
<span class="s">   </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="nv">m</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="nv">m</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="s"> </span><span class="gr">|]</span><span class="s"></span>
</pre></div>
</div>
<p>其中这个数组有 <tt class="docutils literal">m</tt> 行 <tt class="docutils literal">n</tt> 列。</p>
<p>内建函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">array1d</span><span class="s"></span></code> ,
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">array2d</span><span class="s"></span></code> 等家族可以被用来从一个列表（或者更准确的说是一个一维数组）去实例化任何维度的数组。
调用</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="cs">&lt;n&gt;</span><span class="nf">d</span><span class="p">(</span><span class="o">&lt;</span><span class="s">下标集合</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">下标集合</span><span class="o">-</span><span class="nv">n</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">列表</span><span class="o">&gt;</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>返回一个 <tt class="docutils literal">n</tt> 维的数组，它的下标集合在前 <tt class="docutils literal">n</tt> 个参数给出，最后一个参数包含了数组的元素。
例如 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">array2d</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">])</span><span class="s"></span></code> 和
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[|</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="p">|</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="s"> </span><span class="p">|</span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">|]</span><span class="s"></span></code> 是相等的。</p>
<p>数组元素按照通常的方式获取 <span class="target" id="index-11"></span>获取 ： <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> 给出第 <span class="math notranslate nohighlight">\(i^{th}\)</span> 行第 <span class="math notranslate nohighlight">\(j^{th}\)</span> 列的元素。</p>
<p class="last">串联操作符 <tt class="docutils literal">++</tt> 可以被用来串联两个一维的数组。
结果得到一个列表，即一个元素从1索引的一维数组。
例如 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">4000</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">]</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="p">[</span><span class="m">2000</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">]</span><span class="s"></span></code> 求得 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">4000</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">2000</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">,</span><span class="s"> </span><span class="m">500</span><span class="p">]</span><span class="s"></span></code> 。内建函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">length</span><span class="s"></span></code> 返回一维数组的长度。</p>
</div>
<p>模型的下一项定义了参数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> 。它被设为可以生产出的任何类型产品的数量上限。
这个确实是一个复杂的内嵌数组推导式和聚合操作符例子。在我们试图理解这些项和剩下的模型之前，我们应该先介绍一下它们。</p>
<p>首先，MiniZinc提供了在很多函数式编程语言都提供的列表推导式。例如，列表推导式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> 算得 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">3</span><span class="p">]</span><span class="s"></span></code> 等同于 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">]</span><span class="s"></span></code> 。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">]</span><span class="s"></span></code> 只是一个下标集合为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"></span></code> 的数组。</p>
<p>MiniZinc同时也提供了集合推导式，它有类似的语法：例如 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">{</span><span class="nv">i</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">i</span><span class="p">}</span><span class="s"></span></code> 计算得到集合 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">{</span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">}</span><span class="s"></span></code> 。</p>
<div class="admonition- admonition" id="defblock-3">
<p class="first admonition-title">列表和集合推导式</p>
<p>列表推导式的一般格式是</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="o">&lt;</span><span class="s">生成元表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"></span>
</pre></div>
</div>
<p><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"></span></code> 指明了如何从 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">生成元表达式</span><span class="o">&gt;</span><span class="s"></span></code> 产生的元素输出列表中创建元素。
生成元 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;generator-exp&gt;</span><span class="s"></span></code> 由逗号分开的一列生成元表达式组成，选择性地跟着一个布尔型表达式。
两种格式是</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">生成元</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">生成元</span><span class="o">&gt;</span><span class="s"></span>
<span class="o">&lt;</span><span class="s">生成元</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">生成元</span><span class="o">&gt;</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="o">&lt;</span><span class="s">布尔表达式</span><span class="o">&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>第二种格式中的可选择的 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"></span></code> 被用作生成元表达式的过滤器：只有满足布尔型表达式的输出列表中的元素才被用来构建元素。 <span class="target" id="index-12"></span>生成元
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;generator&gt;</span><span class="s"></span></code>
有以下格式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">标识符</span><span class="o">&gt;</span><span class="p">,</span><span class="s"> </span><span class="o">..</span><span class="s">.</span><span class="p">,</span><span class="s"> </span><span class="o">&lt;</span><span class="s">标识符</span><span class="o">&gt;</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="o">&lt;</span><span class="s">数组表达式</span><span class="o">&gt;</span><span class="s"></span>
</pre></div>
</div>
<p>每一个标识符是一个 <em>迭代器</em> ，轮流从数值表达式中取值，最后一个标识符变化的最迅速。</p>
<p>列表推导式的生成元和 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"></span></code> 通常不会涉及决策变量。如果它们确实涉及了决策变量，那么产生的列表是一列 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="cs">&lt;T&gt;</span><span class="s"></span></code> ，其中$T$是 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"></span></code> 的类型。更多细节，请参考 <a class="reference internal" href="optiontypes.html#sec-optiontypes"><span class="std std-ref">选项类型</span></a> 中有关选项类型 <span class="target" id="index-13"></span>option types 的论述。</p>
<p class="last"><span class="target" id="index-14"></span>集合推导式 几乎和列表推导式一样：唯一的不同是这里使用 <tt class="docutils literal">{</tt> 和 <tt class="docutils literal">}</tt> 括住表达式而不是 <tt class="docutils literal">[</tt> 和 <tt class="docutils literal">]</tt> 。集合推导式生成的元素必须是固定的 <span class="target" id="index-15"></span>fixed ，即不能是决策变量。类似的，集合推导式的生成元和可选择的 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"></span></code> 必须是固定的。</p>
</div>
<p id="index-16">第二，MiniZinc提供了一系列的可以把一维数组的元素聚合起来的内建函数。它们中最有用的可能是 :mzn:<tt class="docutils literal">forall</tt> 。它接收一个布尔型表达式数组（即，约束），返回单个布尔型表达式，它是对数组中的布尔型表达式的逻辑合取。</p>
<p>例如，以下表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>其中 <tt class="docutils literal">a</tt> 是一个下标集合为 <tt class="docutils literal">1..3</tt> 的算术数组。它约束了 <tt class="docutils literal">a</tt> 中的元素是互相不相同的。列表推导式计算得到 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">3</span><span class="p">],</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="p">]</span><span class="s"></span></code> ，所以 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> 函数返回逻辑合取 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="s"></span></code> 。</p>
<div class="admonition- admonition" id="defblock-4">
<p class="first admonition-title">聚合函数</p>
<p id="index-17">算术数组的 <em>聚合函数</em> 有: <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">sum</span><span class="s"></span></code> 把元素加起来， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">product</span><span class="s"></span></code> 把元素乘起来，和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">min</span><span class="s"></span></code> 跟 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">max</span><span class="s"></span></code> 各自返回数组中的最小和最大元素。
当作用于一个空的数组时， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">min</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">max</span><span class="s"></span></code> 返回一个运行错误， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">sum</span><span class="s"></span></code> 返回0， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">product</span><span class="s"></span></code> 返回1。</p>
<p class="last">MiniZinc为数组提供了包含有布尔型表达式的四个聚合函数。
正如我们看到的，它们中的第一个是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> ，它返回一个等于多个约束的逻辑合取的单个约束。
第二个函数， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">exists</span><span class="s"></span></code> ，返回多个约束的逻辑析取。因此 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">forall</span><span class="s"></span></code> 强制数组中的所有约束都满足，而 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">exists</span><span class="s"></span></code> 确保至少有一个约束满足。第三个函数， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">xorall</span><span class="s"></span></code> 确保奇数个约束满足。第四个函数， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">iffall</span><span class="s"></span></code> 确保偶数个约束满足。</p>
</div>
<p>第三个，也是难点的最后一个部分是当使用数组推导式时，MiniZinc允许使用一个特别的聚合函数的语法。
建模者不仅仅可以用</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>也可以用一个更加数学的表示</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">3</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">a</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="nv">j</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>两种表达方式是完全相等的：建模者可以自由使用任何一个他们认为更自然的表达方式。</p>
<div class="admonition- admonition" id="defblock-5">
<p class="first admonition-title">生成表达式</p>
<p id="index-18">一个 <em>生成表达式</em> 有以下格式</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">聚合函数</span><span class="o">&gt;</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">生成元表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>圆括号内的 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">生成元表达式</span><span class="o">&gt;</span><span class="s"></span></code> 以及构造表达式 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"></span></code> 是非选择性的：它们必须存在。它等同于</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">聚合函数</span><span class="o">&gt;</span><span class="s"> </span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="o">&lt;</span><span class="s">生成元表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p class="last"><code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">聚合函数</span><span class="o">&gt;</span><span class="s"></span></code> <span class="target" id="index-19"></span>aggregation function 可以是MiniZinc的任何由单个数组作为其参数的函数。</p>
</div>
<p>接下来我们就来了解 <a class="reference internal" href="#ex-prod-planning"><span class="std std-numref">Listing 2.2.2</span></a> 中的简单批量生产计划模型剩余的部分。现在请暂时忽略定义 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> 的这部分。接下来的项：</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="nv">Products</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">mproducts</span><span class="p">:</span><span class="s"> </span><span class="nv">produce</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>定义了一个一维的决策变量数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">produce</span><span class="s"></span></code> 。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="s"></span></code> 的值代表了最优解中产品 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> 的数量。
下一项</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="nv">Resources</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nb">max</span><span class="p">(</span><span class="nv">capacity</span><span class="p">):</span><span class="s"> </span><span class="nv">used</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>定义了一个辅助变量集合来记录每一种资源的使用量。
下面的两个约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="p">)</span><span class="s"></span>
<span class="s">           </span><span class="p">(</span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="s"> </span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">]));</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="p">)(</span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">used</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"></span></code> 计算资源 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 的总体消耗以及保证它是少于可获得的资源 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 的量。
最后，项</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">profit</span><span class="p">[</span><span class="nv">p</span><span class="p">]</span><span class="o">*</span><span class="nv">produce</span><span class="p">[</span><span class="nv">p</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>表明这是一个最大化问题以及最大化的目标是全部利润。</p>
<p>现在我们回到 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">mproducts</span><span class="s"></span></code> 的定义。对每个产品 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> ，表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">min</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"></span>
<span class="s">                                 </span><span class="p">(</span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">])</span><span class="s"></span>
</pre></div>
</div>
<p>决定了在考虑了每种资源 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 的数量以及制造产品 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> 需要的 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 量的情况下， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">p</span><span class="s"></span></code> 可以生产的最大量。注意过滤器 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="s"></span></code> 的使用保证了只有此产品需要的资源才会考虑，因此避免了出现除数为零的错误。所以，完整的表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">mproducts</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="s"> </span><span class="p">(</span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Products</span><span class="p">)</span><span class="s"></span>
<span class="s">                     </span><span class="p">(</span><span class="nb">min</span><span class="s"> </span><span class="p">(</span><span class="nv">r</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Resources</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="p">)</span><span class="s"></span>
<span class="s">                                 </span><span class="p">(</span><span class="nv">capacity</span><span class="p">[</span><span class="nv">r</span><span class="p">]</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">consumption</span><span class="p">[</span><span class="nv">p</span><span class="p">,</span><span class="nv">r</span><span class="p">]));</span><span class="s"></span>
</pre></div>
</div>
<p>计算 <em>任何</em> 产品可以被制造的最大量，因此它可以被作为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">produce</span><span class="s"></span></code> 中的决策变量定义域的上限。</p>
<p>最后，注意输出项是比较复杂的，并且使用了列表推导式 <span class="target" id="index-20"></span>列表推导式 去创建一个易于理解的输出。运行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --solver gecode simple-prod-planning.mzn simple-prod-planning-data.dzn
</pre></div>
</div>
<p>输出得到如下结果</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BananaCake = 2;
ChocolateCake = 2;
Flour = 900;
Banana = 4;
Sugar = 450;
Butter = 500;
Cocoa = 150;
----------
==========
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>2.2.2. 全局约束<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>MiniZinc包含了一个全局约束的库，这些全局约束也可以被用来定义模型。一个例子是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> 约束，它要求所有参数中的变量都必须是互相不相等的。</p>
<div class="literal-block-wrapper docutils container" id="ex-smm">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.4 </span><span class="caption-text">SEND+MORE=MONEY算式谜题模型 (<a class="reference download internal" href="downloads/send-more-money.mzn" download=""><tt class="xref download docutils literal">send-more-money.mzn</tt></a>)</span><a class="headerlink" href="#ex-smm" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">E</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">D</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">M</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">O</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">R</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">9</span><span class="p">:</span><span class="s"> </span><span class="nv">Y</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s">           </span><span class="m">1000</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">S</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">10</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">D</span><span class="s"></span>
<span class="s">                   </span><span class="o">+</span><span class="s"> </span><span class="m">1000</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">M</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">O</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">10</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">R</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">E</span><span class="s"></span>
<span class="s">       </span><span class="o">=</span><span class="s"> </span><span class="m">10000</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">M</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1000</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">O</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">100</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">10</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">E</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">Y</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">]);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;   </span><span class="p">\(</span><span class="nv">S</span><span class="p">)\(</span><span class="nv">E</span><span class="p">)\(</span><span class="nv">N</span><span class="p">)\(</span><span class="nv">D</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">        &quot;+  </span><span class="p">\(</span><span class="nv">M</span><span class="p">)\(</span><span class="nv">O</span><span class="p">)\(</span><span class="nv">R</span><span class="p">)\(</span><span class="nv">E</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="s"></span>
<span class="s">        &quot;= </span><span class="p">\(</span><span class="nv">M</span><span class="p">)\(</span><span class="nv">O</span><span class="p">)\(</span><span class="nv">N</span><span class="p">)\(</span><span class="nv">E</span><span class="p">)\(</span><span class="nv">Y</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>SEND+MORE=MONEY问题要求给每一个字母赋不同的数值使得此算术约束满足。 <a class="reference internal" href="#ex-smm"><span class="std std-numref">Listing 2.2.4</span></a> 中的模型使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="p">([</span><span class="nv">S</span><span class="p">,</span><span class="nv">E</span><span class="p">,</span><span class="nv">N</span><span class="p">,</span><span class="nv">D</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">R</span><span class="p">,</span><span class="nv">Y</span><span class="p">])</span><span class="s"></span></code> 约束表达式来保证每个字母有不同的数字值。在使用了引用项</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>后，此全局约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">alldifferent</span><span class="s"></span></code> 可以在模型中使用。
我们可以用以下代替此行</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;globals.mzn&quot;</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>它包含了所有的全局约束。</p>
<p>一系列所有在MiniZinc中定义了的全局约束都被包含在了发布的文档中。对一些重要的全局约束的描述，请参见 <a class="reference internal" href="predicates.html#sec-globals"><span class="std std-ref">全局约束</span></a> 。</p>
</div>
<div class="section" id="id4">
<h2>2.2.3. 条件表达式<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>MiniZinc提供了一个条件表达式 <em>if-then-else-endif</em> 。
它的一个使用例子如下</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="k">if</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">x</span><span class="s"> </span><span class="o">div</span><span class="s"> </span><span class="nv">y</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">endif</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>若 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> 不是零，则 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">r</span><span class="s"></span></code> 设为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> 除以 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">y</span><span class="s"></span></code> ，否则则设为零。</p>
<div class="admonition- admonition" id="defblock-6">
<p class="first admonition-title">条件表达式</p>
<p id="index-21">条件表达式的格式是</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="s"> </span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">2</span><span class="o">&gt;</span><span class="s"> </span><span class="k">endif</span><span class="s"></span>
</pre></div>
</div>
<p>它是一个真表达式而不是一个控制流语句，所以它可以被用于其他表达式中。如果 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"></span></code> 是真，则它取值 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"></span></code> ，否则则是 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">2</span><span class="o">&gt;</span><span class="s"></span></code> 。 条件表达式的类型是 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"></span></code> 和 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">2</span><span class="o">&gt;</span><span class="s"></span></code> 的类型，而它们俩必须有相同的类型。</p>
<p class="last">如果 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">布尔型表达式</span><span class="o">&gt;</span><span class="s"></span></code> 包含决策变量，则表达式的类型-实例化是 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="kt">var</span><span class="s"> </span><span class="cs">&lt;T&gt;</span><span class="s"></span></code> ，其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;T&gt;</span><span class="s"></span></code> 是
<code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">1</span><span class="o">&gt;</span><span class="s"></span></code> 和 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">表达式</span><span class="o">-</span><span class="m">2</span><span class="o">&gt;</span><span class="s"></span></code> 的类型，就算是在两个表达式都已经固定了的情况下也是如此。</p>
</div>
<div class="literal-block-wrapper docutils container" id="ex-sudoku">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.5 </span><span class="caption-text">广义数独问题的模型 (<a class="reference download internal" href="downloads/sudoku.mzn" download=""><tt class="xref download docutils literal">sudoku.mzn</tt></a>)</span><a class="headerlink" href="#ex-sudoku" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>

<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">S</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nv">S</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">digs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">ceil</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="m">10.0</span><span class="p">,</span><span class="nb">int2float</span><span class="p">(</span><span class="nv">N</span><span class="p">)));</span><span class="s"> </span><span class="c">% 输出的数字</span><span class="s"></span>

<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">N</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">SubSquareRange</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">S</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">N</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">N</span><span class="p">:</span><span class="s"> </span><span class="nv">start</span><span class="p">;</span><span class="s"> </span><span class="c">%% 板初始0 = 空</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="nv">N</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="nv">N</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="p">:</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">;</span><span class="s"></span>

<span class="c">% 填充初始板</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="p">)(</span><span class="s"></span>
<span class="s">    </span><span class="k">if</span><span class="s"> </span><span class="nv">start</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">start</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="l">true</span><span class="s"> </span><span class="k">endif</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="c">% 每行中取值各不相同</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">                   </span><span class="bp">alldifferent</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="s"> </span><span class="p">])</span><span class="s"> </span><span class="p">);</span><span class="s"> </span>

<span class="c">% 每列中取值各不相同</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">                   </span><span class="bp">alldifferent</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="s"> </span><span class="p">])</span><span class="s"> </span><span class="p">);</span><span class="s"> </span>

<span class="c">% 每个子方格块中取值各不相同</span><span class="s"></span>
<span class="k">constraint</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">a</span><span class="p">,</span><span class="s"> </span><span class="nv">o</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">SubSquareRange</span><span class="p">)(</span><span class="s"></span>
<span class="s">                </span><span class="bp">alldifferent</span><span class="p">(</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">[(</span><span class="nv">a</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="o">*</span><span class="nv">S</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">a1</span><span class="p">,</span><span class="s"> </span><span class="p">(</span><span class="nv">o</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="nv">S</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">o1</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">                                        </span><span class="nv">a1</span><span class="p">,</span><span class="s"> </span><span class="nv">o1</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">SubSquareRange</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s">  </span><span class="p">[</span><span class="s"> </span><span class="nb">show_int</span><span class="p">(</span><span class="nv">digs</span><span class="p">,</span><span class="nv">puzzle</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">++</span><span class="s"> &quot; &quot; </span><span class="o">++</span><span class="s"> </span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="nv">S</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot; &quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="k">then</span><span class="s"></span>
<span class="s">             </span><span class="k">if</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">N</span><span class="s"> </span><span class="k">then</span><span class="s"> </span>
<span class="s">                </span><span class="k">if</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="nv">S</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">endif</span><span class="s"> </span>
<span class="s">         </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s">  </span>
<span class="s">         </span><span class="p">|</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="s"> </span><span class="p">]</span><span class="s"> </span><span class="o">++</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-sudokud">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.6 </span><span class="caption-text">广义数独问题的数据文件例子 (<a class="reference download internal" href="downloads/sudoku.dzn" download=""><tt class="xref download docutils literal">sudoku.dzn</tt></a>)</span><a class="headerlink" href="#ex-sudokud" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">S</span><span class="o">=</span><span class="m">3</span><span class="p">;</span><span class="s"></span>
<span class="nv">start</span><span class="o">=</span><span class="p">[|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">7</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">8</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">9</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">7</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">9</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">7</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">9</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|</span><span class="s"></span>
<span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">,</span><span class="s"> </span><span class="m">0</span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="figure" id="id9">
<span id="fig-sudoku"></span><img alt="images/sudoku.svg" src="images/sudoku.svg" /><p class="caption"><span class="caption-number">Fig. 2.2.1 </span><span class="caption-text"><a class="reference download internal" href="downloads/sudoku.dzn" download=""><tt class="xref download docutils literal">sudoku.dzn</tt></a> 代表的问题。</span></p>
</div>
<p>在创建复杂模型或者复杂输出时，条件表达式是非常有用的。我们来看下 <a class="reference internal" href="#ex-sudoku"><span class="std std-numref">Listing 2.2.5</span></a> 中的数独问题模型。板的初始位置在参数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">start</span><span class="s"></span></code> 中给出，其中0代表了一个空的板位置。通过使用以下条件表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">PuzzleRange</span><span class="p">)(</span><span class="s"></span>
<span class="s">     </span><span class="k">if</span><span class="s"> </span><span class="nv">start</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&gt;</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> </span><span class="nv">puzzle</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">start</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="k">else</span><span class="s"> </span><span class="l">true</span><span class="s"> </span><span class="k">endif</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>它被转换为对决策变量 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">puzzle</span><span class="s"></span></code> 的约束。</p>
<p>在定义复杂输出时，条件表达式也很有用。 <span class="target" id="index-22"></span>output 在数独模型 <a class="reference internal" href="#ex-sudoku"><span class="std std-numref">Listing 2.2.5</span></a> 中，表达式</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="nv">S</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot; &quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"></span>
</pre></div>
</div>
<p>在大小为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">S</span><span class="s"></span></code> 的组群之间插入了一个额外的空格。输出表达式同时也使用条件表达式来在每 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">S</span><span class="s"></span></code> 行后面加入一个空白行。这样得到的输出有很高的可读性。</p>
<p>剩下的约束保证了每行中，每列中以及每 <span class="math notranslate nohighlight">\(S \times S\)</span> 子方格块中的值都是互相不相同的。</p>
<p id="index-23">通过使用标示 <tt class="docutils literal">-a</tt> 或 <tt class="docutils literal">--all-solutions</tt> ，我们可以用MiniZinc求解得到一个满足问题 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="s"></span></code>) 的所有解。
运行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --all-solutions sudoku.mzn sudoku.dzn
</pre></div>
</div>
<p>得到</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> 5 9 3  7 6 2  8 1 4
 2 6 8  4 3 1  5 7 9
 7 1 4  9 8 5  2 3 6

 3 2 6  8 5 9  1 4 7
 1 8 7  3 2 4  9 6 5
 4 5 9  1 7 6  3 2 8

 9 4 2  6 1 8  7 5 3
 8 3 5  2 4 7  6 9 1
 6 7 1  5 9 3  4 8 2
----------
==========
</pre></div>
</div>
<p>当系统输出完所有可能的解之后，此行 <tt class="docutils literal">==========</tt> 被输出。在这里则表明了此问题只有一个解。</p>
</div>
<div class="section" id="sec-enum">
<span id="id5"></span><h2>2.2.4. 枚举类型<a class="headerlink" href="#sec-enum" title="Permalink to this headline">¶</a></h2>
<p id="index-24">枚举类型允许我们根据一个或者是数据中的一部分，或者在模型中被命名的对象集合来创建模型。这样一来，模型就更容易被理解和调试。我们之前已经简单介绍了枚举类型或者enums。在这一小分段，我们会探索如何可以全面地使用它们，并且给出一些处理枚举类型的内建函数。</p>
<p>让我们重新回顾一下 <a class="reference internal" href="modelling.html#sec-modelling"><span class="std std-ref">MiniZinc基本模型</span></a> 中的给澳大利亚涂色问题。</p>
<div class="literal-block-wrapper docutils container" id="ex-aust-enum">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.7 </span><span class="caption-text">使用枚举类型的澳大利亚涂色模型 (<a class="reference download internal" href="downloads/aust-enum.mzn" download=""><tt class="xref download docutils literal">aust-enum.mzn</tt></a>).</span><a class="headerlink" href="#ex-aust-enum" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="nv">Color</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">wa</span><span class="p">;</span><span class="s"> </span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">nt</span><span class="p">;</span><span class="s"> </span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">sa</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">q</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">nsw</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="nv">Color</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">wa</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">nt</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">wa</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">sa</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">nt</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">sa</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">nt</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">q</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">sa</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">q</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nv">sa</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">nsw</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">sa</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">q</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">nsw</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span><span class="nv">nsw</span><span class="s"> </span><span class="o">!=</span><span class="s"> </span><span class="nv">v</span><span class="p">;</span><span class="s"> </span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-aust-enum"><span class="std std-numref">Listing 2.2.7</span></a> 中的模型声明了一个枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Color</span><span class="s"></span></code> ，而它必须在数据文件中被定义。每一个州变量被声明为从此枚举类型中取一个值。使用以下方式运行这个程序</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc -D<span class="s2">&quot;Color = { red, yellow, blue };&quot;</span> aust-enum.mzn
</pre></div>
</div>
<p>可能会得到输出</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wa = yellow;
nt = blue;
sa = red;
q = yellow;
nsw = blue;
v = yellow;
t = red;
</pre></div>
</div>
<div class="admonition- admonition" id="defblock-7">
<p class="first admonition-title">枚举类型变量声明</p>
<p id="index-25">一个枚举类型参数变量被声明为以下两种方式：</p>
<div class="highlight-minizincdef notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s">枚举名</span><span class="o">&gt;</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"></span>
<span class="cs">&lt;l&gt;</span><span class="o">..</span><span class="cs">&lt;u&gt;</span><span class="s"> </span><span class="p">:</span><span class="s"> </span><span class="o">&lt;</span><span class="s">变量名</span><span class="o">&gt;</span><span class="s"></span>
</pre></div>
</div>
<p class="last">其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="o">&lt;</span><span class="s">枚举名</span><span class="o">&gt;</span><span class="s"></span></code> 是枚举类型的名字， <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;l&gt;</span><span class="s"></span></code> 和 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;u&gt;</span><span class="s"></span></code> 是此枚举类型的固定枚举类型表达式。</p>
</div>
<p>枚举类型一个重要的行为是，当它们出现的位置所期望的是整数时，它们会自动地强制转换为整数。这样一来，这就允许我们使用定义在整数上的全局变量，例如</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="bp">global_cardinality_low_up</span><span class="p">([</span><span class="nv">wa</span><span class="p">,</span><span class="nv">nt</span><span class="p">,</span><span class="nv">sa</span><span class="p">,</span><span class="nv">q</span><span class="p">,</span><span class="nv">nsw</span><span class="p">,</span><span class="nv">v</span><span class="p">,</span><span class="nv">t</span><span class="p">],</span><span class="s"></span>
<span class="s">                          </span><span class="p">[</span><span class="nv">red</span><span class="p">,</span><span class="nv">yellow</span><span class="p">,</span><span class="nv">blue</span><span class="p">],[</span><span class="m">2,2</span><span class="p">,</span><span class="m">2</span><span class="p">],[</span><span class="m">2,2</span><span class="p">,</span><span class="m">3</span><span class="p">]);</span><span class="s"></span>
</pre></div>
</div>
<p>要求每种颜色至少有两个州涂上并且有三个州被涂了蓝色。</p>
<div class="admonition- admonition" id="defblock-8">
<p class="first admonition-title">枚举类型操作符</p>
<p>有一系列关于枚举类型的内部操作符：</p>
<ul class="simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nf">enum_next</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">x</span><span class="p">)</span><span class="s"></span></code>: 返回枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> 后的下一个值。 这是一个部份函数, 如果 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> 是枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 最后一个值, 则函数会返回 <span class="math notranslate nohighlight">\(\bot\)</span> 令包含这个表达式的布尔表达式返回 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="l">false</span><span class="s"></span></code> 。</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nf">enum_prev</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">x</span><span class="p">)</span><span class="s"></span></code> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nf">enum_prev</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">x</span><span class="p">)</span><span class="s"></span></code>: 返回枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">x</span><span class="s"></span></code> 的上一个值。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">enum_prev</span><span class="s"></span></code> 同样是一个部份函数。</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nf">to_enum</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">i</span><span class="p">)</span><span class="s"></span></code>: 映射一个整型表达式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> 到一个在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 的枚举类型值, 或者如果 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> 是小于等于0或大于:mzn:<cite>X`中元素的个数, 则返回 :math:</cite>bot` 。</li>
</ul>
<p>注意，一些标准函数也是可以应用于枚举类型上</p>
<ul class="last simple">
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">card</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="s"></span></code>: 返回枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 的势。</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">min</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="s"></span></code>: 返回枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 中最小的元素。</li>
<li><code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">max</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="s"></span></code>: 返回枚举类型 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">X</span><span class="s"></span></code> 中最大的元素。</li>
</ul>
</div>
</div>
<div class="section" id="sec-complex">
<span id="id6"></span><h2>2.2.5. 复杂约束<a class="headerlink" href="#sec-complex" title="Permalink to this headline">¶</a></h2>
<p id="index-26">约束是MiniZinc模型的核心。我们已经看到了简单关系表达式，但是约束其实是比这更加强大的。
一个约束可以是任何布尔型表达式。想象一个包含两个时间上不能重叠的任务的调度问题。如果 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s1</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s2</span><span class="s"></span></code> 是相对应的起始时间， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">d1</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">d2</span><span class="s"></span></code> 是相对应的持续时间，我们可以表达约束为：</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="nv">s1</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d1</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s2</span><span class="s">  </span><span class="o">\/</span><span class="s"> </span><span class="nv">s2</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d2</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s1</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>来保证任务之间互相不会重叠。</p>
<div class="admonition- admonition" id="defblock-9">
<p class="first admonition-title">布尔型</p>
<p class="last" id="index-27">MiniZinc中的布尔型表达式可以按照标准的数学语法来书写。布尔常量是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="s">真</span></code>  或 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="s">假</span></code> ，布尔型操作符有合取，即，与 (<tt class="docutils literal">/\</tt>) ，析取，即，或 (<tt class="docutils literal">\/</tt>) ，必要条件蕴含 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;-</span><span class="s"></span></code>) ，充分条件蕴含 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">-&gt;</span><span class="s"></span></code>) ，充分必要蕴含 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">&lt;-&gt;</span><span class="s"></span></code>) 以及非 (<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">not</span><span class="s"></span></code>)。内建函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> 强制转换布尔型为整型：如果参数为真，它返回1，否则返回0。</p>
</div>
<div class="literal-block-wrapper docutils container" id="ex-jobshop">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.8 </span><span class="caption-text">车间作业调度问题模型 (<a class="reference download internal" href="downloads/jobshop.mzn" download=""><tt class="xref download docutils literal">jobshop.mzn</tt></a>).</span><a class="headerlink" href="#ex-jobshop" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="nv">JOB</span><span class="p">;</span><span class="s"></span>
<span class="kt">enum</span><span class="s"> </span><span class="nv">TASK</span><span class="p">;</span><span class="s"></span>
<span class="nv">TASK</span><span class="p">:</span><span class="s"> </span><span class="nv">last</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">max</span><span class="p">(</span><span class="nv">TASK</span><span class="p">);</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="nv">JOB</span><span class="p">,</span><span class="nv">TASK</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">;</span><span class="s">                   </span><span class="c">% 任务持续时间</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">total</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">JOB</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">TASK</span><span class="p">)(</span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]);</span><span class="c">% 总持续时间</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">digs</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">ceil</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="m">10.0</span><span class="p">,</span><span class="nb">int2float</span><span class="p">(</span><span class="nv">total</span><span class="p">)));</span><span class="s"> </span><span class="c">% 输出的数值</span><span class="s"></span>
<span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="nv">JOB</span><span class="p">,</span><span class="nv">TASK</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">total</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s">          </span><span class="c">% 起始时间</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">total</span><span class="p">:</span><span class="s"> </span><span class="nv">end</span><span class="p">;</span><span class="s">                            </span><span class="c">% 总结束时间</span><span class="s"></span>


<span class="k">constraint</span><span class="s"> </span><span class="c">%% 保证任务按照顺序出现 </span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">JOB</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">TASK</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">last</span><span class="p">)</span><span class="s"> </span>
<span class="s">            </span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nf">enum_next</span><span class="p">(</span><span class="nv">TASK</span><span class="p">,</span><span class="nv">j</span><span class="p">)])</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">        </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">last</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">last</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">end</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="c">%% 保证任务之间没有重叠</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">TASK</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">JOB</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nv">i</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">k</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">\/</span><span class="s"></span>
<span class="s">            </span><span class="nv">s</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">d</span><span class="p">[</span><span class="nv">k</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span>
<span class="s">        </span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">minimize</span><span class="s"> </span><span class="nv">end</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;end = </span><span class="p">\(</span><span class="nv">end</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">]</span><span class="s"> </span><span class="o">++</span><span class="s"></span>
<span class="s">       </span><span class="p">[</span><span class="s"> </span><span class="nb">show_int</span><span class="p">(</span><span class="nv">digs</span><span class="p">,</span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">++</span><span class="s"> &quot; &quot; </span><span class="o">++</span><span class="s"> </span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">last</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">         </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">JOB</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">TASK</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-jdata">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.9 </span><span class="caption-text">车间作业调度问题数据 (<a class="reference download internal" href="downloads/jdata.dzn" download=""><tt class="xref download docutils literal">jdata.dzn</tt></a>).</span><a class="headerlink" href="#ex-jdata" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">JOB</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">anon_enum</span><span class="p">(</span><span class="m">5</span><span class="p">);</span><span class="s"></span>
<span class="nv">TASK</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">anon_enum</span><span class="p">(</span><span class="m">5</span><span class="p">);</span><span class="s"></span>
<span class="nv">d</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="s"> </span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">7</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="s">  </span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">6</span><span class="p">,</span><span class="s"> </span><span class="m">8</span><span class="s"></span>
<span class="s">     </span><span class="p">|</span><span class="s"> </span><span class="m">7</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-jobshop"><span class="std std-numref">Listing 2.2.8</span></a> 中的车间作业调度模型给出了一个使用析取建模功能的现实例子。车间作业调度问题中，我们有一个作业集合，每一个包含一系列的在不同机器上的任务：任务 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"></span></code> 是在第 <span class="math notranslate nohighlight">\(i^{th}\)</span> 个作业中运行在第 <span class="math notranslate nohighlight">\(j^{th}\)</span> 个机器上的任务。每列任务必须按照顺序完成，并且运行在同一个机器上的任何两个任务在时间上都不能重叠。就算是对这个问题的小的实例找最优解都会是很有挑战性的。</p>
<p>命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --all-solutions jobshop.mzn jdata.dzn
</pre></div>
</div>
<p>求解了一个小的车间作业调度问题，并且显示了优化问题在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">all</span><span class="o">-</span><span class="nv">solutions</span><span class="s"></span></code> 下的表现。在这里，求解器只有当找到一个更好的解时才会输出它，而不是输出所有的可能最优解。这个命令下的（部分）输出是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>end = 39
 5  9 13 22 30
 6 13 18 25 36
 0  4  8 12 16
 4  8 12 16 22
 9 16 25 27 38
----------
end = 37
 4  8 12 17 20
 5 13 18 26 34
 0  4  8 12 16
 8 12 17 20 26
 9 16 25 27 36
----------
end = 34
 0  1  5 10 13
 6 10 15 23 31
 2  6 11 19 27
 1  5 10 13 19
 9 16 22 24 33
----------
end = 30
 5  9 13 18 21
 6 13 18 25 27
 1  5  9 13 17
 0  1  2  3  9
 9 16 25 27 29
----------
==========
</pre></div>
</div>
<p>表明一个结束时间为30的最优解终于被找到，并且被证明为是最优的。
通过加一个约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">end</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">30</span><span class="s"></span></code> ，并且把求解项改为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="s"></span></code> ，然后运行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --all-solutions jobshop.mzn jobshop.dzn
</pre></div>
</div>
<p>我们可以得到所有的 <em>最优解</em> 。
这个问题有3,444,375个最优解。</p>
<div class="literal-block-wrapper docutils container" id="ex-stable-marriage">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.10 </span><span class="caption-text">稳定婚姻问题模型 (<a class="reference download internal" href="downloads/stable-marriage.mzn" download=""><tt class="xref download docutils literal">stable-marriage.mzn</tt></a>).</span><a class="headerlink" href="#ex-stable-marriage" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>

<span class="kt">enum</span><span class="s"> </span><span class="nv">Men</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">anon_enum</span><span class="p">(</span><span class="nv">n</span><span class="p">);</span><span class="s"></span>
<span class="kt">enum</span><span class="s"> </span><span class="nv">Women</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nf">anon_enum</span><span class="p">(</span><span class="nv">n</span><span class="p">);</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="nv">Women</span><span class="p">,</span><span class="s"> </span><span class="nv">Men</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rankWomen</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Men</span><span class="p">,</span><span class="s"> </span><span class="nv">Women</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rankMen</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="nv">Men</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Women</span><span class="p">:</span><span class="s"> </span><span class="nv">wife</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Women</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Men</span><span class="p">:</span><span class="s"> </span><span class="nv">husband</span><span class="p">;</span><span class="s"></span>

<span class="c">% assignment</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">m</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">husband</span><span class="p">[</span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]]</span><span class="o">=</span><span class="nv">m</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">w</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">wife</span><span class="p">[</span><span class="nv">husband</span><span class="p">[</span><span class="nv">w</span><span class="p">]]</span><span class="o">=</span><span class="nv">w</span><span class="p">);</span><span class="s"></span>
<span class="c">% ranking</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">m</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">,</span><span class="s"> </span><span class="nv">o</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">     </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">m</span><span class="p">,</span><span class="nv">o</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">m</span><span class="p">,</span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]]</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span>
<span class="s">         </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">husband</span><span class="p">[</span><span class="nv">o</span><span class="p">]]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">m</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">w</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">,</span><span class="s"> </span><span class="nv">o</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">     </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">o</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">husband</span><span class="p">[</span><span class="nv">w</span><span class="p">]]</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span>
<span class="s">         </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">wife</span><span class="p">[</span><span class="nv">o</span><span class="p">]]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;wives= </span><span class="p">\(</span><span class="nv">wife</span><span class="p">)</span><span class="se">\n</span><span class="s">husbands= </span><span class="p">\(</span><span class="nv">husband</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="ex-sm-data">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.11 </span><span class="caption-text">稳定婚姻问题模型的数据文件例子。 (<a class="reference download internal" href="downloads/stable-marriage.dzn" download=""><tt class="xref download docutils literal">stable-marriage.dzn</tt></a>).</span><a class="headerlink" href="#ex-sm-data" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="nv">n</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="nv">rankWomen</span><span class="s"> </span><span class="o">=</span><span class="s"> </span>
<span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
<span class="s">  </span>
<span class="nv">rankMen</span><span class="s"> </span><span class="o">=</span><span class="s"> </span>
<span class="s"> </span><span class="p">[|</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="p">,</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"></span>
<span class="s">  </span><span class="p">|</span><span class="s"> </span><span class="m">4</span><span class="p">,</span><span class="s"> </span><span class="m">3</span><span class="p">,</span><span class="s"> </span><span class="m">2</span><span class="p">,</span><span class="s"> </span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="m">5</span><span class="s"> </span><span class="p">|];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>MiniZinc中的另外一个强大的建模特征是决策变量可以被用来访问数组 <span class="target" id="index-28"></span>array access 。作为一个例子，考虑（老式的） <em>稳定婚姻问题</em>  。我们有 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> 个（直）女以及 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> 个（直）男。每一个男士有一个女士排行榜，女士也是。我们想给每一个女士/男士找一个丈夫/妻子来使得所有的婚姻按以下意义上来说都是 <em>稳定的</em> ：</p>
<ul class="simple">
<li>每当 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 喜欢另外一个女士 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">o</span><span class="s"></span></code> 多过他的妻子 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> 时， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">o</span><span class="s"></span></code> 喜欢她的丈夫多过 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> ，以及</li>
<li>每当 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> 喜欢另外一个男士 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">o</span><span class="s"></span></code> 多过她的丈夫 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 时， <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">o</span><span class="s"></span></code> 喜欢他的妻子多过 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code>。</li>
</ul>
<p>这个问题可以很优雅地在MiniZinc中建模。模型和数据例子在 <a class="reference internal" href="#ex-stable-marriage"><span class="std std-numref">Listing 2.2.10</span></a> 和 <a class="reference internal" href="#ex-sm-data"><span class="std std-numref">Listing 2.2.11</span></a> 中分别被给出。</p>
<p>模型中的前三项声明了男士/女士的数量以及男士和女士的集合。在这里我们介绍 <em>匿名枚举类型</em> 的使用。 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Men</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Women</span><span class="s"></span></code> 都是大小为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">n</span><span class="s"></span></code> 的集合，但是我们不希望把它们混合到一起，所以我们使用了一个匿名枚举类型。这就允许MiniZinc检测到使用 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Men</span><span class="s"></span></code> 为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">Women</span><span class="s"></span></code> 或者反之的建模错误。</p>
<p>矩阵 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">rankWomen</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">rankMen</span><span class="s"></span></code> 分别给出了男士们的女士排行以及女士们的男士排行。因此，项 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">m</span><span class="p">]</span><span class="s"></span></code> 给出了女士
texttt{w}的关于男士texttt{m}的排行。在排行中的数目越小，此男士或者女士被选择的倾向越大。</p>
<p>有两个决策变量的数组： <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">wife</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">husband</span><span class="s"></span></code> 。这两个分别代表了每个男士的妻子和每个女士的丈夫。</p>
<p>前两个约束</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">m</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">husband</span><span class="p">[</span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]]</span><span class="o">=</span><span class="nv">m</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">w</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">wife</span><span class="p">[</span><span class="nv">husband</span><span class="p">[</span><span class="nv">w</span><span class="p">]]</span><span class="o">=</span><span class="nv">w</span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>确保了丈夫和妻子的分配是一致的： <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> 是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 的妻子蕴含了 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">m</span><span class="s"></span></code> 是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">w</span><span class="s"></span></code> 的丈夫，反之亦然。注意在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">husband</span><span class="p">[</span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]]</span><span class="s"></span></code> 中，下标表达式 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]</span><span class="s"></span></code> 是一个决策变量，而不是一个参数。</p>
<p>接下来的两个约束是稳定条件的直接编码：</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">m</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">,</span><span class="s"> </span><span class="nv">o</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">     </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">m</span><span class="p">,</span><span class="nv">o</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">m</span><span class="p">,</span><span class="nv">wife</span><span class="p">[</span><span class="nv">m</span><span class="p">]]</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span>
<span class="s">         </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">husband</span><span class="p">[</span><span class="nv">o</span><span class="p">]]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">m</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">w</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Women</span><span class="p">,</span><span class="s"> </span><span class="nv">o</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Men</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">     </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">o</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankWomen</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">husband</span><span class="p">[</span><span class="nv">w</span><span class="p">]]</span><span class="s"> </span><span class="o">-&gt;</span><span class="s"> </span>
<span class="s">         </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">wife</span><span class="p">[</span><span class="nv">o</span><span class="p">]]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">rankMen</span><span class="p">[</span><span class="nv">o</span><span class="p">,</span><span class="nv">w</span><span class="p">]</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
</pre></div>
</div>
<p>在有了用决策变量作为数组的下标和用标准的布尔型连接符构建约束的功能后，稳定婚姻问题的自然建模才变得可行。敏锐的读者可能会在这时产生疑问，如果数组下标变量取了一个超出数组下标集合的值，会产生什么情况。MiniZinc把这种情况看做失败：一个数组访问 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="nv">e</span><span class="p">]</span><span class="s"></span></code> 在其周围最近的布尔型语境中隐含地加入了约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">e</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nb">index_set</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span><span class="s"></span></code> ，其中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">index_set</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span><span class="s"></span></code> 给出了 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="s"></span></code> 的下标集合。</p>
<div class="admonition- admonition" id="defblock-10">
<p class="first admonition-title">匿名枚举类型</p>
<p id="index-29">一个 <em>匿名枚举类型</em> 表达式有格式 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="nf">anon_enum</span><span class="p">(</span><span class="cs">&lt;n&gt;</span><span class="p">)</span><span class="s"></span></code> ，其中 <code class="code mzndef minizincdef docutils literal highlight highlight-minizincdef"><span></span><span class="cs">&lt;n&gt;</span><span class="s"></span></code> 是一个固定的整型表达式，它定义了枚举类型的大小。</p>
<p class="last">除了其中的元素没有名字，匿名枚举类型和其他的枚举类型一样。当被输出时，它们根据枚举类型的名字被给定独有的名字。</p>
</div>
<p>例如，如下的变量声明</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">array</span><span class="p">[</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">a</span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="m">2,3</span><span class="p">];</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">2</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">;</span><span class="s"></span>
<span class="kt">var</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="m">3</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
<p>约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">a</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code> 会在 <span class="math notranslate nohighlight">\(x=1 \wedge y=2\)</span> 和 <span class="math notranslate nohighlight">\(x=2 \wedge y=3\)</span> 时得到满足。约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="o">not</span><span class="s"> </span><span class="nv">a</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">y</span><span class="s"></span></code> 会在 <span class="math notranslate nohighlight">\(x=0 \wedge y=2\)</span>，<span class="math notranslate nohighlight">\(x=0 \wedge y=3\)</span> , <span class="math notranslate nohighlight">\(x=1 \wedge y=3\)</span> 和 <span class="math notranslate nohighlight">\(x=2 \wedge y=2\)</span> 时得到满足。</p>
<p>当参数无效访问数组时，正式的MiniZinc语义会把此情况看成失败来确保参数和决策变量
的处理方式是一致的，但是会发出警告，因为这种情况下几乎总是会有错误出现。</p>
<div class="literal-block-wrapper docutils container" id="ex-magic-series">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.12 </span><span class="caption-text">魔术串问题模型 (<a class="reference download internal" href="downloads/magic-series.mzn" download=""><tt class="xref download docutils literal">magic-series.mzn</tt></a>).</span><a class="headerlink" href="#ex-magic-series" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">))));</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s">   </span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> &quot;s = </span><span class="p">\(</span><span class="nv">s</span><span class="p">)</span><span class="s">;</span><span class="se">\n</span><span class="s">&quot; </span><span class="p">]</span><span class="s"> </span><span class="p">;</span><span class="s"></span>
</pre></div>
</div>
</div>
<p id="index-30">强制转换函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> 可以被任何布尔型表达式调用。
这就使得MiniZinc建模者可以使用所谓的 <em>高价约束</em> 。
举个简单的例子，请看 <em>魔术串问题</em> ：找到一列数字 <span class="math notranslate nohighlight">\(s= [s_0,\ldots,s_{n-1}]\)</span> 使得:math:<cite>s_i</cite> 是数字 <span class="math notranslate nohighlight">\(i\)</span> 出现在 <span class="math notranslate nohighlight">\(s\)</span> 的次数。一个解的例子是 <span class="math notranslate nohighlight">\(s = [1,2,1,0]\)</span> 。</p>
<p>这个问题的一个MiniZinc模型在 <a class="reference internal" href="#ex-magic-series"><span class="std std-numref">Listing 2.2.12</span></a> 中给出。 <a class="reference internal" href="#ex-magic-series"><span class="std std-numref">Listing 2.2.12</span></a> 的使用
使得我们可以把函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="s"></span></code> 满足的次数加起来。
运行命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc --all-solutions magic-series.mzn -D <span class="s2">&quot;n=4;&quot;</span>
</pre></div>
</div>
<p>得到输出</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = [1, 2, 1, 0];
----------
s = [2, 0, 2, 0];
----------
==========
</pre></div>
</div>
<p>确切地显示出这个问题的两个解。</p>
<p>注意当有需要的时候，MiniZinc会自动地强制转换布尔型为整型以及整型为浮点型。
我们可以把 <a class="reference internal" href="#ex-magic-series"><span class="std std-numref">Listing 2.2.12</span></a> 中的约束项替换为</p>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">   </span><span class="nv">s</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="nv">n</span><span class="o">-</span><span class="m">1</span><span class="p">)(</span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="o">=</span><span class="nv">i</span><span class="p">)));</span><span class="s"></span>
</pre></div>
</div>
<p>由于MiniZinc系统实际上会自动地加入缺失的 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code>，布尔型表达式
<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="p">[</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">i</span><span class="s"></span></code> 会被自动地强制转换为整型，所以会得到同样的结果。</p>
<div class="admonition- admonition" id="defblock-11">
<p class="first admonition-title">强制转换</p>
<p id="index-31">MiniZinc中，通过使用函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> ，我们可以把一个布尔型数值emph{强制转换}为一个整型数值。
同样地，通过使用函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">int2float</span><span class="s"></span></code> ，我们也可以把一个整型数值强制转换为一个浮点型数值。
被强制转换的数值的实例化和原数值一样。例如，<code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">par</span><span class="s"> </span><span class="kt">bool</span><span class="s"></span></code> 被强制转换为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">par</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code> ，而 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="s"></span></code> 被强制转换为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="s"></span></code> 。</p>
<p class="last">通过适当地在模型中加入 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">bool2int</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">int2float</span><span class="s"></span></code> ，MiniZinc会自动地强制转换布尔型表达式为整型表达式，以及整型表达式为浮点型表达式。注意通过两步转换，它也会强制转换布尔型为浮点型。</p>
</div>
</div>
<div class="section" id="id7">
<h2>2.2.6. 集合约束<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p id="index-32">MiniZinc另外一个强大的建模特征是它允许包含整数的集合是决策变量：这表示当模型被评估时，求解器会查找哪些元素在集合中。</p>
<p>举个简单的例子， <em>0/1背包问题</em> 。这个问题是背包问题的局限版本，即我们或者选择把物品放入背包或者不放。每一个物品有一个重量和一个利润，在受限制于背包不能太满的条件下，我们想找到选取哪些物品会得到最大化利润。</p>
<p>很自然地，我们在MiniZinc中使用单个的决策变量来建模： <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">ITEM</span><span class="p">:</span><span class="s"> </span><span class="bp">knapsack</span><span class="s"></span></code> 其中 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">ITEM</span><span class="s"></span></code> 是可放置的物品集合。如果数组 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">weight</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> 和 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">profit</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="s"></span></code> 分别
给出物品 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">i</span><span class="s"></span></code> 的重量和利润，以及背包可以装载的最大重量是 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">capacity</span><span class="s"></span></code>，则一个自然的模型在 <a class="reference internal" href="#ex-knapsack-binary"><span class="std std-numref">Listing 2.2.13</span></a> 中给出。</p>
<div class="literal-block-wrapper docutils container" id="ex-knapsack-binary">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.13 </span><span class="caption-text">0/1背包问题模型 (<a class="reference download internal" href="downloads/knapsack.mzn" download=""><tt class="xref download docutils literal">knapsack.mzn</tt></a>).</span><a class="headerlink" href="#ex-knapsack-binary" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="nv">ITEM</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">capacity</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="nv">ITEM</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">profits</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">ITEM</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">weights</span><span class="p">;</span><span class="s"></span>

<span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">ITEM</span><span class="p">:</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">;</span><span class="s"></span>

<span class="k">constraint</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">weights</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="nv">capacity</span><span class="p">;</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="nv">profits</span><span class="p">[</span><span class="nv">i</span><span class="p">])</span><span class="s"> </span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;knapsack = </span><span class="p">\(</span><span class="bp">knapsack</span><span class="p">)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>注意，关键字 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"></span></code> 出现在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">set</span><span class="s"></span></code> 声明之前，表明这个集合本身是决策变量。这就和一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="kt">var</span><span class="s"></span></code> 关键字描述其中元素而不是数组自身的数组形成对比，因为此时数组的基本结构，即它的下标集合，是固定了的。</p>
<div class="literal-block-wrapper docutils container" id="ex-social-golfers">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.14 </span><span class="caption-text">高尔夫联谊问题模型 (<a class="reference download internal" href="downloads/social-golfers.mzn" download=""><tt class="xref download docutils literal">social-golfers.mzn</tt></a>).</span><a class="headerlink" href="#ex-social-golfers" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="k">include</span><span class="s"> &quot;partition_set.mzn&quot;</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">weeks</span><span class="p">;</span><span class="s">    </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">WEEK</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">weeks</span><span class="p">;</span><span class="s"> </span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">groups</span><span class="p">;</span><span class="s">   </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">GROUP</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">groups</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">size</span><span class="p">;</span><span class="s">     </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">SIZE</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">size</span><span class="p">;</span><span class="s"></span>
<span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ngolfers</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">groups</span><span class="o">*</span><span class="nv">size</span><span class="p">;</span><span class="s"> </span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">GOLFER</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">ngolfers</span><span class="p">;</span><span class="s"></span>

<span class="kt">array</span><span class="p">[</span><span class="nv">WEEK</span><span class="p">,</span><span class="nv">GROUP</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">GOLFER</span><span class="p">:</span><span class="s"> </span><span class="nv">Sched</span><span class="p">;</span><span class="s"></span>

<span class="c">% constraints</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">weeks</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">               </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="o">+</span><span class="m">1,1</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">WEEK</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">GROUP</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">           </span><span class="nb">card</span><span class="p">(</span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">size</span><span class="s"></span>
<span class="s">        </span><span class="o">/\</span><span class="s"> </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">k</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">j</span><span class="o">+</span><span class="m">1</span><span class="o">..</span><span class="nv">groups</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="c">%                Sched[i,j] &lt; Sched[i,k]</span><span class="s"></span>
<span class="c">%             /\ </span><span class="s"></span>
<span class="s">                </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="o">intersect</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">k</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{}</span><span class="s"></span>
<span class="s">           </span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">WEEK</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">          </span><span class="bp">partition_set</span><span class="p">([</span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">]</span><span class="s"> </span><span class="p">|</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">GROUP</span><span class="p">],</span><span class="s"> </span><span class="nv">GOLFER</span><span class="p">)</span><span class="s"></span>
<span class="c">%       /\ forall (j in 1..groups-1) (</span><span class="s"></span>
<span class="c">%              Sched[i,j] &lt; Sched[i,j+1]</span><span class="s"></span>
<span class="c">%          )</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="nv">weeks</span><span class="o">-</span><span class="m">1</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">i</span><span class="o">+</span><span class="m">1</span><span class="o">..</span><span class="nv">weeks</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">GROUP</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">            </span><span class="nb">card</span><span class="p">(</span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">x</span><span class="p">]</span><span class="s"> </span><span class="o">intersect</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">j</span><span class="p">,</span><span class="nv">y</span><span class="p">])</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">1</span><span class="s"></span>
<span class="s">        </span><span class="p">)</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>
<span class="c">% symmetry</span><span class="s"></span>
<span class="s">  </span><span class="k">constraint</span><span class="s"> </span>
<span class="s">    </span><span class="c">% Fix the first week %</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">GROUP</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">SIZE</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="p">((</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="nv">size</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="nv">j</span><span class="p">)</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="nv">i</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="c">% Fix first group of second week %</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">SIZE</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="p">((</span><span class="nv">i</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="nv">size</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="m">2,1</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">    </span><span class="c">% Fix first &#39;size&#39; players</span><span class="s"></span>
<span class="s">    </span><span class="k">forall</span><span class="s"> </span><span class="p">(</span><span class="nv">w</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="m">2</span><span class="o">..</span><span class="nv">weeks</span><span class="p">,</span><span class="s"> </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">SIZE</span><span class="p">)</span><span class="s"> </span><span class="p">(</span><span class="s"></span>
<span class="s">        </span><span class="nv">p</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Sched</span><span class="p">[</span><span class="nv">w</span><span class="p">,</span><span class="nv">p</span><span class="p">]</span><span class="s"></span>
<span class="s">    </span><span class="p">);</span><span class="s"></span>
<span class="s">  </span>
<span class="k">solve</span><span class="s"> </span><span class="k">satisfy</span><span class="p">;</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">Sched</span><span class="p">[</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">])</span><span class="s"> </span><span class="o">++</span><span class="s"> &quot; &quot; </span><span class="o">++</span><span class="s"></span>
<span class="s">         </span><span class="k">if</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">groups</span><span class="s"> </span><span class="k">then</span><span class="s"> &quot;</span><span class="se">\n</span><span class="s">&quot; </span><span class="k">else</span><span class="s"> &quot;&quot; </span><span class="k">endif</span><span class="s"> </span><span class="p">|</span><span class="s"></span>
<span class="s">         </span><span class="nv">i</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">WEEK</span><span class="p">,</span><span class="s"> </span><span class="nv">j</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">GROUP</span><span class="s"> </span><span class="p">];</span><span class="s"></span>
</pre></div>
</div>
</div>
<p>我们来看一个更复杂的关于集合约束的例子， <a class="reference internal" href="#ex-social-golfers"><span class="std std-numref">Listing 2.2.14</span></a> 中给出的高尔夫联谊问题。
这个问题的目的是给 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">groups</span><span class="s"></span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">size</span><span class="s"></span></code> 个高尔夫手在 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">weeks</span><span class="s"></span></code> 时间内安排一个高尔夫联赛。每一周我们需要安排 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">groups</span><span class="s"></span></code> 个大小为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">size</span><span class="s"></span></code> 的不同的组。任何一对高尔夫手都不能一起出现于两个组中进行比赛。</p>
<p>模型中的变量是第 <span class="math notranslate nohighlight">\(i^{th}\)</span> 周第 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">j</span><span class="s">^</span><span class="p">{</span><span class="nv">th</span><span class="p">}</span><span class="s"></span></code> 组的高尔夫手:mzn:<cite>Sched[i,j]</cite> 组成的集合。</p>
<p>11-32行中的约束首先对每一周的第一个集合进行一个排序来去除掉周之间可以互相调换的对称。
然后它对每一周内的集合进行了一个排序，同时使得每一个集合的势为 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">size</span><span class="s"></span></code> 。
接下来通过使用全局约束 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="bp">partition_set</span><span class="s"></span></code> ，确保了每一周都是对高尔夫手集合的一个划分。
最后一个约束确保了任何两个高尔夫手都不会一起在两个组内比赛（因为任何两个组的交集的势最多都是1）。</p>
<p id="index-33">我们也有</p>
<p>在34-46行中，我们也给出了去对称初始化约束：
第一周被固定为所有的高尔夫手都按顺序排列；第二周的第一组被规定为是由第一周的前几组的第一个选手组成；最后，对于剩下的周，模型规定第一个 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">size</span><span class="s"></span></code> 内的高尔夫手们出现在他们相对应的组数中。</p>
<p>运行命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc social-golfers.mzn social-golfers.dzn
</pre></div>
</div>
<p>其中数据文件定义了一个周数为4，大小为3，组数为4的问题，得到如下结果</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1..3 4..6 7..9 10..12
{ 1, 4, 7 } { 2, 5, 10 } { 3, 9, 11 } { 6, 8, 12 }
{ 1, 5, 8 } { 2, 6, 11 } { 3, 7, 12 } { 4, 9, 10 }
{ 1, 6, 9 } { 2, 4, 12 } { 3, 8, 10 } { 5, 7, 11 }
----------
</pre></div>
</div>
<p>注意范围集合是如何以范围格式输出的。</p>
</div>
<div class="section" id="id8">
<h2>2.2.7. 汇总<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>我们以一个可以阐释这一章介绍的大部分特征的复杂例子来结束这一节，
包括枚举类型，复杂约束，全局约束以及复杂输出。</p>
<div class="literal-block-wrapper docutils container" id="ex-wedding">
<div class="code-block-caption"><span class="caption-number">Listing 2.2.15 </span><span class="caption-text">使用枚举类型规划婚礼座位 (<a class="reference download internal" href="downloads/wedding.mzn" download=""><tt class="xref download docutils literal">wedding.mzn</tt></a>).</span><a class="headerlink" href="#ex-wedding" title="Permalink to this code">¶</a></div>
<div class="highlight-minizinc notranslate"><div class="highlight"><pre><span></span><span class="kt">enum</span><span class="s"> </span><span class="nv">Guests</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="s"> </span><span class="nv">bride</span><span class="p">,</span><span class="s"> </span><span class="nv">groom</span><span class="p">,</span><span class="s"> </span><span class="nv">bestman</span><span class="p">,</span><span class="s"> </span><span class="nv">bridesmaid</span><span class="p">,</span><span class="s"> </span><span class="nv">bob</span><span class="p">,</span><span class="s"> </span><span class="nv">carol</span><span class="p">,</span><span class="s"> </span>
<span class="s">  </span><span class="nv">ted</span><span class="p">,</span><span class="s"> </span><span class="nv">alice</span><span class="p">,</span><span class="s"> </span><span class="nv">ron</span><span class="p">,</span><span class="s"> </span><span class="nv">rona</span><span class="p">,</span><span class="s"> </span><span class="nv">ed</span><span class="p">,</span><span class="s"> </span><span class="nv">clara</span><span class="p">};</span><span class="s"> </span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Seats</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">12</span><span class="p">;</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Hatreds</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="m">1</span><span class="o">..</span><span class="m">5</span><span class="p">;</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h1</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">groom</span><span class="p">,</span><span class="s"> </span><span class="nv">carol</span><span class="p">,</span><span class="s"> </span><span class="nv">ed</span><span class="p">,</span><span class="s"> </span><span class="nv">bride</span><span class="p">,</span><span class="s"> </span><span class="nv">ted</span><span class="p">];</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">h2</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">[</span><span class="nv">clara</span><span class="p">,</span><span class="s"> </span><span class="nv">bestman</span><span class="p">,</span><span class="s"> </span><span class="nv">ted</span><span class="p">,</span><span class="s"> </span><span class="nv">alice</span><span class="p">,</span><span class="s"> </span><span class="nv">ron</span><span class="p">];</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">Males</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="nv">groom</span><span class="p">,</span><span class="s"> </span><span class="nv">bestman</span><span class="p">,</span><span class="s"> </span><span class="nv">bob</span><span class="p">,</span><span class="s"> </span><span class="nv">ted</span><span class="p">,</span><span class="s"> </span><span class="nv">ron</span><span class="p">,</span><span class="nv">ed</span><span class="p">};</span><span class="s"></span>
<span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="nv">Guests</span><span class="p">:</span><span class="s"> </span><span class="nv">Females</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="p">{</span><span class="nv">bride</span><span class="p">,</span><span class="nv">bridesmaid</span><span class="p">,</span><span class="nv">carol</span><span class="p">,</span><span class="nv">alice</span><span class="p">,</span><span class="nv">rona</span><span class="p">,</span><span class="nv">clara</span><span class="p">};</span><span class="s"> </span>

<span class="kt">array</span><span class="p">[</span><span class="nv">Guests</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">pos</span><span class="p">;</span><span class="s"> </span><span class="c">% 客人的座位</span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p1</span><span class="p">;</span><span class="s">  </span><span class="c">% 互相憎恶的客人1的座位 </span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">p2</span><span class="p">;</span><span class="s">  </span><span class="c">% 互相憎恶的客人2的座位 </span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="m">0</span><span class="o">..</span><span class="m">1</span><span class="p">:</span><span class="s"> </span><span class="nv">sameside</span><span class="p">;</span><span class="s">  </span><span class="c">% 互相憎恶的客人是否坐在同一边 </span><span class="s"></span>
<span class="kt">array</span><span class="p">[</span><span class="nv">Hatreds</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">Seats</span><span class="p">:</span><span class="s"> </span><span class="nv">cost</span><span class="p">;</span><span class="s">  </span><span class="c">% 互相憎恶的客人的距离</span><span class="s"></span>

<span class="k">include</span><span class="s"> &quot;alldifferent.mzn&quot;</span><span class="p">;</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="bp">alldifferent</span><span class="p">(</span><span class="nv">pos</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">g</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Males</span><span class="p">)(</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">g</span><span class="p">]</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">g</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Females</span><span class="p">)(</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">g</span><span class="p">]</span><span class="s"> </span><span class="o">mod</span><span class="s"> </span><span class="m">2</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="m">0</span><span class="s"> </span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="o">not</span><span class="s"> </span><span class="p">(</span><span class="nv">pos</span><span class="p">[</span><span class="nv">ed</span><span class="p">]</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="p">{</span><span class="m">1,6</span><span class="p">,</span><span class="m">7,12</span><span class="p">});</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">pos</span><span class="p">[</span><span class="nv">bride</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">])</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">1</span><span class="s"> </span><span class="o">/\</span><span class="s"> </span>
<span class="s">           </span><span class="p">(</span><span class="nv">pos</span><span class="p">[</span><span class="nv">bride</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">groom</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">);</span><span class="s"></span>
<span class="k">constraint</span><span class="s"> </span><span class="k">forall</span><span class="p">(</span><span class="nv">h</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Hatreds</span><span class="p">)(</span><span class="s"></span>
<span class="s">               </span><span class="nv">p1</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h1</span><span class="p">[</span><span class="nv">h</span><span class="p">]]</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">               </span><span class="nv">p2</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">pos</span><span class="p">[</span><span class="nv">h2</span><span class="p">[</span><span class="nv">h</span><span class="p">]]</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">               </span><span class="nv">sameside</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nb">bool2int</span><span class="p">(</span><span class="nv">p1</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="s"> </span><span class="o">&lt;-&gt;</span><span class="s"> </span><span class="nv">p2</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">&lt;=</span><span class="s"> </span><span class="m">6</span><span class="p">)</span><span class="s"> </span><span class="o">/\</span><span class="s"></span>
<span class="s">               </span><span class="nv">cost</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">=</span><span class="s"> </span><span class="nv">sameside</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="nb">abs</span><span class="p">(</span><span class="nv">p1</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">[</span><span class="nv">h</span><span class="p">])</span><span class="s"> </span><span class="o">+</span><span class="s"></span>
<span class="s">                  </span><span class="p">(</span><span class="m">1</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">sameside</span><span class="p">[</span><span class="nv">h</span><span class="p">])</span><span class="s"> </span><span class="o">*</span><span class="s"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="m">13</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p1</span><span class="p">[</span><span class="nv">h</span><span class="p">]</span><span class="s"> </span><span class="o">-</span><span class="s"> </span><span class="nv">p2</span><span class="p">[</span><span class="nv">h</span><span class="p">])</span><span class="s"> </span><span class="o">+</span><span class="s"> </span><span class="m">1</span><span class="p">)</span><span class="s"> </span><span class="p">);</span><span class="s"></span>

<span class="k">solve</span><span class="s"> </span><span class="k">maximize</span><span class="s"> </span><span class="nb">sum</span><span class="p">(</span><span class="nv">h</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Hatreds</span><span class="p">)(</span><span class="nv">cost</span><span class="p">[</span><span class="nv">h</span><span class="p">]);</span><span class="s"></span>

<span class="k">output</span><span class="s"> </span><span class="p">[</span><span class="s"> </span><span class="nb">show</span><span class="p">(</span><span class="nv">g</span><span class="p">)</span><span class="o">++</span><span class="s">&quot; &quot; </span><span class="p">|</span><span class="s"> </span><span class="nv">s</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Seats</span><span class="p">,</span><span class="nv">g</span><span class="s"> </span><span class="k">in</span><span class="s"> </span><span class="nv">Guests</span><span class="s"> </span><span class="k">where</span><span class="s"> </span><span class="nb">fix</span><span class="p">(</span><span class="nv">pos</span><span class="p">[</span><span class="nv">g</span><span class="p">])</span><span class="s"> </span><span class="o">==</span><span class="s"> </span><span class="nv">s</span><span class="p">]</span><span class="s"></span>
<span class="s">       </span><span class="o">++</span><span class="s"> </span><span class="p">[</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">];</span><span class="s"> </span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#ex-wedding"><span class="std std-numref">Listing 2.2.15</span></a> 中的模型安排婚礼桌上的座位。这个桌子有12个编码的顺序排列的座位，每边有6个。
男士必须坐奇数号码的座位，女士坐偶数。Ed由于恐惧症不能坐在桌子的边缘，新郎和新娘必须坐在彼此旁边。我们的目的是最大化已知的互相憎恶的人之间的距离。如果在同一边，座位之间的距离是座位号码之间的差，否则则是和其对面座位的距离+ 1。</p>
<p>注意在输出语句中我们观察每个座位 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">s</span><span class="s"></span></code> 来找一个客人 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nv">g</span><span class="s"></span></code> 分配给此座位。我们利用内建函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">fix</span><span class="s"></span></code> ，它检查一个决策变量是否是固定的以及输出它的固定值，否则的话中断。在输出语句中使用此函数总是安全的，因为当输出语句被运行的时候，所有的决策变量都应该是固定了的。</p>
<p>运行</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ minizinc wedding.mzn
</pre></div>
</div>
<p>得到输出</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ted bride groom rona ed carol ron alice bob bridesmaid bestman clara
----------
==========
</pre></div>
</div>
<p>最终得到的座位安排在 <a class="reference internal" href="#fig-wedding"><span class="std std-numref">Fig. 2.2.2</span></a> 中给出。其中连线表示互相憎恶，总的距离是22.</p>
<div class="figure" id="id10">
<span id="fig-wedding"></span><img alt="images/wedding.svg" src="images/wedding.svg" /><p class="caption"><span class="caption-number">Fig. 2.2.2 </span><span class="caption-text">婚礼桌上座位的安排</span></p>
</div>
<div class="admonition- admonition" id="defblock-12">
<p class="first admonition-title">固定</p>
<p class="last" id="index-34">输出项中，内建函数 <code class="code mzn minizinc docutils literal highlight highlight-minizinc"><span></span><span class="nb">fix</span><span class="s"></span></code> 检查一个决策变量的值是否固定，然后把决策变量的实例化强制转换为参数。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="predicates.html" class="btn btn-neutral float-right" title="2.3. 谓词和函数" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modelling.html" class="btn btn-neutral" title="2.1. MiniZinc基本模型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.2.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>