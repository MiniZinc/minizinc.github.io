

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.2.1. Global constraints &mdash; The MiniZinc Handbook 2.2.2</title>
  

  
  
  
  
    <link rel="canonical" href="http://www.minizinc.org/doc-latest/en/lib-globals.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/style.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4.2.2. Annotations" href="lib-annotations.html" />
    <link rel="prev" title="4.2. The MiniZinc library" href="lib.html" /> 

  
  <script src="static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
            <a href="http://www.minizinc.org">
          
            
            <img src="static/MiniZn_logo_2.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            <a href="index.html" class="reference internal icon icon-home"> The MiniZinc Handbook </a>
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part_1_overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_2_tutorial.html">2. Minizinc 指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="part_3_user_manual.html">3. User Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part_4_reference.html">4. Reference Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="spec.html">4.1. Specification of MiniZinc</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="lib.html">4.2. The MiniZinc library</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">4.2.1. Global constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#all-different-and-related-constraints">4.2.1.1. All-Different and related constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lexicographic-constraints">4.2.1.2. Lexicographic constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sorting-constraints">4.2.1.3. Sorting constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#channeling-constraints">4.2.1.4. Channeling constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counting-constraints">4.2.1.5. Counting constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packing-constraints">4.2.1.6. Packing constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scheduling-constraints">4.2.1.7. Scheduling constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extensional-constraints-table-regular-etc">4.2.1.8. Extensional constraints (table, regular etc.)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-declarations">4.2.1.9. Other declarations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lib-annotations.html">4.2.2. Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-optiontypes.html">4.2.3. Option type support</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-options.html">4.2.4. Compiler options</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-builtins.html">4.2.5. Builtins</a></li>
<li class="toctree-l3"><a class="reference internal" href="lib-flatzinc.html">4.2.6. FlatZinc builtins</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fzn-spec.html">4.3. Interfacing Solvers to Flatzinc</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The MiniZinc Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="part_4_reference.html">4. Reference Manual</a> &raquo;</li>
        
          <li><a href="lib.html">4.2. The MiniZinc library</a> &raquo;</li>
        
      <li>4.2.1. Global constraints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="global-constraints">
<span id="ch-lib-globals"></span><h1>4.2.1. Global constraints<a class="headerlink" href="#global-constraints" title="Permalink to this headline">¶</a></h1>
<p>These constraints represent high-level modelling abstractions, for which
many solvers implement special, efficient inference algorithms.</p>
<div class="section" id="all-different-and-related-constraints">
<h2>4.2.1.1. All-Different and related constraints<a class="headerlink" href="#all-different-and-related-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//all_different.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">x</tt>  to be all different.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//all_different.mzn#L13-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_disjoint</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">S</tt>  to be pairwise disjoint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//all_disjoint.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-3"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//all_equal.mzn#L7-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-4"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">all_equal</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="s">$</span><span class="nv">X</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of sets of integers <tt class="docutils literal">x</tt>  to be all equal</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//all_equal.mzn#L13-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-5"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alldifferent_except_0</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of integers <tt class="docutils literal">vs</tt>  to be all different except those
elements that are assigned the value 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//alldifferent_except_0.mzn#L5-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-6"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of distinct values in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">n</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//nvalue.mzn#L4-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-7"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">nvalue</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of distinct values in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//nvalue_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-8"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">symmetric_all_different</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires the array of integers <tt class="docutils literal">x</tt>  to be all different, and for all <tt class="docutils literal">i</tt> ,
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ]=j <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">x</tt> [ <tt class="docutils literal">j</tt> ]= <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//symmetric_all_different.mzn#L8-L10">More…</a></p>
</div>
<div class="section" id="lexicographic-constraints">
<h2>4.2.1.2. Lexicographic constraints<a class="headerlink" href="#lexicographic-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-9"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns may be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex2.mzn#L7-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-10"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greater.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-11"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greater.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-12"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greater.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-13"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greater</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically greater than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greater.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-14"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greatereq.mzn#L7-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-15"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greatereq.mzn#L15-L17">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-16"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greatereq.mzn#L23-L25">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-17"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_greatereq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically greater than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_greatereq.mzn#L31-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-18"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_less_bool.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-19"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_less_int.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-20"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_less_float.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-21"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_less</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is strictly lexicographically less than
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_less_set.mzn#L6-L23">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-22"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_lesseq_bool.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-23"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_lesseq_float.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-24"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_lesseq_int.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-25"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">lex_lesseq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is lexicographically less than or equal to
array <tt class="docutils literal">y</tt> . Compares them from first to last element, regardless of indices.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//lex_lesseq_set.mzn#L6-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-26"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">strict_lex2</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Require adjacent rows and adjacent columns in the array <tt class="docutils literal">x</tt>  to be
lexicographically ordered.  Adjacent rows and adjacent columns cannot be equal.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//strict_lex2.mzn#L7-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-27"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">s</tt>  precede <tt class="docutils literal">t</tt>  in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of <tt class="docutils literal">x</tt>
is equal to <tt class="docutils literal">t</tt> , then another element of <tt class="docutils literal">x</tt>  with a  lower index is equal
to <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//value_precede_int.mzn#L1-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-28"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">s</tt>  precede <tt class="docutils literal">t</tt>  in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of <tt class="docutils literal">x</tt>
contains <tt class="docutils literal">t</tt>  but not <tt class="docutils literal">s</tt> , then another element of <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">s</tt>  but not <tt class="docutils literal">t</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//value_precede_set.mzn#L1-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-29"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if any element of <tt class="docutils literal">x</tt>
is equal to <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1], then another element of <tt class="docutils literal">x</tt>  with a  lower index is equal
to <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//value_precede_chain_int.mzn#L3-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-30"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">value_precede_chain</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                              </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] precedes <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] in the array <tt class="docutils literal">x</tt> .</p>
<p>Precedence means that if an element of <tt class="docutils literal">x</tt>
contains <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1] but not <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ], then another element of <tt class="docutils literal">x</tt>  with lower index contains
<tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt> ] but not <tt class="docutils literal">c</tt> [ <tt class="docutils literal">i</tt>  +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//value_precede_chain_set.mzn#L3-L6">More…</a></p>
</div>
<div class="section" id="sorting-constraints">
<h2>4.2.1.3. Sorting constraints<a class="headerlink" href="#sorting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-31"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation <tt class="docutils literal">p</tt>  which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_sort.mzn#L7-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-32"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the permutation <tt class="docutils literal">p</tt>  which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_sort.mzn#L24-L32">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-33"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">p</tt>  to be the permutation which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_sort_int.mzn#L3-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-34"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">arg_sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">p</tt>  to be the permutation which causes <tt class="docutils literal">x</tt>  to be in sorted order hence
<tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] &lt;= <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]].</p>
<p>The permutation is the stable sort hence <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ]] = <tt class="docutils literal">x</tt> [ <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1]] <span class="math notranslate nohighlight">\(\rightarrow\)</span> <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> ] &lt; <tt class="docutils literal">p</tt> [ <tt class="docutils literal">i</tt> +1].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_sort_float.mzn#L3-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-35"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//decreasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-36"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//decreasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-37"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//decreasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-38"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">decreasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in decreasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//decreasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-39"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//increasing_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-40"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//increasing_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-41"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//increasing_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-42"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">increasing</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the array <tt class="docutils literal">x</tt>  is in increasing order (duplicates are allowed).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//increasing_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-43"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the multiset of values in <tt class="docutils literal">x</tt>  are the same as the
multiset of values in <tt class="docutils literal">y</tt>  but <tt class="docutils literal">y</tt>  is in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//sort.mzn#L8-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-44"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">sort</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Return a multiset of values that is the same as the
multiset of values in <tt class="docutils literal">x</tt>  but in sorted order.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//sort_fn.mzn#L7-L11">More…</a></p>
</div>
<div class="section" id="channeling-constraints">
<h2>4.2.1.4. Channeling constraints<a class="headerlink" href="#channeling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-45"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">int_set_channel</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that array of int variables <tt class="docutils literal">x</tt>  and array of set variables <tt class="docutils literal">y</tt>
are related such that ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt> ) if and only if ( <tt class="docutils literal">i</tt>  in <tt class="docutils literal">y</tt> [ <tt class="docutils literal">j</tt> ]).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//int_set_channel.mzn#L5-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-46"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of int variables, <tt class="docutils literal">f</tt>  and <tt class="docutils literal">invf</tt> , to represent
inverse functions.  All the values in each array must be within the index
set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//inverse.mzn#L6-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-47"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">inverse</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Given a function <tt class="docutils literal">f</tt>  represented as an array, return the inverse function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//inverse_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-48"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">inverse_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">f</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">invf</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains two arrays of set of int variables, <tt class="docutils literal">f</tt>  and <tt class="docutils literal">invf</tt> , so that
a <tt class="docutils literal">j</tt>  in f[ <tt class="docutils literal">i</tt> ] iff <tt class="docutils literal">i</tt>  in invf[ <tt class="docutils literal">j</tt> ].  All the values in each array’s sets
must be within the index set of the other array.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//inverse_set.mzn#L6-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-49"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">link_set_to_booleans</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain the array of Booleans <tt class="docutils literal">b</tt>  to be a representation of the set <tt class="docutils literal">s</tt> :
<tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt>  if and only if <tt class="docutils literal">b</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The index set of <tt class="docutils literal">b</tt>  must be a superset of the possible values of <tt class="docutils literal">s</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//link_set_to_booleans.mzn#L7-L11">More…</a></p>
</div>
<div class="section" id="counting-constraints">
<h2>4.2.1.5. Counting constraints<a class="headerlink" href="#counting-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-50"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take one of the values in <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//among.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-51"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">among</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of variables in <tt class="docutils literal">x</tt>  that take one of the values in <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//among_fn.mzn#L6-L9">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-52"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//at_least_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-53"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_least</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at least <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//at_least_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-54"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//at_most_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-55"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires at most <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//at_most_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-56"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">at_most1</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each pair of sets in <tt class="docutils literal">s</tt>  overlap in at most one element.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//at_most1.mzn#L4-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-57"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_eq.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-58"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">count</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_fn.mzn#L6-L7">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-59"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_eq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be the number of occurrences of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_eq.mzn#L4-L5">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-60"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_geq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be greater than or equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_geq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-61"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_gt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be strictly greater than the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_gt.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-62"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_leq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be less than or equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_leq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-63"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_lt</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be strictly less than the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_lt.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-64"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">count_neq</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">c</tt>  to be not equal to the number of occurrences
of <tt class="docutils literal">y</tt>  in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//count_neq.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-65"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nb">card</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">card</tt> [ <tt class="docutils literal">i</tt> ] is the number of occurences of <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//distribute.mzn#L5-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-66"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">distribute</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">value</span><span class="p">,</span><span class="s"></span>
<span class="s">                                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">base</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array of the number of occurences of <tt class="docutils literal">value</tt> [ <tt class="docutils literal">i</tt> ] in
<tt class="docutils literal">base</tt> . The values in <tt class="docutils literal">value</tt>  need not be distinct.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//distribute_fn.mzn#L7-L11">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-67"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//exactly_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-68"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">exactly</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">n</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">v</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires exactly <tt class="docutils literal">n</tt>  variables in <tt class="docutils literal">x</tt>  to take the value <tt class="docutils literal">v</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//exactly_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-69"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurrences of <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality.mzn#L6-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-70"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the number of occurrences of <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-71"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">counts</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the number of occurences of <tt class="docutils literal">i</tt>  in <tt class="docutils literal">x</tt>  is <tt class="docutils literal">counts</tt> [ <tt class="docutils literal">i</tt> ].</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality_closed.mzn#L6-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-72"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">global_cardinality_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns an array with number of occurences of <tt class="docutils literal">i</tt>  in <tt class="docutils literal">x</tt> .</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality_closed_fn.mzn#L8-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-73"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                    </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all <tt class="docutils literal">i</tt> , the value <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality_low_up.mzn#L5-L12">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-74"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">global_cardinality_low_up_closed</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cover</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">lbound</span><span class="p">,</span><span class="s"></span>
<span class="s">                                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">ubound</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that for all <tt class="docutils literal">i</tt> , the value <tt class="docutils literal">cover</tt> [ <tt class="docutils literal">i</tt> ] appears at least <tt class="docutils literal">lbound</tt> [ <tt class="docutils literal">i</tt> ]
and at most <tt class="docutils literal">ubound</tt> [ <tt class="docutils literal">i</tt> ] times in the array <tt class="docutils literal">x</tt> .</p>
<p>The elements of <tt class="docutils literal">x</tt>  must take their values from <tt class="docutils literal">cover</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//global_cardinality_low_up_closed.mzn#L7-L16">More…</a></p>
</div>
<div class="section" id="packing-constraints">
<h2>4.2.1.6. Packing constraints<a class="headerlink" href="#packing-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-75"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin does not exceed the
capacity <tt class="docutils literal">c</tt> .</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
<li><tt class="docutils literal">c</tt>  &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//bin_packing.mzn#L11-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-76"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_capa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">c</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin <tt class="docutils literal">b</tt>  does not exceed the
capacity <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
<li>forall <tt class="docutils literal">b</tt> , <tt class="docutils literal">c</tt> [ <tt class="docutils literal">b</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//bin_packing_capa.mzn#L11-L30">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-77"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">load</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                           </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that each item <tt class="docutils literal">i</tt>  with weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ], be put into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ] such
that the sum of the weights of the items in each bin <tt class="docutils literal">b</tt>  is equal to
<tt class="docutils literal">load</tt> [ <tt class="docutils literal">b</tt> ].</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//bin_packing_load.mzn#L10-L26">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-78"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">bin_packing_load</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">bin</span><span class="p">,</span><span class="s"></span>
<span class="s">                                                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the load of each bin resulting from packing each item <tt class="docutils literal">i</tt>  with
weight <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] into <tt class="docutils literal">bin</tt> [ <tt class="docutils literal">i</tt> ], where the load is defined as
the sum of the weights of the items in each bin.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">w</tt> [ <tt class="docutils literal">i</tt> ] &gt;=0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//bin_packing_load_fn.mzn#L12-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-79"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can still not overlap with any other rectangle.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//diffn.mzn#L6-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-80"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box <tt class="docutils literal">i</tt>
and dimension <tt class="docutils literal">j</tt> , <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension <tt class="docutils literal">j</tt> , and <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in any dimension still cannot overlap with any other box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//diffn_k.mzn#L7-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-81"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dx</span><span class="p">,</span><span class="s"></span>
<span class="s">                          </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">dy</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains rectangles <tt class="docutils literal">i</tt> , given by their origins ( <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">y</tt> [ <tt class="docutils literal">i</tt> ])
and sizes ( <tt class="docutils literal">dx</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">dy</tt> [ <tt class="docutils literal">i</tt> ]), to be non-overlapping. Zero-width
rectangles can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//diffn_nonstrict.mzn#L6-L20">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-82"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">diffn_nonstrict_k</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_posn</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">box_size</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">k</tt> -dimensional boxes to be non-overlapping. For each box <tt class="docutils literal">i</tt>
and dimension <tt class="docutils literal">j</tt> , <tt class="docutils literal">box_posn</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the base position of the box
in dimension <tt class="docutils literal">j</tt> , and <tt class="docutils literal">box_size</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the size in that dimension.
Boxes whose size is 0 in at least one dimension can be packed anywhere.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//diffn_nonstrict_k.mzn#L7-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-83"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//geost.mzn#L14-L77">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in. dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-84"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global <tt class="docutils literal">k</tt>  dimensional bounding box.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//geost.mzn#L96-L129">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds, <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds, <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-85"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">geost_smallest_bb</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">k</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_size</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">rect_offset</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">shape</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">kind</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">l</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">u</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>A global non-overlap constraint for <tt class="docutils literal">k</tt>  dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global <tt class="docutils literal">k</tt>  dimensional bounding box. In addition, it enforces that the bounding box is the smallest one containing all objects, i.e., each of the <tt class="docutils literal">2k</tt>  boundaries is touched by at least by one object.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//geost.mzn#L147-L181">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">k</tt>:             the number of dimensions</li>
<li><tt class="docutils literal">rect_size</tt>:     the size of each box in <tt class="docutils literal">k</tt>  dimensios</li>
<li><tt class="docutils literal">rect_offset</tt>:   the offset of each box from the base position in <tt class="docutils literal">k</tt>  dimensions</li>
<li><tt class="docutils literal">shape</tt>:         the set of rectangles defining the <tt class="docutils literal">i</tt> -th shape. Assumption: Each pair of boxes in a shape must not overlap.</li>
<li><tt class="docutils literal">x</tt>:        the base position of each object. <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> , <tt class="docutils literal">j</tt> ] is the position of object <tt class="docutils literal">i</tt>  in dimension <tt class="docutils literal">j</tt> .</li>
<li><tt class="docutils literal">kind</tt>:       the shape used by each object.</li>
<li><tt class="docutils literal">l</tt>:             is an array of lower bounds, <tt class="docutils literal">l</tt> [ <tt class="docutils literal">i</tt> ] is the minimum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
<li><tt class="docutils literal">u</tt>:             is an array of upper bounds, <tt class="docutils literal">u</tt> [ <tt class="docutils literal">i</tt> ] is the maximum bounding box for all objects in dimension <tt class="docutils literal">i</tt> .</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-86"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">knapsack</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">w</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">p</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">W</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">P</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that items are packed in a knapsack with certain weight and profit restrictions.</p>
<p>Assumptions:</p>
<blockquote>
<div><ul class="simple">
<li>Weights <tt class="docutils literal">w</tt>  and profits <tt class="docutils literal">p</tt>  must be non-negative</li>
<li><tt class="docutils literal">w</tt> , <tt class="docutils literal">p</tt>  and <tt class="docutils literal">x</tt>  must have the same index sets</li>
</ul>
</div></blockquote>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//knapsack.mzn#L16-L33">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">w</tt>:  weight of each type of item</li>
<li><tt class="docutils literal">p</tt>:  profit of each type of item</li>
<li><tt class="docutils literal">x</tt>:  number of items of each type that are packed</li>
<li><tt class="docutils literal">W</tt>:  sum of sizes of all items in the knapsack</li>
<li><tt class="docutils literal">P</tt>:  sum of profits of all items in the knapsack</li>
</ul>
</div>
<div class="section" id="scheduling-constraints">
<h2>4.2.1.7. Scheduling constraints<a class="headerlink" href="#scheduling-constraints" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-87"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">alternative</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Alternative constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the
optional tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments
and at most one can occur</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//alternative.mzn#L8-L15">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-88"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt> , durations <tt class="docutils literal">d</tt> , and
resource requirements <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//cumulative.mzn#L13-L46">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-89"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">cumulative</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">,</span><span class="s"></span>
<span class="s">                     </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">b</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt> , durations <tt class="docutils literal">d</tt> , and
resource requirements <tt class="docutils literal">r</tt> , never require more than a global resource bound
<tt class="docutils literal">b</tt>  at any one time. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:
- forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0 and <tt class="docutils literal">r</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//cumulative_opt.mzn#L10-L31">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-90"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//disjunctive.mzn#L12-L24">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-91"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 can be scheduled at any time,
even in the middle of other tasks. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//disjunctive_opt.mzn#L13-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-92"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//disjunctive_strict.mzn#L10-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-93"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjunctive_strict</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                             </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that a set of tasks given by start times <tt class="docutils literal">s</tt>  and durations <tt class="docutils literal">d</tt>
do not overlap in time. Tasks with duration 0 CANNOT be scheduled at any time,
but only when no other task is running. Start times are optional variables, so
that absent tasks do not need to be scheduled.</p>
<p>Assumptions:</p>
<ul class="simple">
<li>forall <tt class="docutils literal">i</tt> , <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ] &gt;= 0</li>
</ul>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//disjunctive_strict_opt.mzn#L11-L21">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-94"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">span</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d0</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="nv">opt</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">               </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Span constraint for optional tasks. Task ( <tt class="docutils literal">s0</tt> , <tt class="docutils literal">d0</tt> ) spans the optional
tasks ( <tt class="docutils literal">s</tt> [ <tt class="docutils literal">i</tt> ], <tt class="docutils literal">d</tt> [ <tt class="docutils literal">i</tt> ]) in the array arguments.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//span.mzn#L5-L14">More…</a></p>
</div>
<div class="section" id="extensional-constraints-table-regular-etc">
<h2>4.2.1.8. Extensional constraints (table, regular etc.)<a class="headerlink" href="#extensional-constraints-table-regular-etc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-95"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                  </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the DFA of <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; 0.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).  We reserve state 0 to be an always failing state.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//regular.mzn#L8-L45">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-96"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">string</span><span class="p">:</span><span class="s"> </span><span class="nv">r</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>   is accepted by the regular
expression <tt class="docutils literal">r</tt> . This constraint generates it’s DFA equivalent.</p>
<p>Regular expressions can use the following syntax:</p>
<ul class="simple">
<li>Selection:<ul>
<li>Concatenation: “12 34”, 12 followed by 34.
(Characters are assumed to be the part of the same number unless split
by syntax or whitespace.)</li>
<li>Union: “7|11”, a 7 or 11.</li>
<li>Groups: “7(6|8)”, a 7 followed by a 6 or an 8.</li>
<li>Wildcard: “.”, any value within the domain.</li>
<li>Classes: “[3-6 7]”, a 3,4,5,6, or 7.</li>
<li>Negated classes: “[^3 5]”, any value within the domain except for a 3 or a 5.</li>
</ul>
</li>
<li>Quantifiers:<ul>
<li>Asterisk: “12*”, 0 or more times a 12.</li>
<li>Question mark: “5?”, 0 or 1 times a 5. (optional)</li>
<li>Plus sign: “42+”, 1 or more time a 42.</li>
<li>Exact: “1{3}”, exactly 3 times a 1.</li>
<li>At least: “9{5,}”, 5 or more times a 9.</li>
<li>Between: “7{3,5}”, at least 3 times, but at most 5 times a 7.</li>
</ul>
</li>
</ul>
<p>Members of enumerated types can be used in place of any integer (e.g., “A B”,
A followed by B). Enumerated identifiers still use whitespace for concatenation.</p>
<div class="highlight-minizinc notranslate" id="index-97"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">regular_nfa</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">Q</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">d</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">q0</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">F</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>The sequence of values in array <tt class="docutils literal">x</tt>  (which must all be in the range 1.. <tt class="docutils literal">S</tt> )
is accepted by the NFA of <tt class="docutils literal">Q</tt>  states with input 1.. <tt class="docutils literal">S</tt>  and transition
function <tt class="docutils literal">d</tt>  (which maps (1.. <tt class="docutils literal">Q</tt> , 1.. <tt class="docutils literal">S</tt> ) -&gt; set of 1.. <tt class="docutils literal">Q</tt> )) and initial state <tt class="docutils literal">q0</tt>
(which must be in 1.. <tt class="docutils literal">Q</tt> ) and accepting states <tt class="docutils literal">F</tt>  (which all must be in
1.. <tt class="docutils literal">Q</tt> ).</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//regular_nfa.mzn#L8-L45">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-98"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint <tt class="docutils literal">x</tt>  in <tt class="docutils literal">t</tt>  where we
consider each row in <tt class="docutils literal">t</tt>  to be a tuple and <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//table_bool.mzn#L6-L28">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-99"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">table</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Represents the constraint <tt class="docutils literal">x</tt>  in <tt class="docutils literal">t</tt>  where we
consider each row in <tt class="docutils literal">t</tt>  to be a tuple and <tt class="docutils literal">t</tt>  as a set of tuples.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//table_int.mzn#L6-L28">More…</a></p>
</div>
<div class="section" id="other-declarations">
<h2>4.2.1.9. Other declarations<a class="headerlink" href="#other-declarations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-minizinc notranslate" id="index-100"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_max.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-101"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_max</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_max.mzn#L12-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-102"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_min.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-103"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nf">arg_min</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_min.mzn#L12-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-104"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">circuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of <tt class="docutils literal">x</tt>  to define a circuit where <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt>  means
that <tt class="docutils literal">j</tt>  is the successor of <tt class="docutils literal">i</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//circuit.mzn#L7-L18">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-105"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">disjoint</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s1</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s2</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that sets <tt class="docutils literal">s1</tt>  and <tt class="docutils literal">s2</tt>  do not intersect.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//disjoint.mzn#L2-L3">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-106"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the maximum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//redefinitions-2.0.mzn#L25-L33">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-107"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the maximum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//redefinitions-2.0.mzn#L36-L44">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-108"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_max_int.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-109"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">maximum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the maximum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_max_float.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-110"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">bool</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//member_bool.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-111"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//member_float.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-112"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//member_int.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-113"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the array <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//member_set.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-114"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">member</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">y</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">y</tt>  occurs in the set <tt class="docutils literal">x</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//set_member.mzn#L5-L6">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-115"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the minimum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//redefinitions-2.0.mzn#L58-L66">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-116"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">m</span><span class="p">,</span><span class="s"> </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains <tt class="docutils literal">m</tt>  to be the minimum of the values in <tt class="docutils literal">x</tt> .</p>
<p>Assumptions: | <tt class="docutils literal">x</tt> | &gt; 0.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//redefinitions-2.0.mzn#L47-L55">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-117"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_min_int.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-118"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">minimum_arg</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">float</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrain <tt class="docutils literal">i</tt>  to be the index of the minimum value in the array <tt class="docutils literal">x</tt> .
When breaking ties the least index is returned.</p>
<p>Assumption: | <tt class="docutils literal">x</tt> | &gt; 0</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//arg_min_float.mzn#L1-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-119"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                       </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//network_flow.mzn#L9-L28">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc <tt class="docutils literal">i</tt>  connects node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-120"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">network_flow_cost</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="m">1</span><span class="o">..</span><span class="m">2</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">arc</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">balance</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">weight</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">flow</span><span class="p">,</span><span class="s"></span>
<span class="s">                            </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cost</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Defines a network flow constraint with cost.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//network_flow.mzn#L39-L63">More…</a></p>
<p>Parameters:</p>
<ul class="simple">
<li><tt class="docutils literal">arc</tt>:  a directed arc of the flow network. Arc <tt class="docutils literal">i</tt>  connects node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,1] to node <tt class="docutils literal">arc</tt> [ <tt class="docutils literal">i</tt> ,2].</li>
<li><tt class="docutils literal">balance</tt>:  the difference between input and output flow for each node.</li>
<li><tt class="docutils literal">weight</tt>:  the unit cost of the flow through the arc.</li>
<li><tt class="docutils literal">flow</tt>:  the flow going through each arc.</li>
<li><tt class="docutils literal">cost</tt>:  the overall cost of the flow.</li>
</ul>
<div class="highlight-minizinc notranslate" id="index-121"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">partition_set</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">S</span><span class="p">,</span><span class="s"></span>
<span class="s">                        </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">universe</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the sets in array <tt class="docutils literal">S</tt>  to partition the <tt class="docutils literal">universe</tt> .</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//partition_set.mzn#L6-L8">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-122"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the image of function <tt class="docutils literal">x</tt>  (represented as an array) on set
of values <tt class="docutils literal">s</tt>  is <tt class="docutils literal">t</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//range.mzn#L6-L19">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-123"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">range</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns the image of function <tt class="docutils literal">x</tt>  (represented as an array) on set
of values <tt class="docutils literal">s</tt> .  ub( <tt class="docutils literal">s</tt> ) must be a subset of index_set( <tt class="docutils literal">x</tt> ) otherwise an
assertion failure will occur.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//range_fn.mzn#L8-L13">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-124"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">,</span><span class="s"></span>
<span class="s">                </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">t</tt>  for all <tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//roots.mzn#L4-L16">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-125"><div class="highlight"><pre><span></span><span class="k">function</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="bp">roots</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">,</span><span class="s"></span>
<span class="s">                               </span><span class="kt">var</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">t</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Returns <tt class="docutils literal">s</tt>  such that <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] in <tt class="docutils literal">t</tt>  for all <tt class="docutils literal">i</tt>  in <tt class="docutils literal">s</tt></p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//roots_fn.mzn#L6-L10">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-126"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sliding_sum</span><span class="p">(</span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">low</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">up</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">seq</span><span class="p">,</span><span class="s"></span>
<span class="s">                      </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">vs</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that in each subsequence <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt> ], …, <tt class="docutils literal">vs</tt> [ <tt class="docutils literal">i</tt>  + <tt class="docutils literal">seq</tt>  - 1] the sum of the
values belongs to the interval [ <tt class="docutils literal">low</tt> , <tt class="docutils literal">up</tt> ].</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//sliding_sum.mzn#L5-L14">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-127"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">subcircuit</span><span class="p">(</span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">x</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Constrains the elements of <tt class="docutils literal">x</tt>  to define a subcircuit where <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">j</tt>
means that <tt class="docutils literal">j</tt>  is the successor of <tt class="docutils literal">i</tt>  and <tt class="docutils literal">x</tt> [ <tt class="docutils literal">i</tt> ] = <tt class="docutils literal">i</tt>  means that <tt class="docutils literal">i</tt>
is not in the circuit.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//subcircuit.mzn#L8-L52">More…</a></p>
<div class="highlight-minizinc notranslate" id="index-128"><div class="highlight"><pre><span></span><span class="k">predicate</span><span class="s"> </span><span class="bp">sum_pred</span><span class="p">(</span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">i</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">set</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">sets</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">array</span><span class="s"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="s"> </span><span class="kt">of</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">cs</span><span class="p">,</span><span class="s"></span>
<span class="s">                   </span><span class="kt">var</span><span class="s"> </span><span class="kt">int</span><span class="p">:</span><span class="s"> </span><span class="nv">s</span><span class="p">)</span><span class="s"></span>
</pre></div>
</div>
<p>Requires that the sum of <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">i1</tt> ].. <tt class="docutils literal">cs</tt> [ <tt class="docutils literal">iN</tt> ] equals <tt class="docutils literal">s</tt> ,
where <tt class="docutils literal">i1</tt> .. <tt class="docutils literal">iN</tt>  are the elements of the <tt class="docutils literal">i</tt>  th set in <tt class="docutils literal">sets</tt> .</p>
<p>Nb: not called ‘sum’ as in the constraints catalog because ‘sum’ is a
MiniZinc built-in function.</p>
<p><a class="reference external" href="https://github.com/MiniZinc/libminizinc/blob/2.2.3/share/minizinc/std//sum_pred.mzn#L9-L11">More…</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lib-annotations.html" class="btn btn-neutral float-right" title="4.2.2. Annotations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lib.html" class="btn btn-neutral" title="4.2. The MiniZinc library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, 2017, 2018, Peter J. Stuckey, Kim Marriott, Guido Tack.

    </p>
  </div>
<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/80x15.png" /></a>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.2.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>